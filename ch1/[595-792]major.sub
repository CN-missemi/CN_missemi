{64877}{64977}然后，如果要更新它的话
{64978}{65080}用这个 `updatedb` 命令
{65081}{65265}通常由 cron 定期执行来更新数据库。[*] # REVIEW 
{65310}{65384}另外，查找文件是很有门道的
{65385}{65510}实际上，有时你不关心文件本身
{65511}{65573}而是文件的内容
{65604}{65576}这方面可以用前面见过的 `grep` 命令
{65577}{65919}比如 `grep foobar mcd.sh`
{65920}{65945}找到了
{65964}{66132}如果你还是想递归当前目录结构
{66133}{66177}去查找更多的文件该怎么办
{66178}{66271}你不会愿意亲手干苦活的
{66274}{66331}我们可以用 `find` 命令结合 `-exec`
{66340}{66444}但 `grep` 有一个大写 `-R` 的 flag
{66445}{66604}是可以找遍整个目录的
{66605}{66665}啊，应该是这样儿
{66688}{66723}它告诉我们，噢
{66724}{66830}`example.sh` 中有包含 `foobar` 的行
{66831}{66884}在这三个行的位置都有
{66885}{66948}并且这两个位置也有 `foobar`
{67031}{67078}这个挺省事的
{67079}{67213}主要是当你记得你用一些程序语言
{67214}{67282}写了一些代码的时候
{67283}{67366}你知道它就在你文件系统的某处躺着
{67367}{67410}但你就是想不起来
{67411}{67477}用这招就可以快速搜索
{67486}{67598}比如我可以快速搜索草稿文件夹里
{67674}{67969}所有我用了 `request` 库的 Python 代码
{67981}{68009}如果我执行命令
{68010}{68200}就能查到这些文件，精确到匹配的行
{68201}{68293}比起用 `grep`，虽然它挺好
{68294}{68388}你也可以……我用了 `ripgrep`
{68396}{68527}原理是一样的，但是它也是
{68528}{68583}加了亿点点细节
{68584}{68788}比如代码彩色和文件处理啥的
{68789}{68855}也有 Unicode 支持
{68864}{68914}而且跑的还快
{68915}{69037}所以它没为了这些花招拖慢速度
{69100}{69159}还有很多有用的 flag
{69160}{69318}比如说你想，哦，我想要点上下文
{69395}{69513}这样就是结果附近的五行
{69521}{69623}你就能知道那个 `import` 大概在哪
{69624}{69692}它周围都是什么代码
{69696}{69735}这里找这个 `import` 不怎么实用
{69736}{69825}但是比如，你要查你在哪调用了函数
{69826}{69932}它就很给力
{69963}{70175}我们也可以搜索，比如说
{70176}{70277}一个更高级的用法
{70278}{70484}解释一下，`-u` 是不忽略隐藏文件[*]
{70485}{70673}有时候你想忽略隐藏文件
{70674}{70794}但如果你想查找配置（config）文件
{70795}{70841}它们大多是默认隐藏的，这样子
{70842}{70948}然后，这里不是打印匹配内容
{70961}{71026}而我们要求它，呃，这大概是
{71027}{71129}我觉得 `grep` 做不到的
{71130}{71231}就是，我要你打印出所有
{71232}{71320}不匹配这个模式的内容
{71336}{71408}这么做可能挺奇怪的
{71409}{71452}接着往下看……
{71453}{71496}这里这个模式（pattern）是一个
{71510}{71554}小巧的正则表达式[*]
{71563}{71697}意思是，匹配行首有 `#!` 的内容
{71721}{71743}这是个 `shebang`[*]
{71744}{71912}也就是说我们在搜索没有 shebang 的文件
{71923}{72039}这里还给了一个 `-t sh` 是说
{72040}{72106}只搜索 `.sh` （后缀名）的文件
{72107}{72233}因为实际来讲 Python 或者文本文件
{72234}{72267}少了 shebang 也没问题
{72281}{72305}这里它告诉我们
{72306}{72377}「哦，`mcd.sh` 明显少了个 shebang」
{72448}{72553}我们还可以……它有一些好用的 flag
{72554}{72633}比如加上这个 `--stats` flag
{72871}{72945}它也会得到这些结果
{72946}{73054}不过它还会告诉我们 # REVIEW
{73055}{73148}比如成功匹配了多少行
{73149}{73231}查找了多少行多少文件
{73232}{73277}打印了多少 byte，等等
{73323}{73422}类似 `fd` 这种，有时候单会一个工具
{73465}{73522}其实不是很好
{73523}{73628}实际上有很多类似 `ripgrep` 的工具
{73629}{73751}比如 `ack`，也是 `grep` 一个替代
{73764}{73893}还有 `ag`，那个“银子”搜索器[*] # REVIEW
{73894}{73973}这些基本都是可替换的
{73974}{74026}有可能你用某个操作系统
{74027}{74064}发现它有某一个，没有另一个
{74065}{74201}只要知道你可以用这些工具就行
{74243}{74325}最后我想讲讲，怎么去做一些
{74326}{74381}不是去找文件或者代码
{74382}{74528}而是找一些已经执行过的命令 # REVIEW
{74606}{74717}首先，显然可以用上箭头
{74734}{74847}慢慢儿翻你的历史记录
{74848}{74927}你可能也觉得，这不是很有效率
{74928}{75091}所以 bash 有一些更简单的方法
{75101}{75137}有个 `history` 命令
{75138}{75172}它会打印出你的命令历史记录
{75181}{75277}这里我用的 zsh，所以只会打印一部分
{75278}{75407}如果我想从开头全打印出来
{75415}{75550}这就不管是啥，都给打印出来了
{75552}{75622}因为这记录挺多的
{75623}{75745}比如我只关心用了 `convert` 的命令
{75746}{75860}它把某种类型的文件转到另一种

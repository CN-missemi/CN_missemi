{41}{78}好的，欢迎回来[*]
{103}{227}今天我们要分别谈谈与 Shell 有关的两个话题
{234}{344}首先我们要讲 Shell 脚本，这主要和 bash 有关
{345}{482}这将会是你们大多数人一开始在 macOS
{483}{535}或者大多数 Linux 里接触的 Shell
{536}{565}bash 是它们默认的 Shell
{577}{621}并且其他 Shell ，像是 zsh
{622}{683}对其有良好的向后兼容，这非常棒 [*]
{684}{796}然后我们要谈谈特别方便的其他 Shell 工具
{797}{883}你们可以用它避免重复执行任务
{884}{947}像是寻找一段代码
{948}{1027}或者一些犄角旮旯的文件
{1028}{1101}bash 里也有许多很棒的内置命令
{1102}{1202}它们可以帮你做这些事情
{1257}{1338}昨天我们已经介绍了 Shell 
{1339}{1399}和它的一些特性 # REVIEW
{1400}{1478}就比如说你怎样执行一个命令
{1479}{1517}或者重定向它们（的输入输出）
{1518}{1569}今天我们将多讲一些 Shell 脚本中的
{1570}{1718}操纵变量的语法，控制流以及函数
{1738}{1840}例如，一旦你接触 Shell
{1859}{1916}说你想要定义一个变量
{1917}{2076}那是你学习编程语言第一个接触的事情[*]
{2081}{2188}你可以执行像是 `foo=bar`
{2209}{2341}并且我们可以通过 `$foo` 操作 `foo` 的值
{2365}{2430}它是 `bar`，完美~
{2455}{2533}你需要多加注意的一点是
{2534}{2601}当你面对着 bash 的时候[*]
{2602}{2647}空格至关重要[*]
{2648}{2735}主要是因为空格是个保留字
{2736}{2809}它的用途是分隔参数
{2810}{2926}例如，一些像是 `foo = bar` 的操作不管用
{2939}{3065}Shell 会告诉你它为什么无法生效 # REVIEW
{3066}{3118}这是它说因为 `foo` 命令无法生效
{3127}{3188}比如这里提示 `foo` 不存在
{3189}{3284}实际发生的是，我们没有将 `bar` 赋给 `foo`
{3309}{3495}而是用 `=` 和 `bar` 作为参数调用了 `foo` 程序
{3537}{3649}通常，你需要特别关注这类问题
{3657}{3718}比如说一些带有空格的文件名
{3719}{3919}你需要小心地把他们用引号引起来
{3920}{4036}让我们更深入些，探讨一下怎样在 bash 中处理字符串
{4037}{4095}我们有两种定义字符串的方法：
{4096}{4221}可以用双引号定义字符串
{4222}{4345}或者可以用单……
{4346}{4372}呃，对不起
{4402}{4440}使用单引号（定义）
{4507}{4591}虽然对于纯文本字符串，这两种方式是等价的
{4592}{4669}但是对于其余的字符串，则不相同
{4670}{4899}例如,我们执行 `echo "Value is $foo"`
{4920}{5034}其中 `$foo` 将被展开为字符串
{5035}{5131}并且替换掉 Shell 中 `foo` 变量的值
{5140}{5297}如果我们用单引号来重复实验
{5298}{5368}我们仅仅会得到原样的 `$foo`
{5381}{5456}单引号中的变量将不会被替换
{5460}{5534}脚本真的十分易于编写
{5543}{5646}这个就好比…它有点像你更熟悉的 Python # REVIEW
{5658}{5722}你可能没意识到这点
{5738}{5832}这就是给变量赋值的方式
{5833}{5945}我们稍后还会看到 bash 也有控制流技术
{5946}{6008}像是 for 循环、while 循环
{6009}{6131}另一个重点是，我们可以定义函数
{6132}{6257}我们可以访问我在此处定义的函数
{6258}{6379}这里我们已经定义了 `mcd` 函数
{6380}{6483}到目前为止，我们已经了解
{6484}{6567}如何利用管道执行几个命令 # REVIEW
{6568}{6627}昨天简要地说过
{6628}{6754}但是很多时候你想先做一件事，然后另一件事
{6755}{6933}有点像我们这里的顺序执行
{6934}{7015}看这里，例如，我们可以调用 `mcd` 函数
{7116}{7207}首先我们调用 `mkdir` 命令
{7208}{7275}它会创建一个目录
{7299}{7384}在这里，`$1` 就像是一个特殊变量
{7385}{7427}这就是 bash 运作的方式
{7428}{7569}类似于其他脚本语言的 `argv`
{7570}{7705}数组 `argv` 的第一项将包含参数[*]
{7706}{7741}在 bash 中同样的东西是 `$1`
{7742}{7871}一般来说，bash 中许多 `$` 开头的东西
{7872}{7893}它们都是被保留的[*]
{7894}{7963}我们之后会看到更多的例子
{7985}{8051}一旦我们创建了文件夹，
{8052}{8115}我们就 `cd` 进去
{8142}{8236}这其实是个挺常见的流程 # REVIEW
{8250}{8350}实际上，我们直接将其键入到 Shell
{8351}{8408}它就会起作用，定义这个函数
{8419}{8566}但是有时候，把代码写到文件里更好
{8567}{8696}然后我们就可以 `source` 这个文件
{8697}{8808}这就会在 Shell 中加载脚本并执行
{8827}{8904}虽然现在看起来无事发生
{8905}{9040}但是现在 Shell 中已经定义了 `mcd` 函数
{9057}{9169}因此我们现在能，比如说执行 `mcd test`
{9170}{9289}就从 `tool` 目录移到了 `test` 目录
{9290}{9402}我们创建了文件夹并且进入其中
{9481}{9565}还有什么。结果是...
{9566}{9667}我们可以通过 `$1` 访问第一个参数
{9668}{9789}这里有许多被保留的命令[*]
{9790}{9902}例如 `$0` 将会是脚本的名字
{9903}{9989}`$2` 到 `$9` 是 bash 脚本的
{9990}{10120}第二个到第九个参数
{10121}{10261}有一些保留字可以直接在 Shell 中使用
{10262}{10510}例如 `$?` 能获取上条命令的错误代码（返回值）
{10574}{10612}我会简要解释这些
{10613}{10779}再比如，`$_` 会获取上条命令的最后一个参数
{10780}{10903}因此，我们搞定这个的另一种方式是
{10904}{11023}我们可以执行 `mkdir test`
{11024}{11102}与其重写一遍 `test`
{11103}{11200}不如我们用 `$_` 访问上条命令的一部分
{11201}{11353}也就是最后一个参数
{11354}{11422}它将被替换成 `test` 
{11423}{11489}现在我们进去了 `test` 目录
{11568}{11628}像这样的例子很多，你应当熟悉他们
{11629}{11770}另一个我经常用的叫做 `bang bang`（`!!`）
{11771}{11899}每当，比如说，你试着创建某些东西
{11900}{11935}但你没有足够权限的时候
{11936}{11973}正是这个东西的用武之处
{11974}{12031}然后，你可以执行 `sudo !!`
{12045}{12142}`!!` 会被你刚刚尝试的命令取代
{12143}{12203}现在来试一下
{12204}{12259}现在它就提示我输入密码
{12260}{12315}因为我有了 sudo 权限

【252】当你使用 Shell 时，比如

我们现在正在对比两个数，两个整数，看它们是否相同

又比如，-F 命令会让我们知道

是否存在一个文件

这是你以后会频繁用上的

回到例子

如果文件中没有 foobar 会发生什么

像之前有非 0 的错误代码

【260】我们也输出

文件中没有 foobar 字符串

我们将添加一个，而我们所做的是

我们输入 # foobar

并且希望这是一个文件注释

【265】之后我们用 >> 运算符把它添在文件末尾

这里尽管文件充斥着脚本

但我们预先并不知道，我们需要改文件名

事实上我们可以键入这些

我们已经有这个脚本操作的正确权限

【270】我可以举一些例子，我们在这个夹里有一些文件

mcd 是我们先前看到的 mcd 函数

还有其它脚本函数

甚至我们可以给它提供自身的脚本，以检查是否有 foobar 字符串

我们运行它，首先我们可以看到我们成功地列出了很多的变量

【275】

我们有 date 变量

它成功的带入了当前时间

接着我们加入三个参数运行这个程序

随机的 pid 识别码

【280】之后它告诉我们 mcd 没有 foobar 字符串

所以我们新添加了一个

并且这个 script 文件也没有

像现在让我们看看 mcd

它就有我们要找的注释

【285】当你在执行脚本时另一个需要知道的是

像这里，我们有三个完全不同的参数

但通常

你会用一些更加简洁的方式输入参数



【290】例如这里，

如果我想查找所有的 .sh 脚本

我们只需要键入`ls *.sh`

这是大多数 Shell 都有的一种展开文件名的方式

叫做通配

【295】这里，如你所想，会显示出

任何含有任意字符的，以 .sh 后缀的东西



如我们所料，我们得到了 example.sh 和 mcd.sh

我们也有这些 project1 和 project2，并且如果这里有……

【300】比如，我们可以建一个 project42

现在如果我只想找有一个特定字符的项

而不是两个字符

然后，像其它任意的字符

我们可以使用 ? 标记，? 标记只会展开一个字符

【305】我们得到了列出的，

先是 project1 再是 project2 

总而言之，通配符非常强大，你也可以组合它们

一个常用模式是花括号

我们在这个文件夹里有一个 image 文件 

【310】我们想把 image 文件格式由 PNG 转为 JPG

我们可能会复制它，或者……

这确实是常见情况，有两个或者更多相当相似的参数

你想用它们做一些事，把它们当作参数传给命令

你可以这样做，或者更简洁的做法是

【315】你可以只键入`image.{png,jpg}`

这里，有一些彩色的反应，它将会做的是

展开成上面的那行

实际上，我可以让 zsh 为我做这些，也就是这里正进行的[*]
*一种 Shell

这确实很强大，所以比如

【320】你可以做一些像……我们可以……

touch 一串 foo，所有的 foo 都会被展开

你也可以进行多层操作，建立笛卡尔系

如果我们有一些像这样的组，我们这里有一组，{1,2}

之后这里又有 {1,2,3}

【325】这会用使两组展开式形成笛卡尔积

而后展开积里的所有表达式

我们就可以很快地 touch 了

你也可以将 * 通配符与 {} 通配符结合

甚至你可以用一些范围表示，像，我们可以键入`mkdir`

【330】我们创建 foo ，bar 目录

之后我们可以在这些行中做一些事

这将会展开到 foo/a，foo/b ……

像所有的组合，直到 j

bar 也是同理，我之前没有试过……

【335】但是没错，我们得到了我们所能 touch 的所有组合

现在，如果我们在两个目录中建一些不同的东西



我们可以再次展示……用我们之前看到的流程代替

我们想查看这两个文件夹中有什么不同文件

【340】对我们来说很明显，我们刚刚看到了，是 x 和 y

但是我们可以用 Shell 去为我们区分

一个 ls 和另一个 ls 输出的不同之处

如我们所料，我们得到了

x 只在第一个文件夹里：

【345】y 只在第二个文件夹里

还有，目前我们只看了 bash 脚本，如果你喜欢其它的

脚本，像 bash 对一些工作可能并不是最好的选择

它可能会很棘手。事实上你可以

用很多不同的语言写与 Shell 工具交互的脚本

【350】例如，我们在这里看一个

Python 脚本，它在开头有神奇的一行

我现在不会解释

我们有 import sys

这很像…… Python 默认下不会尝试和 Shell 交互

【355】所以你需要导入一些库

之后我们在做一个

确实很傻的事情

就是仅仅作用于 sys.argv[1:] 

sys.argv 是一种类似于 bash 中 $0，$1 等等的东西

【360】像参数向量，我们将它倒序输出

开始时那神奇的一行叫做 shebang

这是 Shell 了解该如何运行这个程序的方式



你随时可以键入类似

【365】`python script.py`之后是`a b c`

它就会运行，像这

但是如果我想让它可以被 Shell 执行该怎么办？



Shell 是用首行识别到需要用 python 解释器运行这个程序



【371】并且第一行

给了这东西所在的路径

然而，你可能不知道

像不同的设备很可能

【375】会把 python 放在不同的地方

你当然不想去设想 python 会装在哪儿

其它解释器也是一样

所以你可以做的一件事是

env 命令

【380】你也可以在 shebang 中给出参数

所以我们正在做的就是指定 env 命令去运行

这是对于绝大多数系统而言的，有一些例外

但是对于绝大多数系统而言它在 uer/bin

那儿有很多二进制文件

【385】之后我们用参数 python 呼叫它

它将会使用

我们第一节课所见到的 path 环境变量



它会在那些路径中找 Python 二进制文件

【390】接着用它去解释这个文件

这使得它有更好的可移植性

能让它在我的，你的还有其它的设备上运行

另一件事是 bash 并不是真正现代化的 #REVIEW

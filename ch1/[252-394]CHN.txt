【252】比如我们现在正在对比两个数

两个整数，看它们是否相同

又比如，`-f` flag 会让我们知道

是否存在一个文件

这是你以后会频繁用上的

回到例子

如果文件中没有 `foobar` 会发生什么

像之前有非 `0` 的错误代码

【260】我们也输出

文件中没有 `foobar` 字符串

我们将添加一个，而我们所做的是

我们输入 `# foobar`

蒙一手这 `#` 是个文件注释格式

【265】之后我们用 `>>` 操作符把它添在文件末尾

这里尽管文件名已经传给了脚本

但我们预先并不知道文件名

所以我们需要用文件名变量在这里展开 # REVIEW

我们可以运行这个试试

我们已经有这个脚本的正确权限

【270】我可以举一些例子，我们在这个夹里有一些文件

`mcd` 是我们先前看到的 `mcd` 函数

还有其它脚本函数

甚至可以把它自己传给它，检查是否有 `foobar`

我们运行它，首先我们可以看到

我们成功地列出了很多的变量

【275】我们有 `date` 命令

它成功地被替换成了当前时间

接着是这个带着三个参数的程序

它的随机的 pid 识别码

【280】之后它告诉我们 `mcd` 没有 `foobar` 字符串

所以我们新添加了一个

并且这个 `script.py` 文件也没有

像现在让我们看看 `mcd`

它就有我们要找的注释

【285】当你在执行脚本时另一个需要知道的是

像这里，我们有三个完全不同的参数

但通常

你会用一些更加简洁的方式输入参数

【290】例如这里，

如果我想查找所有的 `.sh` 脚本

我们只需要键入 `ls *.sh`

这是大多数 Shell 都有的一种展开文件名的方式

叫做通配

【295】这里，如你所想，会显示出

所有含有任意字符，且以 `.sh` 为后缀的东西

如我们所料，得到了 `example.sh` 和 `mcd.sh`

我们也有这些 `project1` 和 `project2`

并且如果这里有……

【300】比如，我们可以建一个 `project42`

现在如果我只想找有一个特定字符的项

而不是两个字符

然后，像其它任意的字符

我们可以使用 `?` 标记，`?` 标记只会展开一个字符

【305】我们得到了列出的

先是 `project1` 再是 `project2` 

总而言之，通配符非常强大，你也可以组合它们

一个常用模式是花括号

我们在这个文件夹里有一个图片 

【310】我们想把图片文件格式由 PNG 转为 JPG

我们可能会复制它，或者……

这确实是常见情况，有两个或多个挺相似的参数

你想把它们当作参数传给命令

你可以这样做，但更简洁的做法是

【315】你可以只键入 `image.{png,jpg}`

这里有一些彩色的反馈……

总之，它会展开成上面的那行

实际上，我可以让 zsh 为我做这些

也就是这里正进行的

这确实很强大，所以比如

【320】你可以做一些像……我们可以……

`touch` 一串 `foo`，所有 `foo` 都会被展开

你也可以进行多层操作，建立笛卡尔系

如果我们有一些像这样的组

我们这里有一组 `{1,2}`

之后这里又有 `{1,2,3}`

【325】这会用使两组展开式形成笛卡尔积

而后展开积里的所有表达式

我们就可以很快地 `touch` 了

你也可以将 `*` 通配符与 `{}` 通配符结合

甚至你可以用一些范围表示

像，我们可以键入 `mkdir`

【330】我们创建 `foo`，`bar` 目录

之后可以在这些行里搞事情

这将会展开到 `foo/a`，`foo/b` ……

像所有的组合，直到 `j`

`bar` 同理，虽然说实话我没试……

【335】但是没错，我们得到了我们所能 touch 的所有组合

现在，如果我们在两个目录中建一些不同的东西

我们可以再次展示……

用我们之前看到的流程代替

我们想查看这两个文件夹中有什么不同文件

【340】非常显然，我们刚刚看到了，是 `x` 和 `y`

但是我们可以用 Shell 去比对

一个 `ls` 和另一个 `ls` 输出的不同

如我们所料，我们得到了

`x` 只在第一个文件夹里

【345】`y` 只在第二个文件夹里

还有，目前我们只看了 bash 脚本

如果你喜欢其它的脚本……

像 bash 对一些工作可能并不是最好的选择

它可能会很棘手。事实上你可以

用很多语言写和 Shell 工具交互的脚本

【350】例如，我们在这里看一个

Python 脚本，它的开头有神秘的一行代码 # REVIEW

我暂且不去解释

我们有 `import sys`

这很像…… Python 默认不会尝试和 Shell 交互

【355】所以你需要导入一些库

之后我们在做一个

确实很傻的事情

就只是迭代 `sys.argv[1:]`

`sys.argv` 是一种类似于 

bash 中 `$0`，`$1` 等等的东西

【360】就是一个参数 vector，我们将它倒序输出

开始时那神奇的一行叫做 shebang

Shell 通过它了解怎么运行这个程序

你随时可以键入类似

【365】`python script.py` 之后是 `a b c`

像这样它就会运行

但如果我想让它从 Shell 就能执行呢？

Shell 是用首行识别到

需要用 Python 解释器运行这个程序

【371】并且第一行

给了这东西所在的路径

然而，你可能不知道

像不同的设备很可能

【375】会把 Python 放在不同的地方

最好别假设 Python 装在哪儿

其它解释器也是一样

所以你可以做的是调用 `env` 命令

【380】你也可以在 shebang 中给出参数

所以我们现在是在调用 `env` 命令

这是对于绝大多数系统而言的，有一些例外

但是对于绝大多数系统而言它在 `usr/bin`

那儿有很多二进制文件

【385】之后用参数 Python 调用它[*]

它会使用

第一节课提到的 `path` 环境变量

`env` 会在那些路径中找 Python 二进制文件

【390】接着用它去解释这个脚本

这样有更好的可移植性

能让它在我的，你的还有其它的设备上运行

另一件事是 bash 并不是真正现代化的

它好久之前就被开发出来了

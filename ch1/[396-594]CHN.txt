【396】 有些时候调试起来简直要命

一般来讲，调试的时候直觉会时不时地失效

就像我们之前看到的 `foo` 命令不存在

因此我们在讲义里有一个很高效的工具

这个工具叫做 shellcheck 

链接已经放在讲义里了

它能给出 warning 和语法错误

【406】 还能指出哪些地方你没正确引用

或者是哪些地方你的空格打错了

举个很简单的例子

`mcd.sh` 这个文件，我们得到了一些错误提示

这些提示说：「嗨！我们惊奇地发现漏掉了一些东西」

这可能导致 `mcd.sh` 在别的系统无法解译成功

并且， `cd` 后面有一个指令

而 `cd` 可能不会被正确执行

【416】 这里你可能想用 `cd ... || exit` 

之类的东西来代替它

回到这行命令

如果 `cd` 命令没有正确结束

你就不能进入那个文件夹

因为要么你没有权限，要么文件夹不存在

之后程序会给你一个非零的错误码

然后你就会执行 `exit` 命令，停止脚本的运行

【426】 而不是在一个不存在的路径继续执行

实际上我还没测试

但是我想我们可以试一下 `example.sh`

这里它告诉我们

应该用另外一种方法检查错误码

原来写的大概不能很好地达到目的

最后一点，我想说的是

当你编写这些 bash 脚本或者函数的时候

【436】 写你要运行的 bash 脚本

和写要载入 Shell 的东西

这两者是有区别的

我们将会在命令行环境那一讲里了解这些差别

同时那一讲会用到 `bashrc` 和 `sshrc` 这两种工具

但是，总的来说

如果你做了一些改动，比如你的路径

比方说你 cd 到了一个 bash 脚本

并且你直接运行它

【446】 它就不会 `cd` 到 Shell 当前的路径

但是如果你直接通过 Shell 加载 bash 代码

比如你的函数，然后你运行这些函数

这个操作就有相反的副作用

在 Shell 中定义变量也是一样

现在我会讲一些和 Shell 搭配干活不累的工具

第一个昨天已经着重讲过了

【456】 怎么去知道 flag 和 command（命令）具体代表什么

就像我现在知道 `ls -l` 

会用列表的形式列出文件

或者我运行 `mv -i` 它会给我提示

你现在能用的就是 man 命令

man 命令会给出很多关于命令的信息

比如说在这解释了 `-i` 的作用

这些就是你能做的全部操作

【466】 不仅是系统内封装的简单命令

对于一些从网上安装的工具也很方便

例如，如果安装完一些工具

那么 man 要用的文档也安装好了

比如我们要运行这个叫 ripgrep 的工具

它可以用 `rg` 调用

系统里并没有自带这个工具

但是它安装了自己的 man 文档

并且我可以查看

【476】 对有些命令来说， man 命令直截了当

但有时，理解 man 调出来的文档也挺头疼

因为它涵盖了这个工具所有的文档和描述

有的时候会有样例，但有的时候没有

比如我经常用的一些优秀工具

像 convert 和 ffmpeg

虽然他们处理图像或视频很优秀

【486】 但是他们的 man 文档都是庞然大物

然后有个好东西叫 `tldr`，你可以装一下

然后就会获得关于你如何调用命令的

一些深入浅出的命令示例

你也可以上网搜一下

但这样你就免得去打开浏览器

然后找一堆例子，再返回来

`tldr` 是社区贡献的，确实好用

比如用它查 `ffmpeg` 

就有很多经典的例子，格式易于阅读

（但我讲课调了特大号字体，打乱了格式所以不明显）

甚至如 `tar` 这种简单的命令

都有好多 option 要去组合运用

比如这里你可以把两三个 flag 结合

但结合出的效果可能违反直觉

这就是你……要找到更多这样的工具

关于查找的主题，我们再来试一下

怎么去查找文件

你永远可以用 `ls`

比如你可以 `ls project1`

然后一路 `ls` 下去……

但假设，我们已知要找名为 `src` 的文件夹

做这件事有更好的命令

它就是 `find`

`find` 大概是每个 UNIX 系统都有的工具

这个 `find`，我们给他一个……

这里意为，在当前文件夹调用 `find`

记住 `.` 代表当前文件夹

然后我们找名为 `src`

而且类型是个目录的东西

键入这些，它就可以在当前目录递归

查看所有符合规则的文件

或者文件夹，在这个例子里

`find` 也有很多有用的 flag

比如你甚至可以查询指定格式的文件路径

这里（`**`）是指要有几层文件夹

我们并不关心具体是多少个[*]
*译者注：这里 `**` 可以匹配零或多个目录名

然后我们想找所有 Python 脚本

也即所有扩展名是 `.py` 的文件

然后要求它们在一个 `test` 文件夹内

然后我们也在确保

虽然确实有点多余，但是

我们也检查它是否为 `F` 类型

`F` 是代表文件

这样就找到了符合的文件

也可以针对非路径和非文件名的查找

运用不同的 flag

比如可以查找被修改过的文件

这里 `-mtime` 代表修改时间

在最近一天被修改过的东西

啊，基本就是这个文件夹的所有东西

打印出了我们刚创建的文件

和先前就有的文件

你甚至可以用其他条件

比如大小，所有者，权限，等等

更强大的是，`find` 不仅查找东西

找到之后还能做别的

我们可以查找所有扩展名是 `.tmp` 的文件

是代表临时文件的扩展名

然后要求 `find` 对于所有这些文件

执行 `rm` 命令

这会对所有这些文件调用 `rm` 

我们先不带 `rm` 执行一下

再带着它执行一下

再次根据命令行的设计哲学

看起来无事发生

但我们有 `0` 错误代码，就是有事发生

那就是所有命令执行成功，一切顺利

然后现在再找下这些文件

就找不到了

总体来说， Shell 的另一个好处

就是即便有了这些工具

人们也在创造新的方式

用别的方法开发这些工具

了解一下挺不错的[*]
*这课程塞得好满……

比如你只想找以 `tmp` 结尾的东西

做这种挺另类的事情

你看这命令其实挺长的

有一个工具叫 `fd`

举个栗子，这命令更短

而且默认使用正则表达式[*]
*英文为 regex（regular expression），是一种匹配字符串的模式

还会忽略你的 gitfile[*]
*版本控制工具 Git 相关文件。后续课程有涉及

你不会想搜到那堆东西的

还有彩色代码和更好的 Unicode 支持……

了解这些工具挺好的

但是重申，核心思想是

你要是知道这些东西存在

就能省去做重复性、无意义工作的时间

另一个要记住的命令是

呃，就比如 `find`

部分同学可能会好奇……

`find` 可能就是遍历目录结构

去找匹配的事物

那我要是每天高强度 `find` 呢？

如果能给整个数据库出来

然后建个索引，不断维护它

岂不美哉

呃，其实大部分 UNIX 系统已经有了

可以用 `locate` 命令

这个 `locate` 会……

它会查找文件系统中具有指定子串的路径

我不知道这行不行……

哦看来可以

我来试试找 `missing-semester`

得等一会，就能找到这些东西

都是在我文件系统里面

因为事先建立了索引，它就会快得多
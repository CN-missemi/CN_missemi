【1】好的，欢迎回来[*]
*Jose 是西班牙人，不是印度人。此名来源于西语。

今天我们要分别谈谈与 Shell 有关的两个话题

首先我们要讲 Shell 脚本，这主要和 bash 有关

这将会是你们大多数人一开始在 macOS

或者大多数 Linux 里接触的 Shell

bash 是它们默认的 Shell

并且其他 Shell ，像是 zsh

对其有良好的向后兼容，这非常棒 [*]
*其实是 ZShell 具有对 Bourne Shell （也即 sh）的兼容性，而 bash 是 sh 的后继者。

然后我们要谈谈特别方便的其他 Shell 工具

你们可以用它避免重复执行任务

【10】像是寻找一段代码

或者一些犄角旮旯的文件

bash 里也有许多很棒的内置命令

它们可以帮你做这些事情

昨天我们已经介绍了 Shell 

和它的一些特性

就比如说你怎样执行一个命令

或者重定向它们（的输入输出）

今天我们将多讲一些 Shell 脚本中的

操纵变量的语法，控制流以及函数

例如，一旦你接触 Shell

说你想要定义一个变量

那是你学习编程语言第一个接触的事情[*]
*译者注：其实也要看编程语言类型

你可以执行像是 `foo=bar`

并且我们可以通过 `$foo` 操作 `foo` 的值

【26】它是 `bar`，完美~

你需要多加注意的一点是

当你面对着 bash 的时候[*]
*bash 也在面对着你

空格至关重要[*]
*译者注：在 sh、zsh 中同样如此

主要是因为空格是用于分隔参数的保留字符

例如，一些像是 `foo = bar` 的操作不管用

Shell 会告诉你它为什么出错

这是它说因为 `foo` 命令无法生效

比如这里提示 `foo` 不存在

【33】实际发生的是，我们没有将 `bar` 赋给 `foo`

而是用 `=` 和 `bar` 作为参数调用了 `foo` 程序

通常，你需要特别关注这类问题

比如说一些带有空格的文件名

你需要小心地把他们用引号引起来

让我们更深入些，探讨一下怎样在 bash 中处理字符串

我们有两种定义字符串的方法：

可以用双引号定义字符串

或者可以用单……

【41】呃，对不起

使用单引号（定义）

虽然对于纯文本字符串，这两种方式是等价的

但是对于其余的字符串，则不相同

例如,我们执行 `echo "Value is $foo"`

其中 `$foo` 将被展开为字符串

并且替换掉 Shell 中 `foo` 变量的值

如果我们用单引号来重复实验

我们仅仅会得到原样的 `$foo`

单引号中的变量将不会被替换

【50】脚本真的十分易于编写

这个就好比…它有点像你可能更熟悉的 Python

你可能没意识到这点

这就是给变量赋值的方式

我们稍后还会看到 bash 也有控制流技术

像是 for 循环、while 循环

另一个重点是，我们可以定义函数

我们可以访问我在此处定义的函数

这里我们已经定义了 `mcd` 函数

【57】到目前为止，我们已经了解

如何利用管道连接并执行几个命令

昨天简要地说过

但是很多时候你想先做一件事，然后另一件事

有点像我们这里的顺序执行

看这里，例如，我们可以调用 `mcd` 函数

首先我们调用 `mkdir` 命令

它会创建一个目录

【65】在这里，`$1` 就像是一个特殊变量

这就是 bash 运作的方式

类似于其他脚本语言的 `argv`

数组 `argv` 的第一项将包含参数[*]
*此处说明较为复杂，详见网络资料

在 bash 中同样的东西是 `$1`

一般来说，bash 中许多 `$` 开头的东西

它们都是被保留的[*]
*此处的「被保留」指留作特定用途

我们之后会看到更多的例子

【72】一旦我们创建了文件夹，

我们就 `cd` 进去

这其实是个挺常见的流程

实际上，我们直接将其键入到 Shell

它就会起作用，定义这个函数

但是有时候，把代码写到文件里更好

然后我们就可以 `source` 这个文件

这就会在 Shell 中加载脚本并执行

虽然现在看起来无事发生

【78】但是现在 Shell 中已经定义了 `mcd` 函数

因此我们现在能，比如说执行 `mcd test`

就从 `tool` 目录移到了 `test` 目录

我们创建了文件夹并且进入其中

还有什么。结果是...

我们可以通过 `$1` 访问第一个参数

这里有许多被保留的命令[*]
*确切来说，此处应为被保留的「变量」，而非命令

例如 `$0` 将会是脚本的名字

`$2` 到 `$9` 是 bash 脚本的

【86】第二个到第九个参数

有一些保留字可以直接在 Shell 中使用

例如 `$?` 能获取上条命令的错误代码（返回值）

我会简要解释这些

再比如，`$_` 会获取上条命令的最后一个参数

因此，我们搞定这个的另一种方式是

我们可以执行 `mkdir test`

与其重写一遍 `test`

【95】不如我们用 `$_` 访问上条命令的一部分

也就是最后一个参数

它将被替换成 `test` 

现在我们进去了 `test` 目录

像这样的例子很多，你应当熟悉他们

另一个我经常用的叫做 `bang bang`（`!!`）

每当，比如说，你试着创建某些东西

【100】但你没有足够权限的时候

正是这个东西的用武之处

然后，你可以执行 `sudo !!`

`!!` 会被你刚刚尝试的命令取代

现在来试一下

现在它就提示我输入密码

因为我有了 sudo 权限


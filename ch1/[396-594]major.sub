{45480}{45553}有些时候调试起来简直要命
{45554}{45685}一般来讲，调试的时候直觉会时不时地失效
{45686}{45854}就像我们之前看到的 `foo` 命令不存在
{45854}{46019}因此我们在讲义里有一个很高效的工具
{46020}{46100}这个工具叫做 shellcheck 
{46101}{46134}链接已经放在讲义里了
{46135}{46214}它能给出 warning 和语法错误
{46215}{46303}还能指出哪些地方你没正确引用
{46304}{46398}或者是哪些地方你的空格打错了
{46420}{46485}举个很简单的例子
{46486}{46598}`mcd.sh` 这个文件，我们得到了一些错误提示
{46599}{46684}这些提示说：「嗨！我们惊奇地发现漏掉了一些东西」
{46685}{46814}这可能导致 `mcd.sh` 在别的系统无法解译成功
{46835}{46922}并且， `cd` 后面有一个指令
{46923}{47022}而 `cd` 可能不会被正确执行
{47023}{47057}这里你可能想用 `cd ... || exit` 
{47058}{47232}之类的东西来代替它
{47233}{47288}回到这行命令
{47289}{47438}如果 `cd` 命令没有正确结束
{47439}{47487}你就不能进入那个文件夹
{47488}{47586}因为要么你没有权限，要么文件夹不存在
{47587}{47723}之后程序会给你一个非零的错误码
{47724}{47824}然后你就会执行 `exit` 命令，停止脚本的运行
{47825}{47960}而不是在一个不存在的路径继续执行
{48001}{48080}实际上我还没测试
{48081}{48228}但是我想我们可以试一下 `example.sh`
{48229}{48311}这里它告诉我们
{48312}{48422}应该用另外一种方法检查错误码
{48423}{48547}原来写的大概不能很好地达到目的
{48605}{48679}最后一点，我想说的是
{48680}{48819}当你编写这些 bash 脚本或者函数的时候
{48820}{48872}写你要运行的 bash 脚本
{48873}{49025}和写要载入 Shell 的东西
{49026}{49089}这两者是有区别的
{49090}{49277}我们将会在命令行环境那一讲里了解这些差别
{49278}{49403}同时那一讲会用到 `bashrc` 和 `sshrc` 这两种工具
{49418}{49462}但是，总的来说
{49463}{49545}如果你做了一些改动，比如你的路径
{49546}{49618}比方说你 cd 到了一个 bash 脚本
{49619}{49679}并且你直接运行它
{49690}{49765}它就不会 `cd` 到 Shell 当前的路径
{49794}{49911}但是如果你直接通过 Shell 加载 bash 代码
{49912}{50074}比如你的函数，然后你运行这些函数
{50075}{50139}这个操作就有相反的副作用
{50140}{50258}在 Shell 中定义变量也是一样
{50345}{50573}现在我会讲一些和 Shell 搭配干活不累的工具
{50615}{50697}第一个昨天已经着重讲过了
{50698}{50847}怎么去知道 flag 和 command（命令）具体代表什么
{50848}{50954}就像我现在知道 `ls -l` 
{50955}{51045}会用列表的形式列出文件
{51046}{51199}或者我运行 `mv -i` 它会给我提示
{51212}{51279}你现在能用的就是 man 命令
{51280}{51455}man 命令会给出很多关于命令的信息
{51456}{51598}比如说在这解释了 `-i` 的作用
{51599}{51671}这些就是你能做的全部操作
{51721}{51944}不仅是系统内封装的简单命令
{51945}{52075}对于一些从网上安装的工具也很方便
{52076}{52216}例如，如果安装完一些工具
{52217}{52291}那么 man 要用的文档也安装好了
{52292}{52455}比如我们要运行这个叫 ripgrep 的工具
{52456}{52537}它可以用 `rg` 调用
{52566}{52611}系统里并没有自带这个工具
{52612}{52714}但是它安装了自己的 man 文档
{52715}{52747}并且我可以查看
{52825}{52913}对有些命令来说， man 命令直截了当
{52914}{53000}但有时，理解 man 调出来的文档也挺头疼
{53001}{53202}因为它涵盖了这个工具所有的文档和描述
{53203}{53400}有的时候会有样例，但有的时候没有
{53401}{53561}比如我经常用的一些优秀工具
{53562}{53622}像 convert 和 ffmpeg
{53623}{53693}虽然他们处理图像或视频很优秀
{53694}{53755}但是他们的 man 文档都是庞然大物
{53756}{53878}然后有个好东西叫 `tldr`，你可以装一下
{53879}{54081}然后就会获得关于你如何调用命令的
{54082}{54152}一些深入浅出的命令示例
{54153}{54208}你也可以上网搜一下
{54209}{54333}但这样你就免得去打开浏览器
{54334}{54404}然后找一堆例子，再返回来
{54405}{54566}`tldr` 是社区贡献的，确实好用
{54567}{54676}比如用它查 `ffmpeg` 
{54677}{54772}就有很多经典的例子，格式易于阅读
{54773}{54860}（但我讲课调了特大号字体，所以不明显） # REVIEW
{54920}{54979}甚至如 `tar` 这种简单的命令
{54980}{55058}都有好多 option 要去组合运用
{55059}{55229}比如这里你可以把两三个 flag 结合
{55230}{55337}但结合出的效果可能违反直觉
{55427}{55558}这就是你……要找到更多这样的工具
{55599}{55652}关于查找的主题，我们再来试一下
{55653}{55753}怎么去查找文件
{55754}{55856}你永远可以用 `ls`
{55857}{55941}比如你可以 `ls project1`
{55942}{56055}然后一路 `ls` 下去……
{56056}{56305}但假设，我们已知要找名为 `src` 的文件夹
{56306}{56406}做这件事有更好的命令
{56407}{56449}它就是 `find`
{56450}{56564}`find` 大概是每个 UNIX 系统都有的工具
{56565}{56704}这个 `find`，我们给他一个……
{56773}{56887}这里意为，在当前文件夹调用 `find`
{56888}{56975}记住 `.` 代表当前文件夹
{56976}{57058}然后我们找名为 `src`
{57058}{57145}而且类型是个目录的东西
{57158}{57311}键入这些，它就可以在当前目录递归
{57312}{57384}查看所有符合规则的文件
{57385}{57463}或者文件夹，在这个例子里
{57464}{57589}`find` 也有很多有用的 flag
{57606}{57748}比如你可以指定文件路径的格式 # REVIEW
{57749}{57857}这里是要求有一定数目的文件夹
{57858}{57907}我们并不关心具体是多少个[*]
{57908}{58024}然后我们想找所有 Python 脚本
{58025}{58097}也即所有扩展名是 `.py` 的文件
{58098}{58161}然后要求它们在一个 `test` 文件夹内
{58162}{58190}然后我们也在确保
{58191}{58228}虽然确实有点多余，但是
{58229}{58318}我们也检查它是否为 `F` 类型
{58319}{58355}`F` 是代表文件
{58393}{58446}这样就找到了符合的文件
{58496}{58570}也可以针对非路径和非文件名的查找
{58571}{58629}运用不同的 flag
{58644}{58779}比如可以查找被修改过的文件
{58780}{58848}这里 `-mtime` 代表修改时间
{58849}{58926}在最近一天被修改过的东西
{58927}{58984}啊，基本就是这个文件夹的所有东西
{58985}{59063}打印出了我们刚创建的文件
{59064}{59127}和先前就有的文件
{59128}{59195}你甚至可以用其他条件
{59196}{59321}比如大小，所有者，权限，等等
{59358}{59464}更强大的是，`find` 不仅查找东西
{59465}{59574}找到之后还能做别的
{59586}{59847}我们可以查找所有扩展名是 `.tmp` 的文件
{59876}{59930}是代表临时文件的扩展名
{59942}{60083}然后要求 `find` 对于所有这些文件
{60084}{60190}执行 `rm` 命令
{60203}{60296}这会对所有这些文件调用 `rm` 
{60312}{60401}我们先不带 `rm` 执行一下
{60425}{60467}再带着它执行一下
{60502}{60592}再次根据命令行的设计哲学
{60627}{60663}看起来无事发生
{60664}{60863}但我们有 `0` 错误代码，就是有事发生
{60864}{60937}那就是所有命令执行成功，一切顺利
{60938}{61014}然后现在再找下这些文件
{61015}{61088}就找不到了
{61156}{61266}总体来说， Shell 的另一个好处
{61267}{61322}就是即便有了这些工具
{61348}{61425}人们也在创造新的方式
{61426}{61509}用别的方法开发这些工具
{61510}{61564}了解一下挺不错的[*]
{61565}{61806}比如你只想找以 `tmp` 结尾的东西
{61807}{61884}做这种挺另类的事情
{61885}{61934}你看这命令其实挺长的
{61935}{62043}有一个工具叫 `fd`
{62044}{62120}举个栗子，这命令更短
{62121}{62181}而且默认使用正则表达式[*]
{62182}{62248}还会忽略你的 gitfile[*]
{62249}{62306}你不会想搜到那堆东西的
{62345}{62456}还有彩色代码和更好的 Unicode 支持……
{62457}{62536}了解这些工具挺好的
{62537}{62625}但是重申，核心思想是
{62626}{62751}你要是知道这些东西存在
{62752}{62895}就能省去做重复性、无意义工作的时间
{62959}{62991}另一个要记住的命令是
{62992}{63023}呃，就比如 `find`
{63024}{63083}部分同学可能会好奇……
{63084}{63230}`find` 可能就是遍历目录结构
{63231}{63274}去找匹配的事物
{63287}{63350}那我要是每天高强度 `find` 呢？
{63351}{63434}如果能给整个数据库出来
{63435}{63575}然后建个索引，不断维护它
{63576}{63633}岂不美哉
{63634}{63711}呃，其实大部分 UNIX 系统已经有了
{63712}{63800}可以用 `locate` 命令
{63801}{63969}这个 `locate` 会……
{63970}{64197}它会查找文件系统中具有指定子串的路径
{64198}{64285}我不知道这行不行……
{64286}{64316}哦看来可以
{64317}{64498}我来试试找 `missing-semester`
{64590}{64689}得等一会，就能找到这些东西
{64690}{64714}都是在我文件系统里面
{64715}{64874}因为事先建立了索引，它就会快得多
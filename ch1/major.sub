{1}{1}30.000000
{41}{78}好的，欢迎回来[*]
{103}{227}今天我们要分别谈谈与 Shell 有关的两个话题
{234}{344}首先我们要讲 Shell 脚本，这主要和 bash 有关
{345}{482}这将会是你们大多数人一开始在 macOS
{483}{535}或者大多数 Linux 里接触的 Shell
{536}{565}bash 是它们默认的 Shell
{577}{621}并且其他 Shell ，像是 zsh
{622}{683}对其有良好的向后兼容，这非常棒 [*]
{684}{796}然后我们要谈谈特别方便的其他 Shell 工具
{797}{883}你们可以用它避免重复执行任务
{884}{947}像是寻找一段代码
{948}{1027}或者一些犄角旮旯的文件
{1028}{1101}bash 里也有许多很棒的内置命令
{1102}{1202}它们可以帮你做这些事情
{1257}{1338}昨天我们已经介绍了 Shell 
{1339}{1399}和它的一些特性
{1400}{1478}就比如说你怎样执行一个命令
{1479}{1517}或者重定向它们（的输入输出）
{1518}{1569}今天我们将多讲一些 Shell 脚本中的
{1570}{1718}操纵变量的语法，控制流以及函数
{1738}{1840}例如，一旦你接触 Shell
{1859}{1916}说你想要定义一个变量
{1917}{2076}那是你学习编程语言第一个接触的事情[*]
{2081}{2188}你可以执行像是 `foo=bar`
{2209}{2341}并且我们可以通过 `$foo` 操作 `foo` 的值
{2365}{2430}它是 `bar`，完美~
{2455}{2533}你需要多加注意的一点是
{2534}{2601}当你面对着 bash 的时候[*]
{2602}{2647}空格至关重要[*]
{2648}{2809}主要是因为空格是用于分隔参数的保留字符
{2810}{2926}例如，一些像是 `foo = bar` 的操作不管用
{2939}{3065}Shell 会告诉你它为什么无法生效
{3066}{3118}这是它说因为 `foo` 命令无法生效
{3127}{3188}比如这里提示 `foo` 不存在
{3189}{3284}实际发生的是，我们没有将 `bar` 赋给 `foo`
{3309}{3495}而是用 `=` 和 `bar` 作为参数调用了 `foo` 程序
{3537}{3649}通常，你需要特别关注这类问题
{3657}{3718}比如说一些带有空格的文件名
{3719}{3919}你需要小心地把他们用引号引起来
{3920}{4036}让我们更深入些，探讨一下怎样在 bash 中处理字符串
{4037}{4095}我们有两种定义字符串的方法：
{4096}{4221}可以用双引号定义字符串
{4222}{4345}或者可以用单……
{4346}{4372}呃，对不起
{4402}{4440}使用单引号（定义）
{4507}{4591}虽然对于纯文本字符串，这两种方式是等价的
{4592}{4669}但是对于其余的字符串，则不相同
{4670}{4899}例如,我们执行 `echo "Value is $foo"`
{4920}{5034}其中 `$foo` 将被展开为字符串
{5035}{5131}并且替换掉 Shell 中 `foo` 变量的值
{5140}{5297}如果我们用单引号来重复实验
{5298}{5368}我们仅仅会得到原样的 `$foo`
{5381}{5456}单引号中的变量将不会被替换
{5460}{5534}脚本真的十分易于编写
{5543}{5646}这个就好比…它有点像你可能更熟悉的 Python
{5658}{5722}你可能没意识到这点
{5738}{5832}这就是给变量赋值的方式
{5833}{5945}我们稍后还会看到 bash 也有控制流技术
{5946}{6008}像是 for 循环、while 循环
{6009}{6131}另一个重点是，我们可以定义函数
{6132}{6257}我们可以访问我在此处定义的函数
{6258}{6379}这里我们已经定义了 `mcd` 函数
{6380}{6483}到目前为止，我们已经了解
{6484}{6567}如何利用管道连接并执行几个命令
{6568}{6627}昨天简要地说过
{6628}{6754}但是很多时候你想先做一件事，然后另一件事
{6755}{6933}有点像我们这里的顺序执行
{6934}{7015}看这里，例如，我们可以调用 `mcd` 函数
{7116}{7207}首先我们调用 `mkdir` 命令
{7208}{7275}它会创建一个目录
{7299}{7384}在这里，`$1` 就像是一个特殊变量
{7385}{7427}这就是 bash 运作的方式
{7428}{7569}类似于其他脚本语言的 `argv`
{7570}{7705}数组 `argv` 的第一项将包含参数[*]
{7706}{7741}在 bash 中同样的东西是 `$1`
{7742}{7871}一般来说，bash 中许多 `$` 开头的东西
{7872}{7893}它们都是被保留的[*]
{7894}{7963}我们之后会看到更多的例子
{7985}{8051}一旦我们创建了文件夹，
{8052}{8115}我们就 `cd` 进去
{8142}{8236}这其实是个挺常见的流程
{8250}{8350}实际上，我们直接将其键入到 Shell
{8351}{8408}它就会起作用，定义这个函数
{8419}{8566}但是有时候，把代码写到文件里更好
{8567}{8696}然后我们就可以 `source` 这个文件
{8697}{8808}这就会在 Shell 中加载脚本并执行
{8827}{8904}虽然现在看起来无事发生
{8905}{9040}但是现在 Shell 中已经定义了 `mcd` 函数
{9057}{9169}因此我们现在能，比如说执行 `mcd test`
{9170}{9289}就从 `tool` 目录移到了 `test` 目录
{9290}{9402}我们创建了文件夹并且进入其中
{9481}{9565}还有什么。结果是...
{9566}{9667}我们可以通过 `$1` 访问第一个参数
{9668}{9789}这里有许多被保留的命令[*]
{9790}{9902}例如 `$0` 将会是脚本的名字
{9903}{9989}`$2` 到 `$9` 是 bash 脚本的
{9990}{10120}第二个到第九个参数
{10121}{10261}有一些保留字可以直接在 Shell 中使用
{10262}{10510}例如 `$?` 能获取上条命令的错误代码（返回值）
{10574}{10612}我会简要解释这些
{10613}{10779}再比如，`$_` 会获取上条命令的最后一个参数
{10780}{10903}因此，我们搞定这个的另一种方式是
{10904}{11023}我们可以执行 `mkdir test`
{11024}{11102}与其重写一遍 `test`
{11103}{11200}不如我们用 `$_` 访问上条命令的一部分
{11201}{11353}也就是最后一个参数
{11354}{11422}它将被替换成 `test` 
{11423}{11489}现在我们进去了 `test` 目录
{11568}{11628}像这样的例子很多，你应当熟悉他们
{11629}{11770}另一个我经常用的叫做 `bang bang`（`!!`）
{11771}{11899}每当，比如说，你试着创建某些东西
{11900}{11935}但你没有足够权限的时候
{11936}{11973}正是这个东西的用武之处
{11974}{12031}然后，你可以执行 `sudo !!`
{12045}{12142}`!!` 会被你刚刚尝试的命令取代
{12143}{12203}现在来试一下
{12204}{12259}现在它就提示我输入密码
{12260}{12315}因为我有了 sudo 权限
{12524}{12559}之前我提到了，呃，命令错误什么的
{12560}{12591}昨天我们看过，总体来说……
{12592}{12632}一个进程有许多方式
{12633}{12741}和其他进程或命令交互
{12756}{12825}我们提到了标准输入（流）
{12826}{12863}它就是好比……
{12864}{12909}（程序）从标准输入获取各种东西
{12910}{12945}然后把东西输到标准输出里
{12946}{13016}还有些东西更有意思
{13025}{13141}也有一个标准错误（流）
{13157}{13249}如果你程序出错了
{13250}{13284}你想输出错误却不污染标准输出
{13288}{13322}就可以写进这个流
{13323}{13384}也有错误代码（error code）这种东西
{13393}{13493}而且它普遍存在于很多编程语言
{13494}{13606}是一种告诉你整个运行过程
{13610}{13628}结果如何的方式
{13650}{13714}所以，比如我们试试
{13727}{13792}`echo "Hello"`
{13798}{13903}然后查一下错误代码的值，它是 `0`
{13904}{13968}`0` 是因为一切正常，没有出问题
{13969}{14038}这种 `0` 退出码和它在[*]
{14055}{14153}比如 C 这种语言里，代表的意思一样
{14166}{14245}`0` 就代表所有事情正常，没出错误
{14262}{14317}然而，有时候事情会出错
{14332}{14485}比如有时候，我们尝试在 `mcd` 脚本里
{14486}{14545}`grep foobar` 的话
{14553}{14635}现在查一下值，就是 `1`
{14636}{14732}这是因为我们试着在 `mcd` 脚本里
{14733}{14813}搜索 `foobar` 字符串，而它不存在
{14829}{14927}所以 `grep` 什么都没输出
{14928}{14997}但是通过反馈一个 `1` 的错误代码
{14999}{15058}它让我们知道这件事没成功
{15071}{15137}有一些有意思的命令，比如
{15148}{15314}`true` 的错误代码始终是 `0`
{15315}{15445}`false` 的错误代码则是 `1`
{15466}{15578}还有比如这些逻辑运算符
{15579}{15697}你可以用来做条件判断
{15698}{15772}比如……其实你也有 `if-else`
{15773}{15793}之后我们会说
{15800}{15854}但是现在你可以做一些
{15870}{15967}比如 `false`，然后 `echo "Oops fail"`
{15968}{16088}这里有两个被或运算符链接的命令
{16089}{16218}这里 bash 要做的是，执行第一个命令
{16219}{16378}如果第一个命令失败，再去执行第二个[*]
{16379}{16443}这里我们有这个结果
{16444}{16516}因为它尝试做一个逻辑或
{16517}{16588}如果第一个（命令）没有 `0` 错误码
{16589}{16637}它就会去执行第二个（命令）
{16638}{16747}相似地，如果我们把 `false`
{16748}{16786}替换成比如 `true`
{16787}{16860}因为我们有一个 `0` 错误代码
{16861}{16925}所以第二个（命令）会被短路
{16926}{17002}所以就不会打印
{17184}{17269}相似地，我们有与运算符
{17300}{17364}它仅当第一个命令执行无错误时
{17367}{17440}才会执行第二个部分
{17508}{17551}这里也是同样的事情：
{17554}{17642}如果第一个失败，那么第二个命令
{17643}{17684}就不会被执行
{17752}{17910}虽然不是很相关，但是另一个事情是
{18053}{18139}无论你执行什么，你都可以通过
{18140}{18212}在同一行内使用分号来连接命令
{18213}{18272}它就会始终被打印出来
{18310}{18410}在这之后，我们还没学到的是
{18411}{18590}怎样把命令的输出存到变量里
{18591}{18726}我们可以这样做
{18737}{18896}这里我们获取 `pwd` 命令的输出
{18897}{18977}它会打印出当前工作目录
{18978}{19008}也就是我们在哪里
{19019}{19108}然后把这个存进 `foo` 变量
{19130}{19233}然后现在我们询问 `foo` 的值
{19234}{19272}我们就能看到这个字符串
{19273}{19355}更广泛的说，我们可以做一个叫
{19376}{19454}命令替换的事情
{19501}{19540}通过把它放进任意字符串中
{19541}{19636}而且因为我们用的不是单引号
{19637}{19663}而是双引号
{19664}{19714}所以这串东西会被展开
{19715}{19866}告诉我们，现在位于这个文件夹
{19915}{19967}另一个有趣的事情是
{19987}{20086}这个会展开成一个字符串
{20087}{20099}而不是……
{20100}{20198}呃，它只是展开成一个字符串
{20199}{20294}另一个好用但知名度更低的工具
{20295}{20336}叫做过程替换
{20346}{20423}和之前那个是类似的
{20529}{20571}它会做什么呢……它会
{20608}{20733}比如这里的 `<(` ，接一个命令，再接 `)`
{20734}{20819}它的作用是，内部的命令会被执行
{20820}{20879}其输出将被存储到，大概像一个
{20880}{20950}临时文件内，然后把文件 handle（标识符）[*]
{20951}{20984}交给（最左面的）命令
{20985}{21077}所以这里我们在……`ls` 这个目录
{21078}{21173}把输出放到临时文件内
{21174}{21239}再对父目录如法炮制
{21240}{21311}然后把两个文件连接
{21312}{21393}而这种写法就非常得劲
{21394}{21431}因为有些命令会从
{21432}{21533}某些文件的内容，而不是标准输入
{21534}{21700}获得输入参数
{21747}{21837}所以我们把这两个命令连起来了
{21991}{22072}感觉讲到现在，讲了真不少东西
{22073}{22154}来看一个里面包含这些内容的
{22155}{22326}简单的示例脚本
{22327}{22409}比如说这里我们有个字符串
{22410}{22483}然后有个 `$(date)`
{22484}{22529}这个 `date` 是个程序
{22530}{22591}重复一下，类 UNIX 系统有很多程序
{22592}{22682}你会慢慢都熟悉它们的
{22683}{22792}`date` 就打印出当前的日期
{22793}{22856}你还可以指定各种打印格式
{22875}{23018}然后这里有这个 `$0`
{23019}{23108}是我们运行的这个脚本的文件名
{23122}{23324}然后是这个 `$#`，代表给定的参数个数
{23325}{23458}然后 `$$` 是这个命令的进程 ID[*]
{23484}{23557}强调，这里有很多 `$`+ 什么什么
{23558}{23596}它们（的含义）并不直观
{23597}{23702}因为你找不到一种巧记的方法
{23703}{23764}`$#` 这种大概就是
{23765}{23813}但是……你一直和它们打照面
{23814}{23832}逐渐就能熟络起来
{23833}{23903}这里还有个 `$@`
{23904}{23979}可以展开成所有参数
{23980}{24096}所以比起来……比如有三个参数
{24097}{24174}那我可以键入 `$1 $2 $3`
{24175}{24247}那如果我们不知道有多少参数
{24248}{24295}我们可以用这种方式把这些参数全部放在这里
{24296}{24431}然后这些参数被传给 `for` 循环
{24454}{24578}`for` 循环会创建一个 `file` 变量 
{24579}{24837}依次地用这些参数赋值给 `file` 变量
{24838}{25007}下一行我们运行 `grep` 命令
{25012}{25102}它会在一堆文件里搜索一个子串[*]
{25103}{25181}这里我们在文件里搜索字符串 `foobar`
{25200}{25377}这里我们让 `file` 变量展开为它的值
{25394}{25510}昨天说过，如果我们在意程序输出的话
{25511}{25601}我们可以把它重定向到某处
{25602}{25671}到一个文件里保存下来，或者连接组合
{25693}{25775}嘿，但有时候情况恰恰相反
{25776}{25838}有时候，比如说，我们想知道
{25839}{25918}这个脚本的错误代码是什么
{25919}{26041}我想知道 `grep` 能不能成功查找
{26059}{26196}所以，我们甚至能直接扔掉整个输出
{26197}{26336}包括标准输出和标准错误（流）
{26355}{26385}这里我们做的是
{26386}{26491}把两个输出重定向到 `/dev/null`
{26492}{26613}它是 UNIX 系统的一种特殊设备
{26614}{26715}输出到它的内容会被丢弃
{26718}{26801}就是你可以随意乱写乱画
{26802}{26807}然后所有内容都会被丢掉|就是你可以随意乱写乱画
{26808}{26834}然后所有内容都会被丢掉
{26842}{26945}还有这个 `>` 符号
{26946}{27005}昨天说过，用来重定向输出的
{27014}{27086}这里有个 `2>`
{27096}{27167}有些人也许猜到了
{27168}{27226}它是重定向标准错误流的
{27227}{27307}因为这两个流是分立的
{27308}{27424}所以你得告诉 bash 去操作哪个
{27459}{27497}所以这里我们执行命令
{27498}{27551}去检查文件有没有 `foobar`
{27552}{27683}如果有的话，返回一个 `0` 错误码
{27684}{27769}如果没有，就是一个非 `0` 码
{27782}{27839}我们正是要检查这个
{27857}{27938}这部分命令里
{27939}{28012}我们先告诉它：「给我错误代码」
{28013}{28055}这个是用 `$?`
{28056}{28168}然后是一个比较运算符 `-ne`
{28169}{28194}代表不等于（`N`on `E`qual）
{28233}{28316}其他编程语言里有像
{28328}{28449}`==` 和 `!=` 这种符号
{28467}{28580}bash 里有很多预设的比较运算
{28581}{28706}这主要是为了你用 Shell 的时候
{28707}{28753}有很多东西要去做测试
{28762}{28825} 比如我们现在正在对比两个数
{28826}{28909}两个整数，看它们是否相同
{28910}{29042}又比如，`-f` flag 会让我们知道
{29043}{29100}是否存在一个文件
{29111}{29206}这是你以后会频繁用上的
{29307}{29352}回到例子
{29353}{29648}如果文件中没有 `foobar` 会发生什么
{29649}{29743}像之前有非 `0` 的错误代码
{29744}{29774}我们也输出
{29775}{29809}文件中没有 `foobar` 字符串
{29810}{29911}我们将添加一个，而我们所做的是
{29925}{30001}我们输入 `# foobar`
{30002}{30067}蒙一手这 `#` 是个文件注释格式
{30079}{30253}之后我们用 `>>` 操作符把它添在文件末尾
{30254}{30376}这里尽管文件名已经传给了脚本
{30377}{30407}但我们预先并不知道文件名
{30408}{30509}所以我们需要用文件名变量在这里展开
{30553}{30644}我们可以运行这个试试
{30662}{30758}我们已经有这个脚本的正确权限
{30773}{30893}我可以举一些例子，我们在这个夹里有一些文件
{30894}{31003}`mcd` 是我们先前看到的 `mcd` 函数
{31004}{31052}还有其它脚本函数
{31058}{31244}甚至可以把它自己传给它，检查是否有 `foobar`
{31274}{31354}我们运行它，首先我们可以看到
{31355}{31542}我们成功地列出了很多的变量
{31557}{31595}我们有 `date` 命令
{31605}{31690}它成功地被替换成了当前时间
{31698}{31801}接着是这个带着三个参数的程序
{31817}{31924}它的随机的 pid 识别码
{31934}{32015}之后它告诉我们 `mcd` 没有 `foobar` 字符串
{32016}{32076}所以我们新添加了一个
{32077}{32134}并且这个 `script.py` 文件也没有
{32135}{32206}像现在让我们看看 `mcd`
{32207}{32269}它就有我们要找的注释
{32382}{32566}当你在执行脚本时另一个需要知道的是
{32590}{32669}像这里，我们有三个完全不同的参数
{32679}{32716}但通常
{32717}{32887}你会用一些更加简洁的方式输入参数
{32899}{32969}例如这里，
{32985}{33146}如果我想查找所有的 `.sh` 脚本
{33161}{33328}我们只需要键入 `ls *.sh`
{33329}{33487}这是大多数 Shell 都有的一种展开文件名的方式
{33488}{33519}叫做通配
{33520}{33604}这里，如你所想，会显示出
{33605}{33745}所有含有任意字符，且以 `.sh` 为后缀的东西
{33806}{33916}如我们所料，得到了 `example.sh` 和 `mcd.sh`
{33932}{34022}我们也有这些 `project1` 和 `project2`
{34023}{34075}并且如果这里有……
{34095}{34205}比如，我们可以建一个 `project42`
{34224}{34391}现在如果我只想找有一个特定字符的项
{34392}{34423}而不是两个字符
{34424}{34468}然后，像其它任意的字符
{34469}{34624}我们可以使用 `?` 标记，`?` 标记只会展开一个字符
{34659}{34709}我们得到了列出的
{34710}{34806}先是 `project1` 再是 `project2` 
{34830}{35022}总而言之，通配符非常强大，你也可以组合它们
{35185}{35274}一个常用模式是花括号
{35289}{35387}我们在这个文件夹里有一个图片 
{35388}{35507}我们想把图片文件格式由 PNG 转为 JPG
{35530}{35587}我们可能会复制它，或者……
{35588}{35721}这确实是常见情况，有两个或多个挺相似的参数
{35722}{35854}你想把它们当作参数传给命令
{35855}{35963}你可以这样做，但更简洁的做法是
{35964}{36256}你可以只键入 `image.{png,jpg}`
{36309}{36382}这里有一些彩色的反馈……
{36383}{36523}总之，它会展开成上面的那行
{36524}{36637}实际上，我可以让 zsh 为我做这些
{36638}{36697}也就是这里正进行的
{36744}{36806}这确实很强大，所以比如
{36807}{36893}你可以做一些像……我们可以……
{36904}{37022}`touch` 一串 `foo`，所有 `foo` 都会被展开
{37091}{37246}你也可以进行多层操作，建立笛卡尔系
{37329}{37366}如果我们有一些像这样的组
{37413}{37506}我们这里有一组 `{1,2}`
{37507}{37577}之后这里又有 `{1,2,3}`
{37578}{37693}这会用使两组展开式形成笛卡尔积
{37694}{37778}而后展开积里的所有表达式
{37826}{37891}我们就可以很快地 `touch` 了
{37911}{38117}你也可以将 `*` 通配符与 `{}` 通配符结合
{38132}{38215}甚至你可以用一些范围表示
{38219}{38303}像，我们可以键入 `mkdir`
{38304}{38400}我们创建 `foo`，`bar` 目录
{38429}{38554}之后可以在这些行里搞事情
{38564}{38678}这将会展开到 `foo/a`，`foo/b` ……
{38679}{38743}像所有的组合，直到 `j`
{38765}{38895}`bar` 同理，虽然说实话我没试……
{38896}{38993}但是没错，我们得到了我们所能 touch 的所有组合
{39014}{39173}现在，如果我们在两个目录中建一些不同的东西
{39197}{39413}我们可以再次展示……
{39434}{39491}用我们之前看到的流程代替
{39492}{39611}我们想查看这两个文件夹中有什么不同文件
{39612}{39699}非常显然，我们刚刚看到了，是 `x` 和 `y`
{39700}{39800}但是我们可以用 Shell 去比对
{39801}{39883}一个 `ls` 和另一个 `ls` 输出的不同
{39918}{39970}如我们所料，我们得到了
{39971}{40025}`x` 只在第一个文件夹里
{40026}{40135}`y` 只在第二个文件夹里
{40217}{40360}还有，目前我们只看了 bash 脚本
{40361}{40414}如果你喜欢其它的脚本……
{40415}{40504}像 bash 对一些工作可能并不是最好的选择
{40517}{40579}它可能会很棘手。事实上你可以
{40580}{40696}用很多语言写和 Shell 工具交互的脚本
{40713}{40802}例如，我们在这里看一个
{40803}{40915}Python 脚本，它的开头有神秘的一行代码
{40916}{40978}我暂且不去解释
{40979}{41051}我们有 `import sys`
{41052}{41284}这很像…… Python 默认不会尝试和 Shell 交互
{41285}{41336}所以你需要导入一些库
{41337}{41381}之后我们在做一个
{41382}{41423}确实很傻的事情
{41435}{41525}就只是迭代 `sys.argv[1:]`
{41568}{41672}`sys.argv` 是一种类似于 
{41673}{41762}bash 中 `$0`，`$1` 等等的东西
{41763}{41915}就是一个参数 vector，我们将它倒序输出
{41981}{42071}开始时那神奇的一行叫做 shebang[*]
{42072}{42194}Shell 通过它了解怎么运行这个程序
{42195}{42319}你随时可以键入类似
{42320}{42403}python script.py` 之后是 `a b c`
{42422}{42499}像这样它就会运行
{42500}{42631}但如果我想让它从 Shell 就能执行呢？
{42632}{42805}Shell 是用首行识别到
{42806}{42911}需要用 Python 解释器运行这个程序
{42954}{43000}并且第一行
{43001}{43078}给了这东西所在的路径
{43161}{43205}然而，你可能不知道
{43206}{43251}像不同的设备很可能
{43252}{43334}会把 Python 放在不同的地方
{43335}{43410}最好别假设 Python 装在哪儿
{43412}{43476}其它解释器也是一样
{43565}{43729}所以你可以做的是调用 `env` 命令
{43730}{43848}你也可以在 shebang 中给出参数
{43849}{44002}所以我们现在是在调用 `env` 命令
{44003}{44093}这是对于绝大多数系统而言的，有一些例外
{44094}{44177}但是对于绝大多数系统而言它在 `usr/bin`
{44178}{44220}那儿有很多二进制文件
{44244}{44315}之后用参数 Python 调用它
{44337}{44396}它会使用
{44397}{44521}第一节课提到的 `path` 环境变量
{44522}{44593}`env` 会在那些路径中找 Python 二进制文件
{44594}{44695}接着用它去解释这个脚本
{44696}{44759}这样有更好的可移植性
{44760}{44882}能让它在我的，你的还有其它的设备上运行
{45268}{45425}另一件事是 bash 并不是真正现代化的
{45427}{45485}它好久之前就被开发出来了
{45480}{45553}有些时候调试起来简直要命
{45554}{45685}一般来讲，调试的时候直觉会时不时地失效
{45686}{45854}就像我们之前看到的 `foo` 命令不存在
{45854}{46019}因此我们在讲义里有一个很高效的工具
{46020}{46100}这个工具叫做 shellcheck 
{46101}{46134}链接已经放在讲义里了
{46135}{46214}它能给出 warning 和语法错误
{46215}{46303}还能指出哪些地方你没正确引用
{46304}{46398}或者是哪些地方你的空格打错了
{46420}{46485}举个很简单的例子
{46486}{46598}`mcd.sh` 这个文件，我们得到了一些错误提示
{46599}{46684}这些提示说：「嗨！我们惊奇地发现漏掉了一些东西」
{46685}{46814}这可能导致 `mcd.sh` 在别的系统无法解译成功
{46835}{46922}并且， `cd` 后面有一个指令
{46923}{47022}而 `cd` 可能不会被正确执行
{47023}{47057}这里你可能想用 `cd ... || exit` 
{47058}{47232}之类的东西来代替它
{47233}{47288}回到这行命令
{47289}{47438}如果 `cd` 命令没有正确结束
{47439}{47487}你就不能进入那个文件夹
{47488}{47586}因为要么你没有权限，要么文件夹不存在
{47587}{47723}之后程序会给你一个非零的错误码
{47724}{47824}然后你就会执行 `exit` 命令，停止脚本的运行
{47825}{47960}而不是在一个不存在的路径继续执行
{48001}{48080}实际上我还没测试
{48081}{48228}但是我想我们可以试一下 `example.sh`
{48229}{48311}这里它告诉我们
{48312}{48422}应该用另外一种方法检查错误码
{48423}{48547}原来写的大概不能很好地达到目的
{48605}{48679}最后一点，我想说的是
{48680}{48819}当你编写这些 bash 脚本或者函数的时候
{48820}{48872}写你要运行的 bash 脚本
{48873}{49025}和写要载入 Shell 的东西
{49026}{49089}这两者是有区别的
{49090}{49277}我们将会在命令行环境那一讲里了解这些差别
{49278}{49403}同时那一讲会用到 `bashrc` 和 `sshrc` 这两种工具
{49418}{49462}但是，总的来说
{49463}{49545}如果你做了一些改动，比如你的路径
{49546}{49618}比方说你 cd 到了一个 bash 脚本
{49619}{49679}并且你直接运行它
{49690}{49765}它就不会 `cd` 到 Shell 当前的路径
{49794}{49911}但是如果你直接通过 Shell 加载 bash 代码
{49912}{50074}比如你的函数，然后你运行这些函数
{50075}{50139}这个操作就有相反的副作用
{50140}{50258}在 Shell 中定义变量也是一样
{50345}{50573}现在我会讲一些和 Shell 搭配干活不累的工具
{50615}{50697}第一个昨天已经着重讲过了
{50698}{50847}怎么去知道 flag 和 command（命令）具体代表什么
{50848}{50954}就像我现在知道 `ls -l` 
{50955}{51045}会用列表的形式列出文件
{51046}{51199}或者我运行 `mv -i` 它会给我提示
{51212}{51279}你现在能用的就是 man 命令
{51280}{51455}man 命令会给出很多关于命令的信息
{51456}{51598}比如说在这解释了 `-i` 的作用
{51599}{51671}这些就是你能做的全部操作
{51721}{51944}不仅是系统内封装的简单命令
{51945}{52075}对于一些从网上安装的工具也很方便
{52076}{52216}例如，如果安装完一些工具
{52217}{52291}那么 man 要用的文档也安装好了
{52292}{52455}比如我们要运行这个叫 ripgrep 的工具
{52456}{52537}它可以用 `rg` 调用
{52566}{52611}系统里并没有自带这个工具
{52612}{52714}但是它安装了自己的 man 文档
{52715}{52747}并且我可以查看
{52825}{52913}对有些命令来说， man 命令直截了当
{52914}{53000}但有时，理解 man 调出来的文档也挺头疼
{53001}{53202}因为它涵盖了这个工具所有的文档和描述
{53203}{53400}有的时候会有样例，但有的时候没有
{53401}{53561}比如我经常用的一些优秀工具
{53562}{53622}像 convert 和 ffmpeg
{53623}{53693}虽然他们处理图像或视频很优秀
{53694}{53755}但是他们的 man 文档都是庞然大物
{53756}{53878}然后有个好东西叫 `tldr`，你可以装一下
{53879}{54081}然后就会获得关于你如何调用命令的
{54082}{54152}一些深入浅出的命令示例
{54153}{54208}你也可以上网搜一下
{54209}{54333}但这样你就免得去打开浏览器
{54334}{54404}然后找一堆例子，再返回来
{54405}{54566}`tldr` 是社区贡献的，确实好用
{54567}{54676}比如用它查 `ffmpeg` 
{54677}{54772}就有很多经典的例子，格式易于阅读
{54773}{54860}（但我讲课调了特大号字体，打乱了格式所以不明显）
{54920}{54979}甚至如 `tar` 这种简单的命令
{54980}{55058}都有好多 option 要去组合运用
{55059}{55229}比如这里你可以把两三个 flag 结合
{55230}{55337}但结合出的效果可能违反直觉
{55427}{55558}这就是你……要找到更多这样的工具
{55599}{55652}关于查找的主题，我们再来试一下
{55653}{55753}怎么去查找文件
{55754}{55856}你永远可以用 `ls`
{55857}{55941}比如你可以 `ls project1`
{55942}{56055}然后一路 `ls` 下去……
{56056}{56305}但假设，我们已知要找名为 `src` 的文件夹
{56306}{56406}做这件事有更好的命令
{56407}{56449}它就是 `find`
{56450}{56564}`find` 大概是每个 UNIX 系统都有的工具
{56565}{56704}这个 `find`，我们给他一个……
{56773}{56887}这里意为，在当前文件夹调用 `find`
{56888}{56975}记住 `.` 代表当前文件夹
{56976}{57058}然后我们找名为 `src`
{57058}{57145}而且类型是个目录的东西
{57158}{57311}键入这些，它就可以在当前目录递归
{57312}{57384}查看所有符合规则的文件
{57385}{57463}或者文件夹，在这个例子里
{57464}{57589}`find` 也有很多有用的 flag
{57606}{57748}比如你甚至可以查询指定格式的文件路径
{57749}{57857}这里（`**`）是指要有几层文件夹
{57858}{57907}我们并不关心具体是多少个[*]
{57908}{58024}然后我们想找所有 Python 脚本
{58025}{58097}也即所有扩展名是 `.py` 的文件
{58098}{58161}然后要求它们在一个 `test` 文件夹内
{58162}{58190}然后我们也在确保
{58191}{58228}虽然确实有点多余，但是
{58229}{58318}我们也检查它是否为 `F` 类型
{58319}{58355}`F` 是代表文件
{58393}{58446}这样就找到了符合的文件
{58496}{58570}也可以针对非路径和非文件名的查找
{58571}{58629}运用不同的 flag
{58644}{58779}比如可以查找被修改过的文件
{58780}{58848}这里 `-mtime` 代表修改时间
{58849}{58926}在最近一天被修改过的东西
{58927}{58984}啊，基本就是这个文件夹的所有东西
{58985}{59063}打印出了我们刚创建的文件
{59064}{59127}和先前就有的文件
{59128}{59195}你甚至可以用其他条件
{59196}{59321}比如大小，所有者，权限，等等
{59358}{59464}更强大的是，`find` 不仅查找东西
{59465}{59574}找到之后还能做别的
{59586}{59847}我们可以查找所有扩展名是 `.tmp` 的文件
{59876}{59930}是代表临时文件的扩展名
{59942}{60083}然后要求 `find` 对于所有这些文件
{60084}{60190}执行 `rm` 命令
{60203}{60296}这会对所有这些文件调用 `rm` 
{60312}{60401}我们先不带 `rm` 执行一下
{60425}{60467}再带着它执行一下
{60502}{60592}再次根据命令行的设计哲学
{60627}{60663}看起来无事发生
{60664}{60863}但我们有 `0` 错误代码，就是有事发生
{60864}{60937}那就是所有命令执行成功，一切顺利
{60938}{61014}然后现在再找下这些文件
{61015}{61088}就找不到了
{61156}{61266}总体来说， Shell 的另一个好处
{61267}{61322}就是即便有了这些工具
{61348}{61425}人们也在创造新的方式
{61426}{61509}用别的方法开发这些工具
{61510}{61564}了解一下挺不错的[*]
{61565}{61806}比如你只想找以 `tmp` 结尾的东西
{61807}{61884}做这种挺另类的事情
{61885}{61934}你看这命令其实挺长的
{61935}{62043}有一个工具叫 `fd`
{62044}{62120}举个栗子，这命令更短
{62121}{62181}而且默认使用正则表达式[*]
{62182}{62248}还会忽略你的 gitfile[*]
{62249}{62306}你不会想搜到那堆东西的
{62345}{62456}还有彩色代码和更好的 Unicode 支持……
{62457}{62536}了解这些工具挺好的
{62537}{62625}但是重申，核心思想是
{62626}{62751}你要是知道这些东西存在
{62752}{62895}就能省去做重复性、无意义工作的时间
{62959}{62991}另一个要记住的命令是
{62992}{63023}呃，就比如 `find`
{63024}{63083}部分同学可能会好奇……
{63084}{63230}`find` 可能就是遍历目录结构
{63231}{63274}去找匹配的事物
{63287}{63350}那我要是每天高强度 `find` 呢？
{63351}{63434}如果能给整个数据库出来
{63435}{63575}然后建个索引，不断维护它
{63576}{63633}岂不美哉
{63634}{63711}呃，其实大部分 UNIX 系统已经有了
{63712}{63800}可以用 `locate` 命令
{63801}{63969}这个 `locate` 会……
{63970}{64197}它会查找文件系统中具有指定子串的路径
{64198}{64285}我不知道这行不行……
{64286}{64316}哦看来可以
{64317}{64498}我来试试找 `missing-semester`
{64590}{64689}得等一会，就能找到这些东西
{64690}{64714}都是在我文件系统里面
{64715}{64874}因为事先建立了索引，它就会快得多
{64877}{64977}然后，如果要更新它的话
{64978}{65080}用这个 `updatedb` 命令
{65081}{65265}通常由 cron 定期执行来更新数据库。[*]
{65310}{65384}另外，查找文件是很有门道的
{65385}{65510}实际上，有时你不关心文件本身
{65511}{65573}而是文件的内容
{65604}{65576}这方面可以用前面见过的 `grep` 命令
{65577}{65919}比如 `grep foobar mcd.sh`
{65920}{65945}找到了
{65964}{66132}如果你还是想递归当前目录结构
{66133}{66177}去查找更多的文件该怎么办
{66178}{66271}你不会愿意亲手干苦活的
{66274}{66331}我们可以用 `find` 命令结合 `-exec`
{66340}{66444}但 `grep` 有一个大写 `-R` 的 flag
{66445}{66604}是可以找遍整个目录的
{66605}{66665}啊，应该是这样儿
{66688}{66723}它告诉我们，噢
{66724}{66830}`example.sh` 中有包含 `foobar` 的行
{66831}{66884}在这三个行的位置都有
{66885}{66948}并且这两个位置也有 `foobar`
{67031}{67078}这个挺省事的
{67079}{67213}主要是当你记得你用一些程序语言
{67214}{67282}写了一些代码的时候
{67283}{67366}你知道它就在你文件系统的某处躺着
{67367}{67410}但你就是想不起来
{67411}{67477}用这招就可以快速搜索
{67486}{67598}比如我可以快速搜索草稿文件夹里
{67674}{67969}所有我用了 `request` 库的 Python 代码
{67981}{68009}如果我执行命令
{68010}{68200}就能查到这些文件，精确到匹配的行
{68201}{68293}比起用 `grep`，虽然它挺好
{68294}{68388}你也可以……我用了 `ripgrep`
{68396}{68527}原理是一样的，但是它也是
{68528}{68583}加了亿点点细节
{68584}{68788}比如代码彩色和文件处理啥的
{68789}{68855}也有 Unicode 支持
{68864}{68914}而且跑的还快
{68915}{69037}所以它没为了这些花招拖慢速度
{69100}{69159}还有很多有用的 flag
{69160}{69318}比如说你想，哦，我想要点上下文
{69395}{69513}这样就是结果附近的五行
{69521}{69623}你就能知道那个 `import` 大概在哪
{69624}{69692}它周围都是什么代码
{69696}{69735}这里找这个 `import` 不怎么实用
{69736}{69825}但是比如，你要查你在哪调用了函数
{69826}{69932}它就很给力
{69963}{70175}我们也可以搜索，比如说
{70176}{70277}一个更高级的用法
{70278}{70484}解释一下，`-u` 是不忽略隐藏文件[*]
{70485}{70673}有时候你想忽略隐藏文件
{70674}{70794}但如果你想查找配置（config）文件
{70795}{70841}它们大多是默认隐藏的，这样子
{70842}{70948}然后，这里不是打印匹配内容
{70961}{71026}而我们要求它，呃，这大概是
{71027}{71129}我觉得 `grep` 做不到的
{71130}{71231}就是，我要你打印出所有
{71232}{71320}不匹配这个模式的内容
{71336}{71408}这么做可能挺奇怪的
{71409}{71452}接着往下看……
{71453}{71496}这里这个模式（pattern）是一个
{71510}{71554}小巧的正则表达式
{71563}{71697}意思是，匹配行首有 `#!` 的内容
{71721}{71743}这是个 `shebang`
{71744}{71912}也就是说我们在搜索没有 shebang 的文件
{71923}{72039}这里还给了一个 `-t sh` 是说
{72040}{72106}只搜索 `.sh` （后缀名）的文件
{72107}{72233}因为实际来讲 Python 或者文本文件
{72234}{72267}少了 shebang 也没问题
{72281}{72305}这里它告诉我们
{72306}{72377}「哦，`mcd.sh` 明显少了个 shebang」
{72448}{72553}我们还可以……它有一些好用的 flag
{72554}{72633}比如加上这个 `--stats` flag
{72871}{72945}它也会得到这些结果
{72946}{73054}不过它还会告诉我们
{73055}{73148}比如成功匹配了多少行
{73149}{73231}查找了多少行多少文件
{73232}{73277}打印了多少 byte，等等
{73323}{73422}类似 `fd` 这种，有时候单会一个工具
{73465}{73522}其实不是很好
{73523}{73628}实际上有很多类似 `ripgrep` 的工具
{73629}{73751}比如 `ack`，也是 `grep` 一个替代
{73764}{73893}还有 `ag`，那个“银子”搜索器[*]
{73894}{73973}这些基本都是可替换的
{73974}{74026}有可能你用某个操作系统
{74027}{74064}发现它有某一个，没有另一个
{74065}{74201}只要知道你可以用这些工具就行
{74243}{74325}最后我想讲讲，怎么去做一些
{74326}{74381}不是去找文件或者代码
{74382}{74528}而是找一些已经执行过的命令
{74606}{74717}首先，显然可以用上箭头
{74734}{74847}慢慢儿翻你的历史记录
{74848}{74927}你可能也觉得，这不是很有效率
{74928}{75091}所以 bash 有一些更简单的方法
{75101}{75137}有个 `history` 命令
{75138}{75172}它会打印出你的命令历史记录
{75181}{75277}这里我用的 zsh，所以只会打印一部分
{75278}{75407}如果我想从开头全打印出来
{75415}{75550}这就不管是啥，都给打印出来了
{75552}{75622}因为这记录挺多的
{75623}{75745}比如我只关心用了 `convert` 的命令
{75746}{75867}它把某种类型的文件转到另一种
{75868}{75939}呃 抱歉，是图片类型（而非所有文件）
{75940}{76052}这里就是所有的结果
{76053}{76142}所有匹配上这个子字符串的
{76239}{76344}更进一步，基本上所有 Shell 
{76345}{76423}默认都会把 `Ctrl`+`R` 这个组合键
{76424}{76486}设成（按执行时间）倒序搜索（backward search）
{76487}{76537}这里我们打开倒序搜索
{76538}{76594}然后输入 `convert` 
{76595}{76684}就会找到与之匹配的命令
{76685}{76752}如果我们接着按 `Ctrl`+`R`
{76753}{76839}就会倒着往前搜索匹配的命令
{76840}{76954}也可以重新执行命令
{76978}{77116}另一个相关的是
{77117}{77198}你可以用这个叫 `fzf` 的高级货
{77199}{77279}它就是一个模糊搜索工具
{77280}{77410}像是一个交互式的 `grep`
{77464}{77587}举个栗子，先 `cat` 一下我们这个
{77588}{77677}`example.sh`
{77689}{77745}就会打印到标准输出
{77746}{77805}然后我们用管道连到 `fzf` 上
{77806}{77860}先是显示出所有行
{77861}{77998}然后可以实时地输入要找的字符串
{78030}{78111}`fzf` 有一个好，就是
{78112}{78199}如果你打开默认绑定，它会绑定到
{78200}{78410}Shell 的 `Ctrl`+`R` 执行上
{78411}{78557}然后你就可以动态的查看
{78558}{78645}历史记录里转换 `favicon` 的命令
{78668}{78746}它还是模糊匹配的
{78747}{78806}比起在 `grep` 里默认你得
{78807}{78970}写正则表达式才能搞定这种情况
{78971}{79046}这里就只打 `convert` 和 `favicon`
{79047}{79129}它就能尝试最优的扫描策略
{79130}{79194}在给定的行里匹配出来
{79266}{79343}最后就是这个工具
{79344}{79407}你们已经看到了我一直用的
{79408}{79480}免去打那些又臭又长的命令
{79481}{79575}就是这个历史记录子串查找[*]
{79576}{79677}当我在 Shell 里输入的时候
{79678}{79784}（呃，这个忘记介绍了）
{79785}{79881}（就是 fish，我以为我提到过的）[*]
{79882}{79951}fish 和 zsh 都有很好的实现
{79986}{80060}它们可以，当你打字的时候
{80061}{80157}动态搜索你的历史记录
{80158}{80232}找到前缀相符的一个命令
{80270}{80502}如果匹配的那条不相符了也会变化
{80503}{80560}如果你按一下右箭头
{80561}{80667}就能选中这个命令，就可以重新执行
{81209}{81268}我们已经见识了一大堆东西了
{81269}{81346}我觉得我还剩下几分钟
{81347}{81470}我打算讲几个工具
{81471}{81599}可以快速列出目录和定位目录的
{81600}{81911}确实可以用 `-R` 递归列出目录结构
{81912}{81983}但是这样不是很好受
{81984}{82057}呃 我轻易读不懂这一堆鬼玩意
{82104}{82203}有个叫 `tree` 的工具可以
{82204}{82373}用比较友好的格式打印这些东西
{82374}{82427}它也会用彩色文本，基于……
{82428}{82478}就比如说 `foo` 是蓝的
{82479}{82549}代表是个目录
{82550}{82646}这个是红的，因为有执行权限
{82671}{82727}我们还可以再深入些
{82728}{82856}有些好用的，比如最近有个
{82857}{82933}`broot`，也是做差不多的事情
{82934}{83051}但是比起列出所有文件
{83052}{83097}比如说在 `bar` 里我们有
{83098}{83152}`a` 一直到 `j` 这些文件
{83153}{83230}它会提示「还有更多文件，未列出」
{83264}{83346}我还可以开始输入，它也会
{83347}{83451}模糊匹配这些文件
{83452}{83542}我可以快速的选择和定位
{83563}{83610}所以还是说
{83611}{83711}知道有这些东西挺好
{83712}{83880}你就不会浪费太多时间
{83947}{84013}还有就是，我记得我装了
{84014}{84150}也是一个，你可能希望你的操作系统该带的
{84151}{84255}比如 Nautilus 或者 mac 的访达[*]
{84256}{84443}有一个交互式的界面
{84444}{84574}你可以用箭头定向，浏览
{84602}{84633}这也许有点过犹不及了
{84634}{84723}但如果在里面走一圈
{84724}{84835}你能够很快速地理解目录结构
{84844}{84899}而且基本所有这些工具
{84900}{84989}去看看选项列表
{84990}{85071}它都可以让你编辑和复制文件什么的
{85137}{85194}最后附加一项就是你怎么
{85195}{85239}去到一个位置
{85240}{85290}我们有 `cd`，挺好用的
{85291}{85445}可以让你进入很多地方
{85446}{85506}但是如果你能快速去到
{85507}{85706}你最近访问的，或者经常访问的地方
{85707}{85748}还是挺美妙的
{85764}{85864}这个有挺多实现方式的
{85865}{85926}你可以考虑，哦，我可以做标签
{85927}{86004}我可以在 Shell 里设置别名
{86005}{86071}这个挑时间会讲
{86072}{86112}还有符号链接……
{86140}{86191}不过当前来说
{86192}{86264}写了这些工具的程序员们
{86265}{86379}他们搞出了一个特别好的方式
{86416}{86506}有一个是用叫「autojump」的项目……
{86507}{86570}……也许我这里没有……？
{86848}{86930}呃啊。没事儿，我会在讲到
{86931}{86974}命令行环境的时候再讲
{87064}{87170}我觉得大概是我禁用了 `Ctrl`+`R`
{87171}{87271}影响到了脚本的其他部分
{87285}{87347}我认为现在如果任何人
{87348}{87422}有相关问题的话
{87423}{87478}如果有东西我没讲清楚的话
{87479}{87537}我非常乐于解答
{87538}{87688}没有的话，我们搞了一堆习题
{87689}{87749}差不多都是这些主题的
{87750}{87801}我们鼓励你去做一下
{87802}{87878}以及办公时间来找我们
{87879}{87944}我们可以帮你搞明白习题
{87945}{88023}或者没说清楚的一些 bash 的细节

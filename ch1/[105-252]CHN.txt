【105】之前我提到了，呃，命令错误什么的

昨天我们看过，总体来说……

一个进程有许多方式

和其他进程或命令交互

我们提到了标准输入（流）

它就是好比……

（程序）从标准输入获取各种东西

然后把东西输到标准输出里

还有些东西更有意思

也有一个标准错误（流）

【114】如果你程序出错了

你想输出错误却不污染标准输出

就可以写进这个流

也有错误代码（error code）这种东西

而且它普遍存在于很多编程语言

是一种告诉你整个运行过程

结果如何的方式

所以，比如我们试试

`echo "Hello"`

然后查一下错误代码的值，它是 `0`

`0` 是因为一切正常，没有出问题

这种 `0` 退出码和它在[*]
*这里把 error code 和 C 语言中的 exit code 做对比

【124】比如 C 这种语言里，代表的意思一样

`0` 就代表所有事情正常，没出错误

然而，有时候事情会出错

比如有时候，我们尝试在 `mcd` 脚本里

`grep foobar` 的话

现在查一下值，就是 `1`

这是因为我们试着在 `mcd` 脚本里

搜索 `foobar` 字符串，而它不存在

所以 `grep` 什么都没输出

但是通过反馈一个 `1` 的错误代码

它让我们知道这件事没成功

【133】有一些有意思的命令，比如

`true` 的错误代码始终是 `0` 

`false` 的错误代码则是 `1` 

还有比如这些逻辑运算符

你可以用来做条件判断

比如……其实你也有 `if-else` 

之后我们会说

但是现在你可以做一些

比如 `false`，然后 `echo "Oops fail"`

这里有两个被或运算符链接的命令

【142】这里 bash 要做的是，执行第一个命令

如果第一个命令失败，再去执行第二个[*]
*这里是短路运算法则，详细解释参见网络

这里我们有这个结果

因为它尝试做一个逻辑或

如果第一个（命令）没有 `0` 错误码

它就会去执行第二个（命令）

相似地，如果我们把 `false`

替换成比如 `true`

因为我们有一个 `0` 错误代码

所以第二个（命令）会被短路

所以就不会打印

【151】相似地，我们有与运算符

它仅当第一个命令执行无错误时

才会执行第二个部分

这里也是同样的事情：

如果第一个失败，那么第二个命令

就不会被执行

虽然不是很相关，但是另一个事情是

无论你执行什么，你都可以通过

在同一行内使用分号来连接命令

它就会始终被打印出来

【160】在这之后，我们还没学到的是

怎样把命令的输出存到变量里

我们可以这样做

这里我们获取 `pwd` 命令的输出

它会打印出当前工作目录

也就是我们在哪里

然后把这个存进 `foo` 变量

然后现在我们询问 `foo` 的值

我们就能看到这个字符串

【168】更广泛的说，我们可以做一个叫

命令替换的事情

通过把它放进任意字符串中

而且因为我们用的不是单引号

而是双引号

所以这串东西会被展开

告诉我们，现在位于这个文件夹

另一个有趣的事情是

这个会展开成一个字符串

而不是……

呃，它只是展开成一个字符串

【176】另一个好用但知名度更低的工具

叫做过程替换

和之前那个是类似的

它会做什么呢……它会

比如这里的 `<(` ，接一个命令，再接 `)`

它的作用是，内部的命令会被执行

其输出将被存储到，大概像一个

临时文件内，然后把文件 handle（标识符）[*]
*handle 在国内常译作「句柄」。但这里应该指的就是文件本身，为避免冲突不译做句柄。

交给（最左面的）命令

【182】所以这里我们在……`ls` 这个目录

把输出放到临时文件内

再对父目录如法炮制

然后把两个文件连接

而这种写法就非常得劲

因为有些命令会从

某些文件的内容，而不是标准输入

获得输入参数

所以我们把这两个命令连起来了

感觉讲到现在，讲了真不少东西

来看一个里面包含这些内容的

【190】简单的示例脚本

比如说这里我们有个字符串

然后有个 `$(date)`

这个 `date` 是个程序

重复一下，类 UNIX 系统有很多程序

你会慢慢都熟悉它们的

`date` 就打印出当前的日期

你还可以指定各种打印格式

然后这里有这个 `$0`

是我们运行的这个脚本的文件名

然后是这个 `$#`，代表给定的参数个数

然后 `$$` 是这个命令的进程 ID[*]
*一般缩写为 PID，操作系统相关，详见网络资料

【200】强调，这里有很多 `$`+ 什么什么

它们（的含义）并不直观

因为你找不到一种巧记的方法

`$#` 这种大概就是

但是……你一直和它们打照面

逐渐就能熟络起来

这里还有个 `$@`

可以展开成所有参数

所以比起来……比如有三个参数

那我可以键入 `$1 $2 $3`

【208】那如果我们不知道有多少参数

我们可以用这种方式把这些参数全部放在这里

然后这些参数被传给 `for` 循环

`for` 循环会创建一个 `file` 变量

依次地用这些参数赋值给 `file` 变量

下一行我们运行 `grep` 命令

它会在一堆文件里搜索一个子串[*]
*这里子串意指一个字符串中连续的一小部分

这里我们在文件里搜索字符串 `foobar`

这里我们让 `file` 变量展开为它的值

昨天说过，如果我们在意程序输出的话

【218】我们可以把它重定向到某处

到一个文件里保存下来，或者连接组合

嘿，但有时候情况恰恰相反

有时候，比如说，我们想知道

这个脚本的错误代码是什么

我想知道 `grep` 能不能成功查找

所以，我们甚至能直接扔掉整个输出

包括标准输出和标准错误（流）

【225】这里我们做的是

把两个输出重定向到 `/dev/null`

它是 UNIX 系统的一种特殊设备

输出到它的内容会被丢弃

就是你可以随意乱写乱画

然后所有内容都会被丢掉

还有这个 `>` 符号

【232】昨天说过，用来重定向输出的

这里有个 `2>`

有些人也许猜到了

它是重定向标准错误流的

因为这两个流是分立的

所以你得告诉 bash 去操作哪个

所以这里我们执行命令

去检查文件有没有 `foobar`

如果有的话，返回一个 `0` 错误码

如果没有，就是一个非 `0` 码

我们正是要检查这个

【243】这部分命令里

我们先告诉它：「给我错误代码」

这个是用 `$?`

然后是一个比较运算符 `-ne`

代表不等于（`N`on `E`qual）

其他编程语言里有像

`==` 和 `!=` 这种符号

bash 里有很多预设的比较运算

这主要是为了你用 Shell 的时候

有很多东西要去做测试
1
00:00:00,400 --> 00:00:02,859
Okay, welcome back.

2
00:00:02,859 --> 00:00:05,919
Today we're gonna cover a couple separate

3
00:00:05,919 --> 00:00:07,619
two main topics related to the shell.

4
00:00:07,620 --> 00:00:11,240
First, we're gonna do some kind of shell
scripting, mainly related to bash,

5
00:00:11,240 --> 00:00:14,160
which is the shell that most of you will start

6
00:00:14,160 --> 00:00:18,520
in Mac, or like in most Linux systems,
that's the default shell.

7
00:00:18,519 --> 00:00:22,719
And it's also kind of backward compatible through
other shells like zsh, it's pretty nice.

8
00:00:22,739 --> 00:00:25,939
And then we're gonna cover some other shell
tools that are really convenient,

9
00:00:26,059 --> 00:00:29,319
so you avoid doing really repetitive tasks,

10
00:00:29,320 --> 00:00:31,580
like looking for some piece of code

11
00:00:31,579 --> 00:00:33,419
or for some elusive file.

12
00:00:33,420 --> 00:00:36,160
And there are already really
nice built-in commands

13
00:00:36,159 --> 00:00:40,959
that will really help you to do those things.

14
00:00:40,960 --> 00:00:43,260
So yesterday we already kind of introduced

15
00:00:43,259 --> 00:00:46,159
you to the shell and some of it's quirks,

16
00:00:46,159 --> 00:00:48,719
and like how you start executing commands,

17
00:00:48,719 --> 00:00:50,599
redirecting them.

18
00:00:50,600 --> 00:00:52,400
Today, we're going to kind of cover more about

19
00:00:52,460 --> 00:00:56,120
the syntax of the variables, the control flow,

20
00:00:56,119 --> 00:00:57,719
functions of the shell.

21
00:00:57,719 --> 00:01:02,699
So for example, once you drop
into a shell, say you want to

22
00:01:02,759 --> 00:01:06,359
define a variable, which is
one of the first things you

23
00:01:06,359 --> 00:01:09,339
learn to do in a programming language.

24
00:01:09,340 --> 00:01:12,740
Here you could do something like foo equals bar.

25
00:01:12,859 --> 00:01:18,399
And now we can access the value
of foo by doing "$foo".

26
00:01:18,459 --> 00:01:21,399
And that's bar, perfect.

27
00:01:21,400 --> 00:01:24,480
One quirk that you need to be aware of is that

28
00:01:24,480 --> 00:01:27,900
spaces are really critical when
you're dealing with bash.

29
00:01:27,900 --> 00:01:33,380
Mainly because spaces are reserved, and
that will be for separating arguments.

30
00:01:33,379 --> 00:01:36,699
So, for example, something like foo equals bar

31
00:01:36,700 --> 00:01:42,000
won't work, and the shell is gonna
tell you why it's not working.

32
00:01:42,000 --> 00:01:46,280
It's because the foo command is not
working, like foo is non-existent.

33
00:01:46,280 --> 00:01:47,780
And here what is actually happening,
we're not assigning foo to bar,

34
00:01:47,780 --> 00:01:52,260
what is happening is we're
calling the foo program

35
00:01:52,260 --> 00:01:57,520
with the first argument "=" and
the second argument "bar".

36
00:01:57,519 --> 00:02:03,879
And in general, whenever you are having
some issues, like some files with spaces

37
00:02:03,879 --> 00:02:06,159
you will need to be careful about that.

38
00:02:06,159 --> 00:02:10,619
You need to be careful about quoting strings.

39
00:02:10,639 --> 00:02:16,479
So, going into that, how you do strings in bash.
There are two ways that you can define a string:

40
00:02:16,539 --> 00:02:24,719
You can define strings using double quotes
and you can define strings using single,

41
00:02:24,719 --> 00:02:26,539
sorry,

42
00:02:26,539 --> 00:02:28,879
using single quotes.

43
00:02:29,139 --> 00:02:32,759
However, for literal strings they are equivalent,

44
00:02:32,759 --> 00:02:35,459
but for the rest they are not equivalent.

45
00:02:35,460 --> 00:02:42,980
So, for example, if we do value is $foo,

46
00:02:43,439 --> 00:02:48,479
the $foo has been expanded like
a string, substituted to the

47
00:02:48,479 --> 00:02:50,819
value of the foo variable in the shell.

48
00:02:50,960 --> 00:02:58,940
Whereas if we do this with a simple quote,
we are just getting the $foo as it is

49
00:02:58,939 --> 00:03:02,279
and single quotes won't be replacing. Again,

50
00:03:02,280 --> 00:03:07,290
it's really easy to write a script, assume that
this is kind of like Python, that you might be

51
00:03:07,289 --> 00:03:10,859
more familiar with, and not realize all that.

52
00:03:10,860 --> 00:03:14,180
And this is the way you will assign variables.

53
00:03:14,180 --> 00:03:17,849
Then bash also has control flow
techniques that we'll see later,

54
00:03:17,848 --> 00:03:24,439
like for loops, while loops, and one main
thing is you can define functions.

55
00:03:24,439 --> 00:03:27,819
We can access a function I have defined here.

56
00:03:28,219 --> 00:03:34,219
Here we have the MCD function, that
has been defined, and the thing is

57
00:03:34,219 --> 00:03:38,399
so far, we have just kind of seen how
to execute several commands by piping

58
00:03:38,400 --> 00:03:40,720
into them, kind of saw that briefly yesterday.

59
00:03:40,939 --> 00:03:44,979
But a lot of times you want to do first
one thing and then another thing.

60
00:03:44,979 --> 00:03:47,579
And that's kind of like the

61
00:03:47,740 --> 00:03:50,880
sequential execution that we get here.

62
00:03:50,879 --> 00:03:54,259
Here, for example, we're
calling the MCD function.

63
00:03:56,860 --> 00:03:57,800
We, first,

64
00:03:57,800 --> 00:04:02,960
are calling the makedir command,
which is creating this directory.

65
00:04:02,960 --> 00:04:05,600
Here, $1 is like a special variable.

66
00:04:05,599 --> 00:04:07,439
This is the way that bash works,

67
00:04:07,439 --> 00:04:12,159
whereas in other scripting languages
there will be like argv,

68
00:04:12,159 --> 00:04:16,619
the first item of the array argv
will contain the argument.

69
00:04:16,620 --> 00:04:19,160
In bash it's $1. And in general, a lot

70
00:04:19,160 --> 00:04:21,640
of things in bash will be dollar something

71
00:04:21,639 --> 00:04:26,679
and will be reserved, we will
be seeing more examples later.

72
00:04:26,680 --> 00:04:30,290
And once we have created the folder,
we CD into that folder,

73
00:04:30,290 --> 00:04:34,687
which is kind of a fairly common
pattern that you will see.

74
00:04:34,687 --> 00:04:39,060
We will actually type this directly
into our shell, and it will work and

75
00:04:39,120 --> 00:04:45,260
it will define this function. But sometimes
it's nicer to write things in a file.

76
00:04:45,259 --> 00:04:50,039
What we can do is we can source
this. And that will

77
00:04:50,079 --> 00:04:53,959
execute this script in our shell and load it.

78
00:04:53,959 --> 00:04:59,339
So now it looks like nothing happened,
but now the MCD function has

79
00:04:59,339 --> 00:05:03,459
been defined in our shell. So
we can now for example do

80
00:05:03,463 --> 00:05:09,150
MCD test, and now we move from
the tools directory to the test

81
00:05:09,160 --> 00:05:14,200
directory. We both created the
folder and we moved into it.

82
00:05:15,759 --> 00:05:18,819
What else. So a result is...

83
00:05:18,819 --> 00:05:22,159
We can access the first argument with $1.

84
00:05:22,160 --> 00:05:26,100
There's a lot more reserved commands,

85
00:05:26,100 --> 00:05:30,020
for example $0 will be the name of the script,

86
00:05:30,019 --> 00:05:35,259
$2 through $9 will be the second
through the ninth arguments

87
00:05:35,259 --> 00:05:38,069
that the bash script takes.
Some of these reserved

88
00:05:38,069 --> 00:05:43,079
keywords can be directly used
in the shell, so for example

89
00:05:43,420 --> 00:05:50,300
$? will get you the error code
from the previous command,

90
00:05:50,300 --> 00:05:53,580
which I'll also explain briefly.

91
00:05:53,579 --> 00:05:58,319
But for example, $_ will get
you the last argument of the

92
00:05:58,319 --> 00:06:03,459
previous command. So another way
we could have done this is

93
00:06:03,459 --> 00:06:07,379
we could have said like "mkdir test"

94
00:06:07,379 --> 00:06:12,019
and instead of rewriting test, we
can access that last argument

95
00:06:12,019 --> 00:06:18,399
as part of the (previous command), using $_

96
00:06:18,399 --> 00:06:23,159
like, that will be replaced with
test and now we go into test.

97
00:06:25,040 --> 00:06:27,480
There are a lot of them, you
should familiarize with them.

98
00:06:27,480 --> 00:06:32,900
Another one I often use is called "bang
bang" ("!!"), you will run into this

99
00:06:32,910 --> 00:06:37,300
whenever you, for example, are trying
to create something and you don't have

100
00:06:37,319 --> 00:06:40,999
enough permissions. Then, you can do "sudo !!"

101
00:06:41,009 --> 00:06:43,399
and then that will replace the command in

102
00:06:43,470 --> 00:06:46,400
there and now you can just try doing

103
00:06:46,439 --> 00:06:48,379
that. And now it will prompt you for a password,

104
00:06:48,379 --> 00:06:50,079
because you have sudo permissions.

105
00:06:53,800 --> 00:06:57,180
Before, I mentioned the, kind
of the error command.

106
00:06:57,180 --> 00:06:59,400
Yesterday we saw that, in general, there are

107
00:06:59,399 --> 00:07:02,399
different ways a process can communicate

108
00:07:02,399 --> 00:07:05,090
with other processes or commands.

109
00:07:05,100 --> 00:07:08,420
We mentioned the standard
input, which also was like

110
00:07:09,160 --> 00:07:11,380
getting stuff through the standard input,

111
00:07:11,639 --> 00:07:13,839
putting stuff into the standard output.

112
00:07:13,839 --> 00:07:16,829
There are a couple more interesting
things, there's also like a

113
00:07:16,829 --> 00:07:19,836
standard error, a stream where you write errors

114
00:07:19,836 --> 00:07:23,899
that happen with your program and you don't
want to pollute the standard output.

115
00:07:23,899 --> 00:07:27,419
There's also the error code,
which is like a general

116
00:07:27,420 --> 00:07:29,520
thing in a lot of programming languages,

117
00:07:29,519 --> 00:07:34,459
some way of reporting how the
entire run of something went.

118
00:07:34,459 --> 00:07:36,059
So if we do

119
00:07:36,060 --> 00:07:41,020
something like echo hello and we

120
00:07:41,579 --> 00:07:43,919
query for the value, it's zero. And it's zero

121
00:07:43,920 --> 00:07:45,840
because everything went okay and there

122
00:07:45,839 --> 00:07:49,169
weren't any issues. And a zero exit code is

123
00:07:49,170 --> 00:07:50,940
the same as you will get in a language

124
00:07:50,939 --> 00:07:54,979
like C, like 0 means everything
went fine, there were no errors.

125
00:07:54,980 --> 00:07:57,600
However, sometimes things won't work.

126
00:07:57,600 --> 00:08:04,600
Sometimes, like if we try to grep
for foobar in our MCD script,

127
00:08:04,600 --> 00:08:08,130
and now we check for that
value, it's 1. And that's

128
00:08:08,129 --> 00:08:10,769
because we tried to search for the foobar

129
00:08:10,769 --> 00:08:13,619
string in the MCD script and it wasn't there.

130
00:08:13,620 --> 00:08:17,190
So grep doesn't print anything, but

131
00:08:17,189 --> 00:08:19,949
let us know that things didn't work by

132
00:08:19,949 --> 00:08:22,259
giving us a 1 error code.

133
00:08:22,259 --> 00:08:24,419
There are some interesting commands like

134
00:08:24,420 --> 00:08:29,160
"true", for example, will always have a zero

135
00:08:29,160 --> 00:08:35,060
error code, and false will always
have a one error code.

136
00:08:35,059 --> 00:08:37,918
Then there are like

137
00:08:37,918 --> 00:08:40,079
these logical operators that you can use

138
00:08:40,080 --> 00:08:43,808
to do some sort of conditionals.
For example, one way...

139
00:08:43,807 --> 00:08:47,159
you also have IF's and ELSE's, that
we will see later, but you can do

140
00:08:47,159 --> 00:08:51,919
something like "false", and echo "Oops fail".

141
00:08:51,919 --> 00:08:56,299
So here we have two commands connected
by this OR operator.

142
00:08:56,299 --> 00:09:00,249
What bash is gonna do here, it's
gonna execute the first one

143
00:09:00,250 --> 00:09:04,450
and if the first one didn't work, then it's

144
00:09:04,450 --> 00:09:07,380
gonna execute the second one. So here we get it,

145
00:09:07,379 --> 00:09:11,999
because it's gonna try to do a logical
OR. If the first one didn't have

146
00:09:12,000 --> 00:09:15,959
a zero error code, it's gonna try to
do the second one. Similarly, if we

147
00:09:15,960 --> 00:09:19,580
instead of use "false", we
use something like "true",

148
00:09:19,580 --> 00:09:22,180
since true will have a zero error code, then the

149
00:09:22,179 --> 00:09:24,699
second one will be short-circuited and

150
00:09:24,700 --> 00:09:27,500
it won't be printed.

151
00:09:32,559 --> 00:09:36,969
Similarly, we have an AND
operator which will only

152
00:09:36,970 --> 00:09:39,430
execute the second part if the first one

153
00:09:39,429 --> 00:09:41,439
ran without errors.

154
00:09:41,440 --> 00:09:44,820
And the same thing will happen.

155
00:09:44,820 --> 00:09:50,340
If the first one fails, then the second
part of this thing won't be executed.

156
00:09:50,340 --> 00:09:57,280
Kind of not exactly related to that, but
another thing that you will see is

157
00:10:00,019 --> 00:10:04,119
that no matter what you execute,
then you can concatenate

158
00:10:04,120 --> 00:10:07,120
commands using a semicolon in the same line,

159
00:10:07,120 --> 00:10:10,300
and that will always print.

160
00:10:10,299 --> 00:10:13,629
Beyond that, what we haven't
seen, for example, is how

161
00:10:13,629 --> 00:10:19,459
you go about getting the output
of a command into a variable.

162
00:10:19,629 --> 00:10:24,119
And the way we can do that is
doing something like this.

163
00:10:24,120 --> 00:10:29,480
What we're doing here is we're getting
the output of the PWD command,

164
00:10:29,480 --> 00:10:32,720
which is just printing the
present working directory

165
00:10:32,720 --> 00:10:33,740
where we are right now.

166
00:10:33,740 --> 00:10:37,220
And then we're storing that
into the foo variable.

167
00:10:37,220 --> 00:10:42,279
So we do that and then we ask
for foo, we view our string.

168
00:10:42,279 --> 00:10:48,459
More generally, we can do this thing
called command substitution

169
00:10:50,110 --> 00:10:51,500
by putting it into any string.

170
00:10:51,500 --> 00:10:55,161
And since we're using double quotes
instead of single quotes

171
00:10:55,162 --> 00:10:57,440
that thing will be expanded and

172
00:10:57,440 --> 00:11:02,740
it will tell us that we are
in this working folder.

173
00:11:02,740 --> 00:11:09,240
Another interesting thing is, right now,
what this is expanding to is a string

174
00:11:09,399 --> 00:11:10,299
instead of

175
00:11:11,919 --> 00:11:13,319
It's just expanding as a string.

176
00:11:13,460 --> 00:11:17,640
Another nifty and lesser known tool
is called process substitution,

177
00:11:17,639 --> 00:11:20,539
which is kind of similar. What it will do...

178
00:11:24,360 --> 00:11:30,041
it will, here for example, the "&lt;(",
some command and another parenthesis,

179
00:11:30,041 --> 00:11:34,840
what that will do is: that will execute,
that will get the output to

180
00:11:34,840 --> 00:11:39,120
kind of like a temporary file and it will
give the file handle to the command.

181
00:11:39,120 --> 00:11:42,020
So here what we're doing is we're getting...

182
00:11:42,019 --> 00:11:45,759
we're LS'ing the directory, putting
it into a temporary file,

183
00:11:45,759 --> 00:11:48,039
doing the same thing for the
parent folder and then

184
00:11:48,039 --> 00:11:51,309
we're concatenating both files. And this

185
00:11:51,309 --> 00:11:55,519
will, may be really handy, because
some commands instead of expecting

186
00:11:55,519 --> 00:11:59,499
the input coming from the stdin,
they are expecting things to

187
00:11:59,500 --> 00:12:03,559
come from some file that is giving
some of the arguments.

188
00:12:04,700 --> 00:12:07,620
So we get both things concatenated.

189
00:12:12,879 --> 00:12:17,039
I think so far there's been a lot of
information, let's see a simple,

190
00:12:17,039 --> 00:12:22,919
an example script where we
see a few of these things.

191
00:12:23,200 --> 00:12:27,220
So for example here we have a string and we

192
00:12:27,220 --> 00:12:30,327
have this $date. So $date is a program.

193
00:12:30,326 --> 00:12:34,539
Again there's a lot of programs
in UNIX you will kind of slowly

194
00:12:34,539 --> 00:12:36,119
familiarize with a lot of them.

195
00:12:36,120 --> 00:12:42,820
Date just prints what the current date is
and you can specify different formats.

196
00:12:43,799 --> 00:12:48,699
Then, we have these $0 here. $0 is the name

197
00:12:48,700 --> 00:12:50,540
of the script that we're running.

198
00:12:50,549 --> 00:12:56,589
Then we have $#, that's the number
of arguments that we are giving

199
00:12:56,590 --> 00:13:01,920
to the command, and then $$ is the process
ID of this command that is running.

200
00:13:01,919 --> 00:13:06,159
Again, there's a lot of these dollar
things, they're not intuitive

201
00:13:06,159 --> 00:13:07,689
because they don't have like a mnemonic

202
00:13:07,690 --> 00:13:10,450
way of remembering, maybe, $#. But

203
00:13:10,450 --> 00:13:12,880
it can be... you will just be

204
00:13:12,879 --> 00:13:14,659
seeing them and getting familiar with them.

205
00:13:14,659 --> 00:13:19,199
Here we have this $@, and that will
expand to all the arguments.

206
00:13:19,200 --> 00:13:21,480
So, instead of having to assume that,

207
00:13:21,490 --> 00:13:25,840
maybe say, we have three arguments
and writing $1, $2, $3,

208
00:13:25,840 --> 00:13:29,760
if we don't know how many arguments we
can put all those arguments there.

209
00:13:29,759 --> 00:13:33,669
And that has been given to a
for loop. And the for loop

210
00:13:33,669 --> 00:13:39,019
will, in time, get the file variable

211
00:13:39,019 --> 00:13:43,879
and it will be giving each one of the arguments.

212
00:13:43,879 --> 00:13:47,528
So what we're doing is, for every
one of the arguments we're giving.

213
00:13:47,528 --> 00:13:51,698
Then, in the next line we're running the

214
00:13:51,698 --> 00:13:56,919
grep command which is just search for
a substring in some file and we're

215
00:13:56,919 --> 00:14:01,379
searching for the string foobar in the file.

216
00:14:01,379 --> 00:14:06,489
Here, we have put the variable
that the file took, to expand.

217
00:14:06,490 --> 00:14:11,559
And yesterday we saw that if we care
about the output of a program, we can

218
00:14:11,559 --> 00:14:15,679
redirect it to somewhere, to save it
or to connect it to some other file.

219
00:14:15,679 --> 00:14:18,938
But sometimes you want the opposite.

220
00:14:18,938 --> 00:14:21,259
Sometimes, here for example, we care...

221
00:14:21,259 --> 00:14:25,118
we're gonna care about the error code. About
this script, we're gonna care whether the

222
00:14:25,120 --> 00:14:28,440
grep ran successfully or it didn't.

223
00:14:28,440 --> 00:14:33,220
So we can actually discard
entirely what the output...

224
00:14:33,220 --> 00:14:37,480
like both the standard output and the
standard error of the grep command.

225
00:14:37,480 --> 00:14:39,970
And what we're doing is we're

226
00:14:39,970 --> 00:14:43,029
redirecting the output to /dev/null which

227
00:14:43,028 --> 00:14:46,539
is kind of like a special device in UNIX

228
00:14:46,539 --> 00:14:49,118
systems where you can like write and

229
00:14:49,119 --> 00:14:51,129
it will be discarded. Like you can

230
00:14:51,129 --> 00:14:52,869
write no matter how much you want,

231
00:14:52,869 --> 00:14:57,730
there, and it will be discarded.
And here's the "&gt;" symbol

232
00:14:57,730 --> 00:15:02,199
that we saw yesterday for redirecting
output. Here you have a "2&gt;"

233
00:15:02,198 --> 00:15:04,688
and, as some of you might have

234
00:15:04,688 --> 00:15:06,518
guessed by now, this is for redirecting the

235
00:15:06,519 --> 00:15:08,589
standard error, because those those two

236
00:15:08,589 --> 00:15:11,709
streams are separate, and you kind of have to

237
00:15:11,708 --> 00:15:14,638
tell bash what to do with each one of them.

238
00:15:14,639 --> 00:15:17,529
So here, we run, we check if the file has

239
00:15:17,528 --> 00:15:20,648
foobar, and if the file has foobar then it's

240
00:15:20,649 --> 00:15:22,959
going to have a zero code. If it

241
00:15:22,958 --> 00:15:24,368
doesn't have foobar, it's gonna have a

242
00:15:24,369 --> 00:15:26,980
nonzero error code. So that's exactly what we

243
00:15:26,980 --> 00:15:31,120
check. In this if part of the command we

244
00:15:31,120 --> 00:15:34,840
say "get me the error code". Again, this $?

245
00:15:34,840 --> 00:15:37,240
And then we have a comparison operator

246
00:15:37,240 --> 00:15:41,590
which is "-ne", for "non equal". And some

247
00:15:41,590 --> 00:15:47,650
other programming languages
will have "==", "!=", these

248
00:15:47,649 --> 00:15:51,069
symbols. In bash there's

249
00:15:51,070 --> 00:15:53,650
like a reserved set of comparisons and

250
00:15:53,649 --> 00:15:54,969
it's mainly because there's a lot of

251
00:15:54,970 --> 00:15:57,520
things you might want to test for when

252
00:15:57,519 --> 00:15:59,079
you're in the shell. Here for example

253
00:15:59,080 --> 00:16:03,970
we're just checking for two values, two
integer values, being the same. Or for

254
00:16:03,970 --> 00:16:08,380
example here, the "-F" check will let

255
00:16:08,379 --> 00:16:10,419
us know if a file exists, which is

256
00:16:10,419 --> 00:16:12,219
something that you will run into very,

257
00:16:12,220 --> 00:16:17,530
very commonly. I'm going back to the

258
00:16:17,529 --> 00:16:23,019
example. Then, what happens when we

259
00:16:24,399 --> 00:16:28,599
if the file did not have
foobar, like there was a

260
00:16:28,600 --> 00:16:31,990
nonzero error code, then we print

261
00:16:31,990 --> 00:16:33,400
"this file doesn't have any foobar,

262
00:16:33,399 --> 00:16:36,399
we're going to add one". And what we do is

263
00:16:36,399 --> 00:16:40,749
we echo this "# foobar", hoping this

264
00:16:40,750 --> 00:16:43,200
is a comment to the file and then we're

265
00:16:43,200 --> 00:16:47,620
using the operator "&gt;&gt;" to append at the end of

266
00:16:47,620 --> 00:16:50,800
the file. Here since the file has

267
00:16:50,799 --> 00:16:54,489
been fed through the script, and we don't
know it beforehand, we have to substitute

268
00:16:54,490 --> 00:17:03,430
the variable of the filename. We can
actually run this. We already have

269
00:17:03,429 --> 00:17:05,259
correct permissions in this script and

270
00:17:05,259 --> 00:17:10,539
we can give a few examples. We have a
few files in this folder, "mcd" is the

271
00:17:10,539 --> 00:17:12,759
one we saw at the beginning for the MCD

272
00:17:12,759 --> 00:17:15,039
function, some other "script" function and

273
00:17:15,039 --> 00:17:21,699
we can even feed the own script to itself
to check if it has foobar in it.

274
00:17:21,700 --> 00:17:26,680
And we run it and first we can
see that there's different

275
00:17:26,680 --> 00:17:29,460
variables that we saw, that have been

276
00:17:29,460 --> 00:17:33,400
successfully expanded. We have the date, that has

277
00:17:33,400 --> 00:17:36,700
been replaced to the current time, then

278
00:17:36,700 --> 00:17:39,100
we're running this program, with three

279
00:17:39,099 --> 00:17:44,559
arguments, this randomized PID, and then

280
00:17:44,559 --> 00:17:46,509
it's telling us MCD doesn't have any

281
00:17:46,509 --> 00:17:48,168
foobar, so we are adding a new one,

282
00:17:48,169 --> 00:17:50,450
and this script file doesn't

283
00:17:50,450 --> 00:17:52,970
have one. So now for example let's look at MCD

284
00:17:52,970 --> 00:17:55,820
and it has the comment that we were looking for.

285
00:17:59,000 --> 00:18:05,618
One other thing to know when you're
executing scripts is that

286
00:18:05,618 --> 00:18:07,758
here we have like three completely

287
00:18:07,759 --> 00:18:10,279
different arguments but very commonly

288
00:18:10,278 --> 00:18:12,888
you will be giving arguments that

289
00:18:12,888 --> 00:18:16,099
can be more succinctly given in some way.

290
00:18:16,099 --> 00:18:20,178
So for example here if we wanted to

291
00:18:20,179 --> 00:18:25,429
refer to all the ".sh" scripts we

292
00:18:25,429 --> 00:18:31,120
could just do something like "ls *.sh"

293
00:18:31,119 --> 00:18:36,119
and this is a way of filename expansion
that most shells have

294
00:18:36,119 --> 00:18:38,449
that's called "globbing". Here, as you

295
00:18:38,450 --> 00:18:39,919
might expect, this is gonna say

296
00:18:39,919 --> 00:18:42,559
anything that has any kind of sort of

297
00:18:42,558 --> 00:18:45,939
characters and ends up with "sh".

298
00:18:45,940 --> 00:18:52,159
Unsurprisingly, we get "example.sh"
and "mcd.sh". We also have these

299
00:18:52,159 --> 00:18:54,769
"project1" and "project2", and if there

300
00:18:54,769 --> 00:19:00,100
were like a... we can do a
"project42", for example

301
00:19:00,619 --> 00:19:04,219
And now if we just want to refer
to the projects that have

302
00:19:04,220 --> 00:19:07,279
a single character, but not two characters

303
00:19:07,278 --> 00:19:08,719
afterwards, like any other characters,

304
00:19:08,720 --> 00:19:13,879
we can use the question mark. So "?"
will expand to only a single one.

305
00:19:13,880 --> 00:19:17,360
And we get, LS'ing, first

306
00:19:17,359 --> 00:19:21,048
"project1" and then "project2".

307
00:19:21,048 --> 00:19:27,579
In general, globbing can be very powerful.
You can also combine it.

308
00:19:31,880 --> 00:19:35,480
A common pattern is to use what
is called curly braces.

309
00:19:35,480 --> 00:19:39,320
So let's say we have an image,
that we have in this folder

310
00:19:39,319 --> 00:19:43,619
and we want to convert this image from PNG to JPG

311
00:19:43,619 --> 00:19:46,319
or we could maybe copy it, or...

312
00:19:46,319 --> 00:19:49,608
it's a really common pattern, to have
two or more arguments that are

313
00:19:49,608 --> 00:19:55,239
fairly similar and you want to do something
with them as arguments to some command.

314
00:19:55,240 --> 00:20:01,290
You could do it this way, or more
succinctly, you can just do

315
00:20:01,289 --> 00:20:08,879
"image.{png,jpg}"

316
00:20:09,410 --> 00:20:13,590
And here, I'm getting some color feedback,
but what this will do, is

317
00:20:13,589 --> 00:20:17,609
it'll expand into the line above.

318
00:20:17,609 --> 00:20:23,989
Actually, I can ask zsh to do that for
me. And that what's happening here.

319
00:20:23,990 --> 00:20:26,550
This is really powerful. So for example

320
00:20:26,549 --> 00:20:29,219
you can do something like... we could do...

321
00:20:29,220 --> 00:20:34,220
"touch" on a bunch of foo's, and
all of this will be expanded.

322
00:20:35,519 --> 00:20:41,879
You can also do it at several levels
and you will do the Cartesian...

323
00:20:41,880 --> 00:20:49,980
if we have something like this,
we have one group here, "{1,2}"

324
00:20:49,980 --> 00:20:53,310
and then here there's "{1,2,3}",
and this is going to do

325
00:20:53,309 --> 00:20:54,989
the Cartesian product of these

326
00:20:54,990 --> 00:20:59,920
two expansions and it will expand
into all these things,

327
00:20:59,960 --> 00:21:03,540
that we can quickly "touch".

328
00:21:03,539 --> 00:21:10,519
You can also combine the asterisk
glob with the curly braces glob.

329
00:21:10,519 --> 00:21:16,839
You can even use kind of ranges.
Like, we can do "mkdir"

330
00:21:16,839 --> 00:21:21,419
and we create the "foo" and the
"bar" directories, and then we

331
00:21:21,420 --> 00:21:25,680
can do something along these lines. This

332
00:21:25,680 --> 00:21:28,890
is going to expand to "fooa", "foob"...

333
00:21:28,890 --> 00:21:31,430
like all these combinations, through "j", and

334
00:21:31,430 --> 00:21:35,250
then the same for "bar". I haven't

335
00:21:35,250 --> 00:21:38,609
really tested it... but yeah, we're getting
all these combinations that we

336
00:21:38,609 --> 00:21:41,849
can "touch". And now, if we touch something

337
00:21:41,849 --> 00:21:47,969
that is different between these
two [directories], we

338
00:21:47,970 --> 00:21:55,890
can again showcase the process
substitution that we saw

339
00:21:55,890 --> 00:21:59,610
earlier. Say we want to check what
files are different between these

340
00:21:59,609 --> 00:22:03,399
two folders. For us it's obvious,
we just saw it, it's X and Y,

341
00:22:03,400 --> 00:22:07,410
but we can ask the shell to do
this "diff" for us between the

342
00:22:07,410 --> 00:22:10,200
output of one LS and the other LS.

343
00:22:10,200 --> 00:22:12,810
Unsurprisingly we're getting: X is

344
00:22:12,809 --> 00:22:14,699
only in the first folder and Y is

345
00:22:14,700 --> 00:22:20,970
only in the second folder. What is more

346
00:22:20,970 --> 00:22:26,519
is, right now, we have only seen
bash scripts. If you like other

347
00:22:26,519 --> 00:22:30,259
scripts, like for some tasks bash
is probably not the best,

348
00:22:30,259 --> 00:22:33,118
it can be tricky. You can actually
write scripts that

349
00:22:33,118 --> 00:22:35,699
interact with the shell implemented in a lot

350
00:22:35,700 --> 00:22:39,710
of different languages. So for
example, let's see here a

351
00:22:39,710 --> 00:22:43,139
Python script that has a magic line at the

352
00:22:43,138 --> 00:22:45,538
beginning that I'm not explaining for now.

353
00:22:45,539 --> 00:22:48,329
Then we have "import sys",

354
00:22:48,329 --> 00:22:53,628
it's kind of like... Python is not,
by default, trying to interact

355
00:22:53,628 --> 00:22:56,998
with the shell so you will have to import

356
00:22:56,999 --> 00:22:58,799
some library. And then we're doing a

357
00:22:58,798 --> 00:23:01,528
really silly thing of just iterating

358
00:23:01,528 --> 00:23:06,439
over "sys.argv[1:]".

359
00:23:06,440 --> 00:23:12,809
"sys.argv" is kind of similar to what
in bash we're getting as $0, $1, &amp;c.

360
00:23:12,808 --> 00:23:16,648
Like the vector of the arguments, we're
printing it in the reversed order.

361
00:23:16,648 --> 00:23:21,178
And the magic line at the beginning is

362
00:23:21,179 --> 00:23:23,999
called a shebang and is the way that the

363
00:23:23,999 --> 00:23:26,159
shell will know how to run this program.

364
00:23:26,159 --> 00:23:30,509
You can always do something like

365
00:23:30,509 --> 00:23:34,379
"python script.py", and then "a b c" and that

366
00:23:34,378 --> 00:23:36,658
will work, always, like that. But

367
00:23:36,659 --> 00:23:39,119
what if we want to make this to be

368
00:23:39,118 --> 00:23:41,308
executable from the shell? The way the

369
00:23:41,308 --> 00:23:44,189
shell knows that it has to use python as the

370
00:23:44,190 --> 00:23:48,450
interpreter to run this file is using

371
00:23:48,450 --> 00:23:52,440
that first line. And that first line is

372
00:23:52,440 --> 00:23:56,620
giving it the path to where that thing lives.

373
00:23:58,500 --> 00:23:59,600
However, you might not know.

374
00:23:59,608 --> 00:24:01,829
Like, different machines will have probably

375
00:24:01,829 --> 00:24:04,048
different places where they put python

376
00:24:04,048 --> 00:24:06,089
and you might not want to assume where

377
00:24:06,089 --> 00:24:08,788
python is installed, or any other interpreter.

378
00:24:08,788 --> 00:24:16,378
So one thing that you can do is use the

379
00:24:16,380 --> 00:24:17,720
"env" command.

380
00:24:18,279 --> 00:24:21,559
You can also give arguments in the shebang, so

381
00:24:21,569 --> 00:24:23,939
what we're doing here is specifying

382
00:24:23,940 --> 00:24:29,720
run the "env" command, that is for pretty much every
system, there are some exceptions, but like for

383
00:24:29,720 --> 00:24:31,550
pretty much every system it's is in

384
00:24:31,549 --> 00:24:33,619
"usr/bin", where a lot of binaries live,

385
00:24:33,619 --> 00:24:36,199
and then we're calling it with the

386
00:24:36,200 --> 00:24:38,570
argument "python". And then that will make

387
00:24:38,569 --> 00:24:42,019
use of the path environment variable

388
00:24:42,019 --> 00:24:43,579
that we saw in the first lecture. It's

389
00:24:43,579 --> 00:24:45,679
gonna search in that path for the Python

390
00:24:45,680 --> 00:24:48,620
binary and then it's gonna use that to

391
00:24:48,619 --> 00:24:50,479
interpret this file. And that will make

392
00:24:50,480 --> 00:24:52,490
this more portable so it can be run in

393
00:24:52,490 --> 00:24:57,520
my machine, and your machine
and some other machine.

394
00:25:08,019 --> 00:25:12,139
Another thing is that the bash is not

395
00:25:12,140 --> 00:25:14,300
really like modern, it was

396
00:25:14,299 --> 00:25:16,339
developed a while ago. And sometimes

397
00:25:16,339 --> 00:25:18,889
it can be tricky to debug. By

398
00:25:18,890 --> 00:25:21,980
default, and the ways it will fail

399
00:25:21,980 --> 00:25:24,020
sometimes are intuitive like the way we

400
00:25:24,019 --> 00:25:26,179
saw before of like foo command not

401
00:25:26,180 --> 00:25:28,610
existing, sometimes it's not. So there's

402
00:25:28,609 --> 00:25:31,279
like a really nifty tool that we have

403
00:25:31,279 --> 00:25:34,309
linked in the lecture notes, which is called

404
00:25:34,309 --> 00:25:37,579
"shellcheck", that will kind of give you

405
00:25:37,579 --> 00:25:40,009
both warnings and syntactic errors

406
00:25:40,009 --> 00:25:43,249
and other things that you might
not have quoted properly,

407
00:25:43,250 --> 00:25:46,040
or you might have misplaced spaces in

408
00:25:46,039 --> 00:25:50,059
your files. So for example for
extremely simple "mcd.sh"

409
00:25:50,059 --> 00:25:51,979
file we're getting a couple

410
00:25:51,980 --> 00:25:54,800
of errors saying hey, surprisingly,

411
00:25:54,799 --> 00:25:56,089
we're missing a shebang, like this

412
00:25:56,089 --> 00:25:59,059
might not interpret it correctly if you're

413
00:25:59,059 --> 00:26:01,999
it at a different system. Also, this

414
00:26:02,000 --> 00:26:05,620
CD is taking a command and it might not

415
00:26:05,619 --> 00:26:08,959
expand properly so instead of using CD

416
00:26:08,960 --> 00:26:11,300
you might want to use something like CD

417
00:26:11,299 --> 00:26:14,539
and then an OR and then an "exit". We go

418
00:26:14,539 --> 00:26:16,489
back to what we explained earlier, what

419
00:26:16,490 --> 00:26:18,920
this will do is like if the

420
00:26:18,920 --> 00:26:21,860
CD doesn't end correctly, you cannot CD

421
00:26:21,859 --> 00:26:23,719
into the folder because either you

422
00:26:23,720 --> 00:26:25,250
don't have permissions, it doesn't exist...

423
00:26:25,250 --> 00:26:28,779
That will give a nonzero error

424
00:26:28,779 --> 00:26:32,419
command, so you will execute exit

425
00:26:32,420 --> 00:26:33,920
and that will stop the script

426
00:26:33,920 --> 00:26:35,810
instead of continue executing as if

427
00:26:35,809 --> 00:26:37,239
you were in a place that you are

428
00:26:37,240 --> 00:26:42,900
actually not in. And actually
I haven't tested, but I

429
00:26:42,920 --> 00:26:47,179
think we can check for "example.sh"

430
00:26:47,179 --> 00:26:50,809
and here we're getting that we should be

431
00:26:50,808 --> 00:26:55,069
checking the exit code in a
different way, because it's

432
00:26:55,069 --> 00:26:57,709
probably not the best way, doing it this

433
00:26:57,710 --> 00:27:01,580
way. One last remark I want to make

434
00:27:01,579 --> 00:27:05,089
is that when you're writing bash scripts

435
00:27:05,089 --> 00:27:07,158
or functions for that matter,

436
00:27:07,159 --> 00:27:09,080
there's kind of a difference between

437
00:27:09,079 --> 00:27:12,589
writing bash scripts in isolation like a

438
00:27:12,589 --> 00:27:14,148
thing that you're gonna run, and a thing

439
00:27:14,148 --> 00:27:16,099
that you're gonna load into your shell.

440
00:27:16,099 --> 00:27:19,849
We will see some of this in the command

441
00:27:19,849 --> 00:27:23,089
line environment lecture, where we will kind of

442
00:27:23,089 --> 00:27:29,058
be tooling with the bashrc and the
sshrc. But in general, if you make

443
00:27:29,058 --> 00:27:31,369
changes to for example where you are,

444
00:27:31,369 --> 00:27:34,008
like if you CD into a bash script and you

445
00:27:34,009 --> 00:27:36,919
just execute that bash script, it won't CD

446
00:27:36,919 --> 00:27:39,980
into the shell are right now. But if you

447
00:27:39,980 --> 00:27:42,980
have loaded the code directly into

448
00:27:42,980 --> 00:27:45,559
your shell, for example you load...

449
00:27:45,558 --> 00:27:48,439
you source the function and then you execute

450
00:27:48,440 --> 00:27:50,269
the function then you will get those

451
00:27:50,269 --> 00:27:52,000
side effects. And the same goes for

452
00:27:52,000 --> 00:27:57,219
defining variables into the shell.

453
00:27:57,220 --> 00:28:03,950
Now I'm going to talk about some
tools that I think are nifty when

454
00:28:03,950 --> 00:28:07,580
working with the shell. The first was

455
00:28:07,579 --> 00:28:09,798
also briefly introduced yesterday.

456
00:28:09,798 --> 00:28:13,308
How do you know what flags, or like

457
00:28:13,308 --> 00:28:15,319
what exact commands are. Like how I am

458
00:28:15,319 --> 00:28:21,888
supposed to know that LS minus L will list
the files in a list format, or that

459
00:28:21,888 --> 00:28:25,788
if I do "move - i", it's gonna like prom me

460
00:28:25,788 --> 00:28:28,638
for stuff. For that what you have is the "man"

461
00:28:28,638 --> 00:28:30,729
command. And the man command will kind of

462
00:28:30,730 --> 00:28:33,590
have like a lot of information of how

463
00:28:33,589 --> 00:28:35,808
will you go about... so for example here it

464
00:28:35,808 --> 00:28:40,339
will explain for the "-i" flag, there are

465
00:28:40,339 --> 00:28:43,969
all these options you can do. That's

466
00:28:43,970 --> 00:28:45,620
actually pretty useful and it will work

467
00:28:45,619 --> 00:28:51,539
not only for really simple commands
that come packaged with your OS

468
00:28:51,539 --> 00:28:55,808
but will also work with some tools
that you install from the internet

469
00:28:55,808 --> 00:28:58,239
for example, if the person that did the

470
00:28:58,240 --> 00:29:01,390
installation made it so that the man

471
00:29:01,390 --> 00:29:03,399
package were also installed. So for example

472
00:29:03,398 --> 00:29:06,489
a tool that we're gonna cover in a bit

473
00:29:06,490 --> 00:29:12,370
which is called "ripgrep" and
is called with RG, this didn't

474
00:29:12,369 --> 00:29:14,979
come with my system but it has installed

475
00:29:14,980 --> 00:29:17,230
its own man page and I have it here and

476
00:29:17,230 --> 00:29:21,700
I can access it. For some commands the

477
00:29:21,700 --> 00:29:25,029
man page is useful but sometimes it can be

478
00:29:25,028 --> 00:29:28,269
tricky to decipher because it's more

479
00:29:28,269 --> 00:29:30,398
kind of a documentation and a

480
00:29:30,398 --> 00:29:32,678
description of all the things the tool

481
00:29:32,679 --> 00:29:35,860
can do. Sometimes it will have

482
00:29:35,859 --> 00:29:37,719
examples but sometimes not, and sometimes

483
00:29:37,720 --> 00:29:41,620
the tool can do a lot of things so a

484
00:29:41,619 --> 00:29:45,249
couple of good tools that I use commonly

485
00:29:45,250 --> 00:29:50,288
are "convert" or "ffmpeg", which deal
with images and video respectively and

486
00:29:50,288 --> 00:29:52,418
the man pages are like enormous. So there's

487
00:29:52,419 --> 00:29:54,850
one neat tool called "tldr" that

488
00:29:54,849 --> 00:29:58,239
you can install and you will have like

489
00:29:58,240 --> 00:30:02,710
some nice kind of explanatory examples

490
00:30:02,710 --> 00:30:05,470
of how you want to use this command. And you

491
00:30:05,470 --> 00:30:07,840
can always Google for this, but I find

492
00:30:07,839 --> 00:30:10,119
myself saving going into the

493
00:30:10,119 --> 00:30:12,639
browser, looking about some examples and

494
00:30:12,640 --> 00:30:14,919
coming back, whereas "tldr" are

495
00:30:14,919 --> 00:30:16,870
community contributed and

496
00:30:16,869 --> 00:30:19,209
they're fairly useful. Then,

497
00:30:19,210 --> 00:30:23,020
the one for "ffmpeg" has a lot of

498
00:30:23,019 --> 00:30:24,939
useful examples that are more nicely

499
00:30:24,940 --> 00:30:26,799
formatted (if you don't have a huge

500
00:30:26,798 --> 00:30:30,819
font size for recording). Or even

501
00:30:30,819 --> 00:30:33,249
simple commands like "tar", that have a lot

502
00:30:33,250 --> 00:30:35,470
of options that you are combining. So for

503
00:30:35,470 --> 00:30:37,840
example, here you can be combining 2, 3...

504
00:30:37,839 --> 00:30:41,709
different flags and it can not be

505
00:30:41,710 --> 00:30:43,419
obvious, when you want to combine

506
00:30:43,419 --> 00:30:48,429
different ones. That's how you

507
00:30:48,429 --> 00:30:54,850
would go about finding more about these tools.
On the topic of finding, let's try

508
00:30:54,849 --> 00:30:58,689
learning how to find files. You can

509
00:30:58,690 --> 00:31:03,100
always go "ls", and like you can go like

510
00:31:03,099 --> 00:31:05,949
"ls project1", and

511
00:31:05,950 --> 00:31:08,559
keep LS'ing all the way through. But

512
00:31:08,558 --> 00:31:11,739
maybe, if we already know that we want

513
00:31:11,740 --> 00:31:15,450
to look for all the folders called

514
00:31:15,450 --> 00:31:19,000
"src", then there's probably a better command

515
00:31:19,000 --> 00:31:21,399
for doing that. And that's "find".

516
00:31:21,460 --> 00:31:26,679
Find is the tool that, pretty much comes
with every UNIX system. And find,

517
00:31:26,679 --> 00:31:35,230
we're gonna give it... here we're
saying we want to call find in the

518
00:31:35,230 --> 00:31:37,510
current folder, remember that "." stands

519
00:31:37,509 --> 00:31:40,148
for the current folder, and we want the

520
00:31:40,148 --> 00:31:46,538
name to be "src" and we want the type to
be a directory. And by typing that it's

521
00:31:46,538 --> 00:31:49,869
gonna recursively go through the current

522
00:31:49,869 --> 00:31:52,329
directory and look for all these files,

523
00:31:52,329 --> 00:31:58,658
or folders in this case, that match this
pattern. Find has a lot of useful

524
00:31:58,659 --> 00:32:01,840
flags. So for example, you can even test

525
00:32:01,839 --> 00:32:05,439
for the path to be in a way. Here we're

526
00:32:05,440 --> 00:32:08,230
saying we want some number of folders,

527
00:32:08,230 --> 00:32:09,909
we don't really care how many folders,

528
00:32:09,909 --> 00:32:13,179
and then we care about all the Python

529
00:32:13,179 --> 00:32:17,830
scripts, all the things with the extension
".py", that are within a

530
00:32:17,829 --> 00:32:19,898
test folder. And we're also checking, just in

531
00:32:19,898 --> 00:32:21,518
cases really but we're checking just

532
00:32:21,519 --> 00:32:24,460
that it's also a type F, which stands for

533
00:32:24,460 --> 00:32:28,710
file. We're getting all these files.

534
00:32:28,710 --> 00:32:32,169
You can also use different flags for things

535
00:32:32,169 --> 00:32:34,000
that are not the path or the name.

536
00:32:34,000 --> 00:32:38,160
You could check things that have been

537
00:32:38,160 --> 00:32:42,060
modified ("-mtime" is for the modification
time), things that have been

538
00:32:42,069 --> 00:32:44,539
modified in the last day, which is gonna

539
00:32:44,558 --> 00:32:46,658
be pretty much everything. So this is gonna print

540
00:32:46,659 --> 00:32:49,029
a lot of the files we created and files

541
00:32:49,028 --> 00:32:51,849
that were already there. You can even

542
00:32:51,849 --> 00:32:54,959
use other things like size, the owner,

543
00:32:54,960 --> 00:32:59,080
permissions, you name it. What is even more

544
00:32:59,079 --> 00:33:01,869
powerful is, "find" can find stuff

545
00:33:01,869 --> 00:33:04,268
but it also can do stuff when you

546
00:33:04,269 --> 00:33:10,690
find those files. So we could look for all

547
00:33:10,690 --> 00:33:14,080
the files that have a TMP

548
00:33:14,079 --> 00:33:18,159
extension, which is a temporary extension, and

549
00:33:18,160 --> 00:33:22,720
then, we can tell "find" that
for every one of those files,

550
00:33:22,720 --> 00:33:26,350
just execute the "rm" command for them. And

551
00:33:26,349 --> 00:33:29,049
that will just be calling "rm" with all

552
00:33:29,049 --> 00:33:32,349
these files. So let's first execute it

553
00:33:32,349 --> 00:33:35,759
without, and then we execute it with it.

554
00:33:35,759 --> 00:33:38,949
Again, as with the command line

555
00:33:38,950 --> 00:33:41,470
philosophy, it looks like nothing

556
00:33:41,470 --> 00:33:48,070
happened. But since we have
a zero error code, something

557
00:33:48,069 --> 00:33:49,539
happened - just that everything went

558
00:33:49,539 --> 00:33:51,489
correct and everything is fine. And now,

559
00:33:51,490 --> 00:33:57,810
if we look for these files,
they aren't there anymore.

560
00:33:57,809 --> 00:34:02,949
Another nice thing about the shell
in general is that there are

561
00:34:02,950 --> 00:34:05,890
these tools, but people will keep

562
00:34:05,890 --> 00:34:08,230
finding new ways, so alternative

563
00:34:08,230 --> 00:34:12,220
ways of writing these tools. It's
nice to know about it. So, for

564
00:34:12,219 --> 00:34:20,019
example find if you just want to match
the things that end in "tmp"

565
00:34:20,019 --> 00:34:24,189
it can be sometimes weird to do this
thing, it has a long command.

566
00:34:24,190 --> 00:34:27,760
There's things like "fd",

567
00:34:27,760 --> 00:34:32,320
for example, that is a shorter command
that by default will use regex

568
00:34:32,320 --> 00:34:34,899
and will ignore your gitfiles, so you

569
00:34:34,898 --> 00:34:38,019
don't even search for them. It

570
00:34:38,019 --> 00:34:42,878
will color-code, it will have better
Unicode support... It's nice to

571
00:34:42,878 --> 00:34:45,039
know about some of these tools. But, again,

572
00:34:45,039 --> 00:34:52,148
the main idea is that if you are aware
that these tools exist, you can

573
00:34:52,148 --> 00:34:53,739
save yourself a lot of time from doing

574
00:34:53,739 --> 00:34:57,659
kind of menial and repetitive tasks.

575
00:34:57,659 --> 00:35:00,009
Another command to bear in mind is like

576
00:35:00,010 --> 00:35:01,990
"find". Some of you may be

577
00:35:01,989 --> 00:35:04,299
wondering, "find" is probably just

578
00:35:04,300 --> 00:35:06,520
actually going through a directory

579
00:35:06,519 --> 00:35:09,579
structure and looking for things but

580
00:35:09,579 --> 00:35:11,259
what if I'm doing a lot of "finds" a day?

581
00:35:11,260 --> 00:35:12,850
Wouldn't it be better, doing kind of

582
00:35:12,849 --> 00:35:18,789
a database approach and build an index
first, and then use that index

583
00:35:18,789 --> 00:35:21,519
and update it in some way. Well, actually

584
00:35:21,519 --> 00:35:23,379
most Unix systems already do it and

585
00:35:23,380 --> 00:35:28,170
this is through the "locate" command and

586
00:35:28,170 --> 00:35:31,690
the way that the locate will

587
00:35:31,690 --> 00:35:35,470
be used... it will just look for paths in

588
00:35:35,469 --> 00:35:38,679
your file system that have the substring

589
00:35:38,679 --> 00:35:44,709
that you want. I actually don't know if it
will work... Okay, it worked. Let me try to

590
00:35:44,710 --> 00:35:49,840
do something like "missing-semester".

591
00:35:51,840 --> 00:35:53,950
You're gonna take a while but

592
00:35:53,949 --> 00:35:56,108
it found all these files that are somewhere

593
00:35:56,108 --> 00:35:57,729
in my file system and since it has

594
00:35:57,730 --> 00:36:01,750
built an index already on them, it's much

595
00:36:01,750 --> 00:36:05,680
faster. And then, to keep it updated,

596
00:36:05,679 --> 00:36:11,979
using the "updatedb" command
that is running through cron,

597
00:36:13,840 --> 00:36:18,490
to update this database. Finding files, again, is

598
00:36:18,489 --> 00:36:23,229
really useful. Sometimes you're actually concerned
about, not the files themselves,

599
00:36:23,230 --> 00:36:26,740
but the content of the files. For that

600
00:36:26,739 --> 00:36:31,419
you can use the grep command that we

601
00:36:31,420 --> 00:36:33,880
have seen so far. So you could do

602
00:36:33,880 --> 00:36:37,740
something like grep foobar in MCD, it's there.

603
00:36:37,739 --> 00:36:43,689
What if you want to, again, recursively
search through the current

604
00:36:43,690 --> 00:36:45,760
structure and look for more files, right?

605
00:36:45,760 --> 00:36:48,700
We don't want to do this manually.

606
00:36:48,699 --> 00:36:51,219
We could use "find", and the "-exec", but

607
00:36:51,219 --> 00:36:58,919
actually "grep" has the "-R" flag
that will go through the entire

608
00:36:58,920 --> 00:37:03,609
directory, here. And it's telling us

609
00:37:03,608 --> 00:37:06,578
that oh we have the foobar line in example.sh

610
00:37:06,579 --> 00:37:09,279
at these three places and in

611
00:37:09,278 --> 00:37:14,588
this other two places in foobar. This can be

612
00:37:14,588 --> 00:37:16,899
really convenient. Mainly, the

613
00:37:16,900 --> 00:37:18,940
use case for this is you know you have

614
00:37:18,940 --> 00:37:21,910
written some code in some programming

615
00:37:21,909 --> 00:37:23,858
language, and you know it's somewhere in

616
00:37:23,858 --> 00:37:26,199
your file system but you actually don't

617
00:37:26,199 --> 00:37:28,598
know. But you can actually quickly search.

618
00:37:28,599 --> 00:37:32,979
So for example, I can quickly search

619
00:37:35,659 --> 00:37:40,319
for all the Python files that I have in my

620
00:37:40,329 --> 00:37:45,460
scratch folder where I used the request library.

621
00:37:45,460 --> 00:37:47,589
And if I run this, it's giving me

622
00:37:47,588 --> 00:37:50,889
through all these files, exactly in

623
00:37:50,889 --> 00:37:53,649
what line it has been found. And here

624
00:37:53,650 --> 00:37:56,260
instead of using grep, which is fine,

625
00:37:56,260 --> 00:37:58,930
you could also do this, I'm using "ripgrep",

626
00:37:58,929 --> 00:38:05,259
which is kind of the same idea but
again trying to bring some more

627
00:38:05,260 --> 00:38:09,730
niceties like color coding or file

628
00:38:09,730 --> 00:38:16,480
processing and other things. It think it has,
also, unicode support. It's also pretty

629
00:38:16,480 --> 00:38:22,829
fast so you are not paying like a
trade-off on this being slower and

630
00:38:22,829 --> 00:38:25,420
there's a lot of useful flags. You

631
00:38:25,420 --> 00:38:27,670
can say, oh, I actually want to get some

632
00:38:27,670 --> 00:38:30,460
context around those results.

633
00:38:33,039 --> 00:38:36,399
So I want to get like five
lines of context around

634
00:38:36,400 --> 00:38:42,819
that, so you can see where that import
lives and see code around it.

635
00:38:42,818 --> 00:38:44,169
Here in the import it's not really useful

636
00:38:44,170 --> 00:38:45,819
but like if you're looking for where you

637
00:38:45,818 --> 00:38:49,719
use the function, for example, it will

638
00:38:49,719 --> 00:38:54,009
be very handy. We can also do things like

639
00:38:54,010 --> 00:38:59,170
we can search, for example here,.

640
00:38:59,170 --> 00:39:04,839
A more advanced use, we can say,

641
00:39:04,840 --> 00:39:11,580
"-u" is for don't ignore hidden files, sometimes

642
00:39:12,519 --> 00:39:16,358
you want to be ignoring hidden
files, except if you want to

643
00:39:16,358 --> 00:39:23,499
search config files, that are by default
hidden. Then, instead of printing

644
00:39:23,500 --> 00:39:28,400
the matches, we're asking to do something
that would be kind of hard, I think,

645
00:39:28,400 --> 00:39:31,380
to do with grep, out of my head, which is

646
00:39:31,389 --> 00:39:34,568
"I want you to print all the files that

647
00:39:34,568 --> 00:39:37,749
don't match the pattern I'm giving you", which

648
00:39:37,750 --> 00:39:40,029
may be a weird thing to ask here but

649
00:39:40,030 --> 00:39:42,940
then we keep going... And this pattern here

650
00:39:42,940 --> 00:39:45,790
is a small regex which is saying

651
00:39:45,789 --> 00:39:48,098
at the beginning of the line I have a

652
00:39:48,099 --> 00:39:51,190
"#" and a "!", and that's a shebang.

653
00:39:51,190 --> 00:39:53,470
Like that, we're searching here for all

654
00:39:53,469 --> 00:39:56,649
the files that don't have a shebang

655
00:39:56,650 --> 00:39:59,369
and then we're giving it, here,

656
00:39:59,369 --> 00:40:02,470
a "-t sh" to only look for "sh"

657
00:40:02,469 --> 00:40:07,659
files, because maybe all your
Python or text files are fine

658
00:40:07,659 --> 00:40:09,999
without a shebang. And here it's telling us

659
00:40:10,000 --> 00:40:13,020
"oh, MCD is obviously missing a shebang"

660
00:40:14,760 --> 00:40:16,660
We can even... It has like some

661
00:40:16,659 --> 00:40:19,118
nice flags, so for example if we

662
00:40:19,119 --> 00:40:21,359
include the "stats" flag

663
00:40:28,699 --> 00:40:34,118
it will get all these results but it will
also tell us information about all

664
00:40:34,119 --> 00:40:35,410
the things that it searched. For example,

665
00:40:35,409 --> 00:40:40,389
the number of matches that it found,
the lines, the file searched,

666
00:40:40,389 --> 00:40:44,039
the bytes that it printed, &amp;c.

667
00:40:44,039 --> 00:40:47,159
Similar as with "fd", sometimes
it's not as useful

668
00:40:48,400 --> 00:40:50,619
using one specific tool or another and

669
00:40:50,619 --> 00:40:55,779
in fact, as ripgrep, there are several
other tools. Like "ack",

670
00:40:55,780 --> 00:40:57,700
is the original grep alternative that was

671
00:40:57,699 --> 00:41:00,669
written. Then the silver searcher,

672
00:41:00,670 --> 00:41:04,089
"ag", was another one... and they're all

673
00:41:04,088 --> 00:41:05,588
pretty much interchangeable so

674
00:41:05,588 --> 00:41:07,629
maybe you're at a system that has one and

675
00:41:07,630 --> 00:41:09,670
not the other, just knowing that you can

676
00:41:09,670 --> 00:41:12,040
use these things with these tools can be

677
00:41:12,039 --> 00:41:15,548
fairly useful. Lastly, I want to cover

678
00:41:15,548 --> 00:41:19,779
how you go about, not finding files
or code, but how you go about

679
00:41:19,780 --> 00:41:22,540
finding commands that you already

680
00:41:22,539 --> 00:41:30,159
some time figured out. The first, obvious
way is just using the up arrow,

681
00:41:30,159 --> 00:41:34,539
and slowly going through all your history,
looking for these matches.

682
00:41:34,539 --> 00:41:36,489
This is actually not very efficient, as

683
00:41:36,489 --> 00:41:42,578
you probably guessed. So the bash
has ways to do this more easily.

684
00:41:42,579 --> 00:41:44,619
There is the "history" command, that will

685
00:41:44,619 --> 00:41:49,180
print your history. Here I'm in zsh and
it only prints some of my history, but

686
00:41:49,179 --> 00:41:54,068
if I say, I want you to print everything
from the beginning of time, it will print

687
00:41:54,068 --> 00:41:58,219
everything from the beginning
of whatever this history is.

688
00:41:58,219 --> 00:42:00,699
And since this is a lot of results,

689
00:42:00,699 --> 00:42:02,588
maybe we care about the ones where we

690
00:42:02,588 --> 00:42:08,489
use the "convert" command to go from some
type of file to some other type of file.

691
00:42:08,489 --> 00:42:12,939
Some image, sorry. Then, we're getting all

692
00:42:12,940 --> 00:42:15,849
these results here, about all the ones

693
00:42:15,849 --> 00:42:18,120
that match this substring.

694
00:42:21,280 --> 00:42:24,609
Even more, pretty much all shells by default will

695
00:42:24,608 --> 00:42:27,129
link "Ctrl+R", the keybinding,

696
00:42:27,130 --> 00:42:29,680
to do backward search. Here we

697
00:42:29,679 --> 00:42:31,568
have backward search, where we can

698
00:42:31,568 --> 00:42:34,749
type "convert" and it's finding the

699
00:42:34,750 --> 00:42:36,608
command that we just typed. And if we just

700
00:42:36,608 --> 00:42:38,618
keep hitting "Ctrl+R", it will

701
00:42:38,619 --> 00:42:41,740
kind of go through these matches and

702
00:42:41,739 --> 00:42:44,259
it will let re-execute it

703
00:42:44,260 --> 00:42:49,240
in place. Another thing that you can do,

704
00:42:49,239 --> 00:42:51,068
related to that, is you can use this

705
00:42:51,068 --> 00:42:53,828
really nifty tool called "fzf", which is

706
00:42:53,829 --> 00:42:56,280
like a fuzzy finder, like it will...

707
00:42:57,099 --> 00:42:58,479
It will let you do kind of

708
00:42:58,480 --> 00:43:02,200
like an interactive grep. We could do

709
00:43:02,199 --> 00:43:06,368
for example this, where we can cat our

710
00:43:06,369 --> 00:43:10,030
example.sh command, that will print

711
00:43:10,030 --> 00:43:11,680
print to the standard output, and then we

712
00:43:11,679 --> 00:43:14,289
can pipe it through fzf. It's just getting

713
00:43:14,289 --> 00:43:18,489
all the lines and then we can
interactively look for the

714
00:43:18,489 --> 00:43:21,848
string that we care about. And the nice

715
00:43:21,849 --> 00:43:26,349
thing about fzf is that, if you enable
the default bindings, it will bind to

716
00:43:26,349 --> 00:43:33,670
your "Ctrl+R" shell execution and now

717
00:43:33,670 --> 00:43:36,490
you can quickly and dynamically like

718
00:43:36,489 --> 00:43:41,699
look for all the times you try to
convert a favicon in your history.

719
00:43:42,019 --> 00:43:46,374
And it's also like fuzzy matching,
whereas like by default in grep

720
00:43:46,375 --> 00:43:49,419
or these things you have to write a regex or some

721
00:43:49,420 --> 00:43:52,360
expression that will match within here.

722
00:43:52,360 --> 00:43:54,609
Here I'm just typing "convert" and "favicon" and

723
00:43:54,608 --> 00:43:57,368
it's just trying to do the best scan,

724
00:43:57,369 --> 00:44:01,349
doing the match in the lines it has.

725
00:44:01,349 --> 00:44:06,190
Lastly, a tool that probably you have
already seen, that I've been using

726
00:44:06,190 --> 00:44:08,410
for not retyping these extremely long

727
00:44:08,409 --> 00:44:13,079
commands is this "history
substring search", where

728
00:44:13,940 --> 00:44:15,660
as I type in my shell,

729
00:44:15,670 --> 00:44:19,630
and both F fail to mention but both face

730
00:44:19,630 --> 00:44:22,760
which I think was originally introduced,
this concept, and then

731
00:44:22,760 --> 00:44:25,760
zsh has a really nice implementation)

732
00:44:25,760 --> 00:44:26,800
what it'll let you do is

733
00:44:26,800 --> 00:44:31,300
as you type the command, it will
dynamically search back in your

734
00:44:31,300 --> 00:44:34,420
history to the same command
that has a common prefix,

735
00:44:34,980 --> 00:44:36,900
and then, if you...

736
00:44:39,099 --> 00:44:42,099
it will change as the match list stops

737
00:44:42,099 --> 00:44:44,109
working and then as you do the

738
00:44:44,119 --> 00:44:49,759
right arrow you can select that
command and then re-execute it.

739
00:45:05,800 --> 00:45:09,920
We've seen a bunch of stuff... I think I have

740
00:45:09,940 --> 00:45:16,180
a few minutes left so I'm going
to cover a couple of tools to do

741
00:45:16,179 --> 00:45:20,059
really quick directory listing
and directory navigation.

742
00:45:20,059 --> 00:45:30,019
So you can always use the "-R" to recursively
list some directory structure,

743
00:45:30,019 --> 00:45:35,159
but that can be suboptimal, I cannot
really make sense of this easily.

744
00:45:36,340 --> 00:45:44,460
There's tool called "tree" that will
be the much more friendly form of

745
00:45:44,460 --> 00:45:47,500
printing all the stuff, it will
also color code based on...

746
00:45:47,500 --> 00:45:50,680
here for example "foo" is blue
because it's a directory and

747
00:45:50,679 --> 00:45:55,099
this is red because it has execute permissions.

748
00:45:55,099 --> 00:46:00,219
But we can go even further than
that. There's really nice tools

749
00:46:00,219 --> 00:46:04,579
like a recent one called "broot" that
will do the same thing but here

750
00:46:04,579 --> 00:46:07,299
for example instead of doing
this thing of listing

751
00:46:07,300 --> 00:46:09,160
every single file, for example in bar

752
00:46:09,159 --> 00:46:11,399
we have these "a" through "j" files,

753
00:46:11,400 --> 00:46:14,260
it will say "oh there are more, unlisted here".

754
00:46:15,079 --> 00:46:18,199
I can actually start typing and it will again

755
00:46:18,199 --> 00:46:21,539
again facily match to the files that are there

756
00:46:21,539 --> 00:46:24,799
and I can quickly select them
and navigate through them.

757
00:46:24,800 --> 00:46:28,380
So, again, it's good to know that

758
00:46:28,380 --> 00:46:33,340
these things exist so you don't
lose a large amount of time

759
00:46:34,239 --> 00:46:36,179
going for these files.

760
00:46:37,880 --> 00:46:40,500
There are also, I think I have it installed

761
00:46:40,500 --> 00:46:44,828
also something more similar to what
you would expect your OS to have,

762
00:46:44,829 --> 00:46:49,960
like Nautilus or one of the Mac
finders that have like an

763
00:46:49,960 --> 00:46:59,260
interactive input where you can just use your
navigation arrows and quickly explore.

764
00:46:59,260 --> 00:47:03,849
It might be overkill but you'll
be surprised how quickly you can

765
00:47:03,849 --> 00:47:07,839
make sense of some directory structure
by just navigating through it.

766
00:47:07,840 --> 00:47:12,780
And pretty much all of these tools
will let you edit, copy files...

767
00:47:12,780 --> 00:47:16,880
if you just look for the options for them.

768
00:47:17,599 --> 00:47:20,099
The last addendum is kind of going places.

769
00:47:20,099 --> 00:47:24,479
We have "cd", and "cd" is nice, it will get you

770
00:47:26,119 --> 00:47:30,059
to a lot of places. But it's pretty handy if

771
00:47:30,068 --> 00:47:33,189
you can like quickly go places,

772
00:47:33,190 --> 00:47:36,730
either you have been to recently or that

773
00:47:36,730 --> 00:47:40,599
you go frequently. And you can do this in

774
00:47:40,599 --> 00:47:42,520
many ways there's probably... you can start

775
00:47:42,519 --> 00:47:44,318
thinking, oh I can make bookmarks, I can

776
00:47:44,318 --> 00:47:46,659
make... I can make aliases in the shell,

777
00:47:46,659 --> 00:47:49,019
that we will cover at some point,

778
00:47:49,019 --> 00:47:53,019
symlinks... But at this point,

779
00:47:53,019 --> 00:47:54,909
programmers have like built all these

780
00:47:54,909 --> 00:47:56,798
tools, so programmers have already figured

781
00:47:56,798 --> 00:47:59,519
out a really nice way of doing this.

782
00:47:59,519 --> 00:48:01,929
One way of doing this is using what is

783
00:48:01,929 --> 00:48:05,759
called "auto jump", which I
think is not loaded here...

784
00:48:14,139 --> 00:48:20,099
Okay, don't worry. I will cover it
in the command line environment.

785
00:48:21,960 --> 00:48:25,579
I think it's because I disabled
the "Ctrl+R" and that also

786
00:48:25,579 --> 00:48:31,309
affected other parts of the script.
I think at this point if anyone has

787
00:48:31,309 --> 00:48:35,480
any questions that are related to this,
I'll be more than happy to answer

788
00:48:35,480 --> 00:48:37,509
them, if anything was left unclear.

789
00:48:37,509 --> 00:48:42,859
Otherwise, a there's a bunch of
exercises that we wrote, kind of

790
00:48:42,858 --> 00:48:46,548
touching on these topics and we
encourage you to try them and

791
00:48:46,548 --> 00:48:48,558
come to office hours, where we can help

792
00:48:48,559 --> 00:48:54,569
you figure out how to do them, or some
bash quirks that are not clear.


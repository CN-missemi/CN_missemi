{12524}{12559}之前我提到了，呃，命令错误什么的
{12560}{12591}昨天我们看过，总体来说……
{12592}{12632}一个进程有许多方式
{12633}{12741}和其他进程或命令交互
{12756}{12825}我们提到了标准输入（流）
{12826}{12863}它就是好比……
{12864}{12909}（程序）从标准输入获取各种东西
{12910}{12945}然后把东西输到标准输出里
{12946}{13016}还有些东西更有意思
{13025}{13141}也有一个标准错误（流）
{13157}{13249}如果你程序出错了
{13250}{13284}你想输出错误却不污染标准输出
{13288}{13322}就可以写进这个流
{13323}{13384}也有错误代码（error code）这种东西
{13393}{13493}而且它普遍存在于很多编程语言
{13494}{13606}是一种告诉你整个运行过程
{13610}{13628}结果如何的方式
{13650}{13714}所以，比如我们试试
{13727}{13792}`echo "Hello"`
{13798}{13903}然后查一下错误代码的值，它是 `0`
{13904}{13968}`0` 是因为一切正常，没有出问题
{13969}{14038}这种 `0` 退出码和它在[*]
{14055}{14153}比如 C 这种语言里，代表的意思一样
{14166}{14245}`0` 就代表所有事情正常，没出错误
{14262}{14317}然而，有时候事情会出错
{14332}{14485}比如有时候，我们尝试在 `mcd` 脚本里
{14486}{14545}`grep foobar` 的话
{14553}{14635}现在查一下值，就是 `1`
{14636}{14732}这是因为我们试着在 `mcd` 脚本里
{14733}{14813}搜索 `foobar` 字符串，而它不存在
{14829}{14927}所以 `grep` 什么都没输出
{14928}{14997}但是通过反馈一个 `1` 的错误代码
{14999}{15058}它让我们知道这件事没成功
{15071}{15137}有一些有意思的命令，比如
{15148}{15314}`true` 的错误代码始终是 `0`
{15315}{15445}`false` 的错误代码则是 `1`
{15466}{15578}还有比如这些逻辑运算符
{15579}{15697}你可以用来做条件判断
{15698}{15772}比如……其实你也有 `if-else`
{15773}{15793}之后我们会说
{15800}{15854}但是现在你可以做一些
{15870}{15967}比如 `false`，然后 `echo "Oops fail"`
{15968}{16088}这里有两个被或运算符链接的命令
{16089}{16218}这里 bash 要做的是，执行第一个命令
{16219}{16378}如果第一个命令失败，再去执行第二个[*]
{16379}{16443}这里我们有这个结果
{16444}{16516}因为它尝试做一个逻辑或
{16517}{16588}如果第一个（命令）没有 `0` 错误码
{16589}{16637}它就会去执行第二个（命令）
{16638}{16747}相似地，如果我们把 `false`
{16748}{16786}替换成比如 `true`
{16787}{16860}因为我们有一个 `0` 错误代码
{16861}{16925}所以第二个（命令）会被短路
{16926}{17002}所以就不会打印
{17184}{17269}相似地，我们有与运算符
{17300}{17364}它仅当第一个命令执行无错误时
{17367}{17440}才会执行第二个部分
{17508}{17551}这里也是同样的事情：
{17554}{17642}如果第一个失败，那么第二个命令
{17643}{17684}就不会被执行
{17752}{17910}虽然不是很相关，但是另一个事情是
{18053}{18139}无论你执行什么，你都可以通过
{18140}{18212}在同一行内使用分号来连接命令
{18213}{18272}它就会始终被打印出来
{18310}{18410}在这之后，我们还没学到的是
{18411}{18590}怎样把命令的输出存到变量里
{18591}{18726}我们可以这样做
{18737}{18896}这里我们获取 `pwd` 命令的输出
{18897}{18977}它会打印出当前工作目录
{18978}{19008}也就是我们在哪里
{19019}{19108}然后把这个存进 `foo` 变量
{19130}{19233}然后现在我们询问 `foo` 的值
{19234}{19272}我们就能看到这个字符串
{19273}{19355}更广泛的说，我们可以做一个叫
{19376}{19454}命令替换的事情
{19501}{19540}通过把它放进任意字符串中
{19541}{19636}而且因为我们用的不是单引号
{19637}{19663}而是双引号
{19664}{19714}所以这串东西会被展开
{19715}{19866}告诉我们，现在位于这个文件夹
{19915}{19967}另一个有趣的事情是
{19987}{20086}这个会展开成一个字符串
{20087}{20099}而不是……
{20100}{20198}呃，它只是展开成一个字符串
{20199}{20294}另一个好用但知名度更低的工具
{20295}{20336}叫做过程替换
{20346}{20423}和之前那个是类似的
{20529}{20571}它会做什么呢……它会
{20608}{20733}比如这里的 `<(` ，接一个命令，再接 `)`
{20734}{20819}它的作用是，内部的命令会被执行
{20820}{20879}其输出将被存储到，大概像一个
{20880}{20950}临时文件内，然后把文件 handle（抓手、句柄）
{20951}{20984}交给（最左面的）命令
{20985}{21077}所以这里我们在……`ls` 这个目录
{21078}{21173}把输出放到临时文件内
{21174}{21239}再对父目录如法炮制
{21240}{21311}然后把两个文件连接
{21312}{21393}而这种写法就非常得劲
{21394}{21431}因为有些命令会从
{21432}{21533}某些文件的内容，而不是标准输入
{21534}{21700}获得输入参数
{21747}{21837}所以我们把这两个命令连起来了
{21991}{22072}感觉讲到现在，讲了真不少东西
{22073}{22154}来看一个里面包含这些内容的
{22155}{22326}简单的示例脚本
{22327}{22409}比如说这里我们有个字符串
{22410}{22483}然后有个 `$(date)`
{22484}{22529}这个 `date` 是个程序
{22530}{22591}重复一下，类 UNIX 系统有很多程序
{22592}{22682}你会慢慢都熟悉它们的
{22683}{22792}`date` 就打印出当前的日期
{22793}{22856}你还可以指定各种打印格式
{22875}{23018}然后这里有这个 `$0`
{23019}{23108}是我们运行的这个脚本的文件名
{23122}{23324}然后是这个 `$#`，代表给定的参数个数
{23325}{23458}然后 `$$` 是这个命令的进程 ID[*]
{23484}{23557}强调，这里有很多 `$`+ 什么什么
{23558}{23596}它们（的含义）并不直观
{23597}{23702}因为你找不到一种巧记的方法
{23703}{23764}`$#` 这种大概就是
{23765}{23813}但是……你一直和它们打照面
{23814}{23832}逐渐就能熟络起来
{23833}{23903}这里还有个 `$@`
{23904}{23979}可以展开成所有参数
{23980}{24096}所以比起来……比如有三个参数
{24097}{24174}那我可以键入 `$1 $2 $3`
{24175}{24247}那如果我们不知道有多少参数
{24248}{24295}这样我们仍然可以把它们放在这
{24296}{24431}然后参数被传给一个 `for` 循环
{24454}{24578}`for` 循环创建一个 `file` 变量
{24579}{24713}这个变量会逐一地获取一个参数
{24751}{24837}这里，对于给出的每一个参数
{24838}{25007}下一行我们运行 `grep` 命令
{25012}{25102}它会在一堆文件里搜索一个子串[*]
{25103}{25181}这里我们在文件里搜索字符串 `foobar`
{25200}{25377}这里我们让 `file` 变量展开为它的值
{25394}{25510}昨天说过，如果我们在意程序输出的话
{25511}{25601}我们可以把它重定向到某处
{25602}{25671}到一个文件里保存下来，或者连接组合
{25693}{25775}嘿，但有时候情况恰恰相反
{25776}{25838}有时候，比如说，我们想知道
{25839}{25918}这个脚本的错误代码是什么
{25919}{26041}我想知道 `grep` 能不能成功查找
{26059}{26196}所以，我们甚至能直接扔掉整个输出
{26197}{26336}包括标准输出和标准错误（流）
{26355}{26385}这里我们做的是
{26386}{26491}把两个输出重定向到 `/dev/null`
{26492}{26613}它是 UNIX 系统的一种特殊设备
{26614}{26715}输出到它的内容会被丢弃
{26718}{26801}就是你可以随意乱写乱画
{26802}{26807}然后所有内容都会被丢掉|就是你可以随意乱写乱画
{26808}{26834}然后所有内容都会被丢掉
{26842}{26945}还有这个 `>` 符号
{26946}{27005}昨天说过，用来重定向输出的
{27014}{27086}这里有个 `2>`
{27096}{27167}有些人也许猜到了
{27168}{27226}它是重定向标准错误流的
{27227}{27307}因为这两个流是分立的
{27308}{27424}所以你得告诉 bash 去操作哪个
{27459}{27497}所以这里我们执行命令
{27498}{27551}去检查文件有没有 `foobar`
{27552}{27683}如果有的话，返回一个 `0` 错误码
{27684}{27769}如果没有，就是一个非 `0` 码
{27782}{27839}我们正是要检查这个
{27857}{27938}这部分命令里
{27939}{28012}我们先告诉它：「给我错误代码」
{28013}{28055}这个是用 `$?`
{28056}{28168}然后是一个比较运算符 `-ne`
{28169}{28194}代表不等于（`N`on `E`qual）
{28233}{28316}其他编程语言里有像
{28328}{28449}`==` 和 `!=` 这种符号
{28467}{28580}bash 里有很多预设的比较运算
{28581}{28706}这主要是为了你用 Shell 的时候
{28707}{28753}有很多东西要去做测试
{28762}{28825} 比如我们现在正在对比两个数
{28826}{28909}两个整数，看它们是否相同
{28910}{29042}又比如，`-f` flag 会让我们知道
{29043}{29100}是否存在一个文件
{29111}{29206}这是你以后会频繁用上的
{29307}{29352}回到例子
{29353}{29648}如果文件中没有 `foobar` 会发生什么
{29649}{29743}像之前有非 `0` 的错误代码
{29744}{29774}我们也输出
{29775}{29809}文件中没有 `foobar` 字符串
{29810}{29911}我们将添加一个，而我们所做的是
{29925}{30001}我们输入 `# foobar`
{30002}{30067}蒙一手这 `#` 是个文件注释格式
{30079}{30253}之后我们用 `>>` 运算符把它添在文件末尾
{30254}{30376}这里尽管文件名已经传给了脚本
{30377}{30407}但我们预先并不知道文件名
{30408}{30509}需要调用记录文件名的变量（获取文件名）
{30553}{30644}我们可以运行这个试试
{30662}{30758}我们已经有这个脚本的正确权限
{30773}{30893}我可以举一些例子，我们在这个夹里有一些文件
{30894}{31003}`mcd` 是我们先前看到的 `mcd` 函数
{31004}{31052}还有其它脚本函数
{31058}{31244}甚至可以把它自己传给它，检查是否有 `foobar`
{31274}{31354}我们运行它，首先我们可以看到
{31355}{31542}我们成功地列出了很多的变量
{31557}{31595}我们有 `date` 命令
{31605}{31690}它成功地被替换成了当前时间
{31698}{31801}接着是这个带着三个参数的程序
{31817}{31924}它的随机的 pid 识别码
{31934}{32015}之后它告诉我们 `mcd` 没有 `foobar` 字符串
{32016}{32076}所以我们新添加了一个
{32077}{32134}并且这个 `script.py` 文件也没有
{32135}{32206}像现在让我们看看 `mcd`
{32207}{32269}它就有我们要找的注释
{32382}{32566}当你在执行脚本时另一个需要知道的是
{32590}{32669}像这里，我们有三个完全不同的参数
{32679}{32716}但通常
{32717}{32887}你会用一些更加简洁的方式输入参数
{32899}{32969}例如这里，
{32985}{33146}如果我想查找所有的 `.sh` 脚本
{33161}{33328}我们只需要键入 `ls *.sh`
{33329}{33487}这是大多数 Shell 都有的一种展开文件名的方式
{33488}{33519}叫做通配
{33520}{33604}这里，如你所想，会显示出
{33605}{33745}所有含有任意字符，且以 `.sh` 为后缀的东西
{33806}{33916}如我们所料，得到了 `example.sh` 和 `mcd.sh`
{33932}{34022}我们也有这些 `project1` 和 `project2`
{34023}{34075}并且如果这里有……
{34095}{34205}比如，我们可以建一个 `project42`
{34224}{34391}现在如果我只想找有一个特定字符的项
{34392}{34423}而不是两个字符
{34424}{34468}然后，像其它任意的字符
{34469}{34624}我们可以使用 `?` 标记，`?` 标记只会展开一个字符
{34659}{34709}我们得到了列出的
{34710}{34806}先是 `project1` 再是 `project2` 
{34830}{35022}总而言之，通配符非常强大，你也可以组合它们
{35185}{35274}一个常用模式是花括号
{35289}{35387}我们在这个文件夹里有一个图片 
{35388}{35507}我们想把图片文件格式由 PNG 转为 JPG
{35530}{35587}我们可能会复制它，或者……
{35588}{35721}这确实是常见情况，有两个或多个挺相似的参数
{35722}{35854}你想把它们当作参数传给命令
{35855}{35963}你可以这样做，但更简洁的做法是
{35964}{36256}你可以只键入 `image.`
{36309}{36382}这里有一些彩色的反馈……
{36383}{36523}总之，它会展开成上面的那行
{36524}{36637}实际上，我可以让 zsh 为我做这些
{36638}{36697}也就是这里正进行的
{36744}{36806}这确实很强大，所以比如
{36807}{36893}你可以做一些像……我们可以……
{36904}{37022}`touch` 一串 `foo`，所有 `foo` 都会被展开
{37091}{37246}你也可以进行多层操作，建立笛卡尔系
{37329}{37366}如果我们有一些像这样的组
{37413}{37506}我们这里有一组 ``
{37507}{37577}之后这里又有 ``
{37578}{37693}这会用使两组展开式形成笛卡尔积
{37694}{37778}而后展开积里的所有表达式
{37826}{37891}我们就可以很快地 `touch` 了
{37911}{38117}你也可以将 `*` 通配符与 `` 通配符结合
{38132}{38215}甚至你可以用一些范围表示
{38219}{38303}像，我们可以键入 `mkdir`
{38304}{38400}我们创建 `foo`，`bar` 目录
{38429}{38554}之后可以在这些行里搞事情
{38564}{38678}这将会展开到 `foo/a`，`foo/b` ……
{38679}{38743}像所有的组合，直到 `j`
{38765}{38895}`bar` 同理，虽然说实话我没试……
{38896}{38993}但是没错，我们得到了我们所能 touch 的所有组合
{39014}{39173}现在，如果我们在两个目录中建一些不同的东西
{39197}{39413}我们可以再次展示……
{39434}{39491}用我们之前看到的流程代替
{39492}{39611}我们想查看这两个文件夹中有什么不同文件
{39612}{39699}非常显然，我们刚刚看到了，是 `x` 和 `y`
{39700}{39800}但是我们可以用 Shell 去比对
{39801}{39883}一个 `ls` 和另一个 `ls` 输出的不同
{39918}{39970}如我们所料，我们得到了
{39971}{40025}`x` 只在第一个文件夹里
{40026}{40135}`y` 只在第二个文件夹里
{40217}{40360}还有，目前我们只看了 bash 脚本
{40361}{40414}如果你喜欢其它的脚本……
{40415}{40504}像 bash 对一些工作可能并不是最好的选择
{40517}{40579}它可能会很棘手。事实上你可以
{40580}{40696}用很多语言写和 Shell 工具交互的脚本
{40713}{40802}例如，我们在这里看一个
{40803}{40915}Python 脚本，它的开头是一个魔法行
{40916}{40978}我暂且不去解释
{40979}{41051}我们有 `import sys`
{41052}{41284}这很像…… Python 默认不会尝试和 Shell 交互
{41285}{41336}所以你需要导入一些库
{41337}{41381}之后我们在做一个
{41382}{41423}确实很傻的事情
{41435}{41525}就只是迭代 `sys.argv[1:]`
{41568}{41672}`sys.argv` 是一种类似于 
{41673}{41762}bash 中 `$0`，`$1` 等等的东西
{41763}{41915}就是一个参数 vector，我们将它倒序输出
{41981}{42071}开始时那神奇的一行叫做 shebang
{42072}{42194}Shell 通过它了解怎么运行这个程序
{42195}{42319}你随时可以键入类似
{42320}{42403}python script.py` 之后是 `a b c`
{42422}{42499}像这样它就会运行
{42500}{42631}但如果我想让它从 Shell 就能执行呢？
{42632}{42805}Shell 是用首行识别到
{42806}{42911}需要用 Python 解释器运行这个程序
{42954}{43000}并且第一行
{43001}{43078}给了这东西所在的路径
{43161}{43205}然而，你可能不知道
{43206}{43251}像不同的设备很可能
{43252}{43334}会把 Python 放在不同的地方
{43335}{43410}最好别假设 Python 装在哪儿
{43412}{43476}其它解释器也是一样
{43565}{43729}所以你可以做的是调用 `env` 命令
{43730}{43848}你也可以在 shebang 中给出参数
{43849}{44002}所以我们现在是在调用 `env` 命令
{44003}{44093}这是对于绝大多数系统而言的，有一些例外
{44094}{44177}但是对于绝大多数系统而言它在 `usr/bin`
{44178}{44220}那儿有很多二进制文件
{44244}{44315}之后用参数 Python 调用它
{44337}{44396}它会使用
{44397}{44521}第一节课提到的 `path` 环境变量
{44522}{44593}`env` 会在那些路径中找 Python 二进制文件
{44594}{44695}接着用它去解释这个脚本
{44696}{44759}这样有更好的可移植性
{44760}{44882}能让它在我的，你的还有其它的设备上运行
{45268}{45425}另一件事是 bash 并不是真正现代化的
{45427}{45485}它好久之前就被开发出来了

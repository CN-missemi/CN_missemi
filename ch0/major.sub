{1}{1}30.000000
{40}{137}好的，感谢大家的到来。
{138}{262}这门课是《计算机科学教育中缺失的一课》[*]
{263}{319}至少这是我们给这门课起的名字
{320}{354}如果你来这儿不是上这门课的
{355}{393}那你走错地儿了
{394}{514}先说一下，我们大约得讲一个小时
{560}{677}我想先和你们谈一下为什么我们开这门课
{678}{870}这门课源于 Anish, Jose 和我在做 MIT 很多课程的 TA[*] 时'
{871}{959}观察到的一个现象：
{960}{1051}基本上，我们这些计算机科学家都清楚
{1052}{1163}计算机很善于处理重复性任务，把事情自动化
{1164}{1266}但是我们常常意识不到有很多工具
{1267}{1358}可以让我们的开发过程更好
{1359}{1438}我们用起电脑来可以更有效率
{1447}{1549}因为我们可以将电脑作为手上的一个利器
{1550}{1674}而不仅仅是用于建个网站或者写个软件这类事情
{1675}{1807}这门课就是试着告诉你这点，并做点儿尝试
{1808}{1887}介绍给你一些这样的工具，你用起来之后
{1888}{2039}可以在你生活、研究和学习上发挥很大的作用
{2058}{2318}在这门课里我们不仅想教你一些你有大致了解的工具
{2319}{2437}还希望教给你一点儿你之前不知道的工具
{2438}{2520}还有如何将这些工具结合起来
{2521}{2678}制造出一些你可能都想象不到的、更强大的东西
{2679}{2747}你们应该知道这门课的结构
{2748}{2831}将是一系列，总共 11 次的一小时课
{2832}{2940}每个都涉及一个特定的主题
{2941}{3029}你还可以去看看课程网站
{3030}{3140}上面列出了课程列表和每场的日期
{3141}{3207}它们大致上将互相独立
{3208}{3296}所以你可以只来听你感兴趣的那些
{3297}{3388}但是，我们会假设你一直在跟着上课
{3389}{3449}所以我们讲到后面的时候，就比如说
{3450}{3543}我就不会一遍遍地教 bash 怎么用了
{3588}{3861}上课的时候，我们也会立马把讲义、课程录像发到网上
{3862}{4016}当然我们现在还没上传，显然得等到上完课之后
{4017}{4185}将由我（Jon），Anish ，他坐在那个位置，还有 Jose 来上课
{4186}{4277}Jose[*] 今天没到场，不过他会上明天的课
{4294}{4391}提醒一下，在这门仅仅 11 × 1 小时的课里
{4392}{4464}我们会试图涉及很大的范围
{4465}{4567}所以我们的节奏相对会快些
{4568}{4714}但是如果你觉得跟不上了，别介意打断我们
{4715}{4791}如果你觉得有什么东西值得多花点时间讲的
{4792}{4821}也请告诉我们
{4822}{4870}有问题也请打断我们
{4871}{5061}并且每次下课之后我们都在 32 号楼 9 层有办公时间
{5062}{5119}是在计算机科学楼，也就是 Stata Center （史塔特科技中心）[*]
{5127}{5252}如果你来 Gates Tower 九楼的休息室 [*]
{5253}{5382}你可以来做做我们每节课后给的练习
{5383}{5514}或者直接问我们别的问题，有关课上讲的内容的
{5515}{5598}或者怎么高效地利用电脑
{5655}{5768}因为我们只有很有限的时间
{5769}{5881}我们不可能讲到所有工具的所有细节
{5882}{6043}只聚焦有趣的工具和怎么使用它们
{6044}{6117}我们也没必要深挖那些细节
{6118}{6202}搞明白它们是怎么运行的，或者使用上的小细节
{6203}{6296}但是如果你对这些有问题，请来问我们
{6297}{6390}讲到的绝大部分工具的是我们用了成年累月的东西
{6391}{6448}我们也许能给告诉你拿这些工具
{6449}{6513}能做什么额外的有趣的活计
{6514}{6590}要利用我们在这儿上实体课的优势
{6621}{6746}我不太想说「让我们开足马力冲吧」
{6747}{6859}但是这门课要讲的，今天这一讲要讲的
{6860}{6917}是很多基础的东西
{6918}{6995}我们也会假设后面的课里你们都了解了这些
{6996}{7066}比如怎么用 Shell 和你的终端（Terminal）
{7067}{7144}对于不熟悉这些的，我马上会解释这些是啥
{7145}{7260}然后我们就会很快速地狂奔到更高级的工具上
{7261}{7287}讲讲怎么用它们
{7288}{7402}现在已经可以从课程讲义上看到所有要讲的主题
{7430}{7579}所以我们今天的课要讲 Shell
{7580}{7730}Shell 将会是你和电脑交互的最主要方式之一
{7731}{7864}一旦你想脱离开那些可视化的界面让你做的
{7865}{7909}然后去做点别的
{7910}{8045}其实可视化界面[*]挺受限的
{8046}{8116}因为它们只让你做一些按钮啊，
{8117}{8169}滑条啊，输入框啊能按出来，输进去的事情
{8170}{8319}但这些基于文本的工具经常是能互相耦合的
{8320}{8424}也有无数种方式能把它们结合起来
{8425}{8467}或者写个程序让它们自动化
{8468}{8574}这就是这门课介绍命令行工具
{8575}{8609}和基于文本的工具的理由
{8619}{8726}Shell 则是你去做这些活计的地方
{8727}{8806}对于不熟悉 Shell 的同学们
{8807}{8888}大多数平台都会提供某种 Shell[*]
{8889}{8964}在 Windows 上基本是 Powershell[*]
{8965}{9039}而且也有其他 Shell 可以用
{9040}{9146}在 Windows 和 Linux 上你会找到成堆的终端（Terminal）
{9147}{9228}这些是能显示 Shell 的（文本）窗口
{9229}{9307}你能找到很多不同种类的 Shell
{9308}{9421}其中最普遍的是 bash，或者叫 born again shell
{9422}{9579}因为它非常普遍，我们这些课里就主要用它了
{9588}{9671}如果你用 MacOS，你大概也有 bash
{9672}{9718}如果你打开终端（Terminal）应用看看
{9719}{9758}也许还是个旧版本的 (‾◡◝)
{9759}{9864}如果你想用哪个平台上课，随意
{9865}{9916}不过注意，在我们教课的时候
{9917}{9996}大部分内容会是以 Linux 为中心
{9997}{10071}尽管大部分工具在所有平台上都能用
{10072}{10240}如果你想安装一个终端和 Shell，却不知道该咋办
{10241}{10318}我们很乐意在办公时间教你
{10319}{10429}或者去网上搜搜也挺容易
{10430}{10533}比如输入你的平台，加上像是终端啊，这种关键词
{10534}{10569}就能找到教程
{10588}{10733}好，当你打开一个终端的时候
{10734}{10805}你会看到一个长得像这样的东西
{10806}{10915}也就是说通常是在顶上有单单一行
{10916}{10982}这个一般就叫「命令行提示符」（Shell Prompt）
{10983}{11049}你可以看到我的命令行提示符看起来像这样
{11050}{11139}这里是我的用户名，还有我用的机器的名字
{11140}{11200}还有我当前所在路径（path）
{11201}{11260}我们晚一会儿再说说路径（path）
{11261}{11380}然后就是这个闪烁的东西，它在要求我输点啥
{11381}{11495}这个就是「命令行提示符」（Shell Prompt），在这里告诉 Shell 你想做什么
{11496}{11606}你可以自由地自定义这个提示符
{11607}{11640}所以当你在你机器上打开它的时候
{11641}{11682}它可能不会长得和这个一样
{11683}{11802}如果你设置了一下，那可能会是这样
{11803}{11874}或者会是各种千奇百怪的样子
{11897}{11996}这节课我们不会讲太多关于自定义 Shell 的东西
{11998}{12043}我们晚些时候再说
{12044}{12154}我们只讲怎么用 Shell 去做有用的事
{12204}{12352}这是你电脑上和 Shell 交互的主要文本界面
{12353}{12424}你可以在命令行提示符上写命令
{12425}{12510}命令相对都是一些直白的东西
{12511}{12635}比如，通常是带着参数（argument）执行程序
{12637}{12668}大概类似这样的事情
{12669}{12755}嗯，有一个我们可以运行的程序是 `date`
{12756}{12798}输入 `date` 然后按一下回车
{12799}{12875}不出所料，它会告诉你日期和时间
{12876}{12967}你也可以带着参数（arguments）执行一个程序
{12968}{13082}这是一种修改程序行为的方式
{13097}{13172}比如说有一个程序叫 `echo`
{13173}{13271}`echo` 只是打印出你传给它的参数
{13272}{13364}而参数呢，则是一些紧随程序名后面的
{13365}{13403}用空格分隔开的东西
{13404}{13520}我们可以打出 `Hello` 然后它就会回显 `Hello`
{13521}{13580}也许你不会觉得很惊奇
{13581}{13647}但这是参数最基础的运用了
{13659}{13711}你会注意到一件事就是
{13712}{13775}我提到参数是被空格分隔的
{13776}{13881}你也许会好奇，如果我想传一个多单词的参数会怎样
{13882}{13919}你可以拿引号把东西括起来
{13920}{14044}所以你可以像这样 `echo Hello` 空格 `world`
{14045}{14108}这样 `echo` 程序会收到一个
{14109}{14224}字符串参数 `"Hello world"`，中间还有个空格
{14243}{14305}呃，你也可以用单引号做这件事情
{14306}{14377}单双引号的区别
{14378}{14456}我们等到讲 bash scripting 的时候再说
{14489}{14556}你也可以用单转义字符（Escape character）
{14569}{14655}比如这样，`Hello\ World`
{14656}{14704}这样也能正常起作用
{14726}{14922}关于如何给参数、变量转义，解析和加括号
{14923}{14979}我们之后会涉及到
{14980}{15068}不过别放在心上，这都是小菜一碟
{15069}{15175}只要记好用空格分隔参数就行
{15176}{15223}因此如果你想做什么事情
{15224}{15287}比如建一个叫 my photos 的目录
{15288}{15385}你不能只是输入 `mkdir my photos`
{15386}{15420}这样系统会建立两个目录
{15421}{15471}一个叫 my，一个叫 photos
{15472}{15508}显然这不是你想要的
{15571}{15684}现在你也许会好奇一点
{15685}{15752}Shell 是怎么知道这些程序在哪儿的
{15753}{15834}当我输入 `date` 或者 `echo` 的时候
{15835}{15945}Shell 怎么知道这些程序要做什么
{15953}{16020}答案就是你的程序，呃
{16021}{16080}就是你的电脑，有很多内置（Built-in）程序
{16081}{16118}它们是系统自带的
{16119}{16239}就比如你的机器可能内嵌了终端程序
{16240}{16411}或者比如 Windows Explorer，或者某些浏览器
{16412}{16507}也内嵌了很多围绕终端工作的程序
{16508}{16587}这些程序位于你的文件系统（File System）
{16588}{16757}而 Shell 有办法知道某个程序存放在哪
{16758}{16827}说白了就是它有一个搜索程序的方法
{16828}{17002}这借助一个叫寒境，啊，环境变量的东西完成
{17003}{17140}环境变量就类似编程语言里的变量
{17141}{17254}说白了 Shell，或者就说 bash 本身
{17255}{17314}就是一种程序设计语言
{17315}{17464}你输入的提示符（Prompt）不仅能带参运行程序
{17465}{17606}你也可以写出 while 循环，for 循环，条件
{17607}{17622}等等所有这些
{17623}{17685}甚至可以定义函数，甚至变量
{17686}{17732}所有这些你能在 Shell 里做的事情
{17733}{17843}关于 Shell Scripting 的下一讲会有涉及
{17879}{17999}现在我们先关注环境变量（Environment Variable）
{18000}{18046}环境变量是 Shell 本就设定好的
{18047}{18136}无论何时启动 Shell 都无须重新设置
{18137}{18188}有一堆东西会被设定好
{18189}{18320}比如哪里是 home 目录，你的用户名是什么
{18321}{18412}也有一个是为了做这件事情的
{18413}{18472}那就是 `PATH` 变量
{18476}{18546}当我输入 `$PATH`
{18547}{18656}这里会输出一些我电脑上的目录
{18657}{18757}这些目录是 Shell 寻找程序时所查找的目录
{18777}{18836}也许你会觉得
{18837}{18963}这一大行被冒号分隔的东西看起来很费眼睛
{18964}{19022}但重要的事情在于
{19023}{19102}当你输入一个程序名称的时候
{19103}{19222}你的电脑会在这个列表中的每个目录里查找
{19223}{19438}名字与你所输入指令相同的一个程序或一个文件
{19463}{19524}刚刚的例子里当我试图运行 `date` 或者 `echo` 的时候
{19525}{19587}电脑会遍历这些目录
{19588}{19685}直到它找到一个包含 `date` 或者 `echo` 的程序的目录
{19686}{19715}然后电脑就会运行找到的这个程序
{19731}{19793}如果我们想要知道电脑具体运行了哪一个目录里的程序
{19794}{19864}我们有一个叫做 `which` 的指令，它可以整这个活
{19865}{19926}所以我现在可以输入 `which echo`
{19927}{19969}然后它就会告诉我
{19970}{20045}如果我要运行一个叫 `echo` 的程序
{20046}{20083}我就会运行——这个东西
{20120}{20214}这里有必要插入讲一下什么是路径（path）
{20227}{20354}路径是用来描述你的计算机里的文件的位置的东西
{20355}{20423}在 Linux 或者 Mac OS 上
{20424}{20529}路径被用一连串的斜杠分隔
{20540}{20690}你在这里可以看到，这个路径的起点在根目录
{20691}{20753}目录的开头有斜杠来指示它开始的地方：
{20754}{20845}整个文件系统的最顶层
{20861}{20967}然后我们进到叫做 `usr` 的目录
{20982}{21047}然后进到叫做 `bin` 的目录
{21048}{21107}然后找到名叫 `echo` 的文件
{21132}{21254}在 Windows 里，这样的路径一般以反斜杠而非斜杠分隔
{21266}{21337}在 Linux 和 MacOS 上
{21338}{21404}所有东西都在一个叫根（root）的空间下面的某处
{21405}{21505}所以所有以斜杠开头的路径都是绝对路径
{21512}{21638}在 Windows 下，每一个分区都有一个根
{21639}{21776}所以你可能见过类似 `C:\` 或者 `D:\` 的东西
{21777}{21927}所以 Windows 里每一个驱动器（硬盘）下
{21928}{21995}都有独立的一套文件系统的层次结构
{21996}{22039}相比之下，在 Linux 和 MacOS 下
{22040}{22099}所有东西都在一个命名空间里
{22145}{22215}你会注意到我提到了“绝对路径”这个词
{22216}{22275}可能有人会不知道这是什么意思，解释一下：
{22276}{22486}绝对路径是可以绝对准确地确定一个文件的位置的路径
{22487}{22523}所以在屏幕上这个例子里面
{22524}{22617}这行东西唯一地指向一个叫 `echo` 的独一无二的文件
{22618}{22714}它表示了到这个文件的完整路径
{22742}{22841}但是也有一种称作“相对路径”的东西
{22851}{22986}“相对路径”是相对于你当前所在位置的路径
{23016}{23106}所以要找出我们当前的位置在哪里
{23107}{23182}我们可以输入 `pwd`，意思是
{23192}{23242}当前工作目录（present working directory）……
{23243}{23260}当前（present）？
{23276}{23307}打印工作目录（print working directory）
{23344}{23386}所以如果我输入 `pwd`
{23387}{23497}它就会输出当前我所在的目录路径
{23515}{23625}我现在的位置是 `root` 下的 `home` 文件夹
{23626}{23699}其中的 `jon` 里，其中的 `dev` 里
{23700}{23737}然后再叭啦叭啦叭啦这一串的里面
{23738}{23886}我可以选择改变我的当前工作目录
{23887}{23992}所有相对路径都是相对当前工作目录的
{23993}{24060}基本上也就是说是相对于你所在的地方
{24082}{24199}举个例子，我可以输入 `cd /home`
{24200}{24253}`cd` 是改变目录（change directory）的意思
{24254}{24345}这是改变当前工作目录的一种方法
{24353}{24410}在这个例子里，我把当前工作目录转到 `home`
{24411}{24522}你可以看到我的 Shell 的提示也改变了
{24523}{24576}它说我在 `home` 里面
{24577}{24668}它只会给出路径的最后一段的名称
{24669}{24782}不过也可以设置下，使得它总能显示当前的完整路径
{24838}{24902}如果现在我再输入 `pwd`
{24903}{24962}它会告诉我我在 `/home` 里
{24984}{25079}同时也有一对特殊的目录
{25085}{25147}`.`（点） 和 `..`（点点）
{25163}{25338}点表示当前目录，而点点表示上一层目录
{25339}{25427}通过这种方式，你可以容易地访问整个系统
{25434}{25527}举个例子，如果我输入 `cd ..`
{25550}{25607}它会告诉我我现在在 `/`
{25617}{25670}所以我现在在整个文件系统的根
{25671}{25745}我刚刚在 `/home`，现在在 `/` 了
{25800}{25894}然后如果我输入 `pwd`，运行结果看起来也很对`
{25929}{26024}我也可以使用相对路径来向下访问文件系统
{26025}{26097}所以我可以输入 `cd ./home`
{26098}{26242}然后就会 cd 到当前的目录下的 `home` 目录
{26284}{26341}这个操作就把我带回到了 `/home` 里
{26342}{26434}然后如果我现在试着再输入一次 `cd ./home`
{26435}{26491}它会告诉我当前目录下没有 `home` 目录
{26492}{26583}我现在在刚刚 cd 进的文件夹里
{26727}{26870}一路 cd 进刚刚我在的那一个文件夹里
{26906}{26964}就可以用相对路径
{26989}{27172}我也可以用类似点点，点点，点点……的操作
{27173}{27235}来回到我的文件系统的比较靠近根的位置
{27236}{27336}这个应该是回到了根目录
{27337}{27393}然后里面有一个 `bin` 目录
{27394}{27453}然后在里面有一个 `echo` 文件
{27454}{27504}所以我就可以输一个 `world`
{27510}{27578}然后这就会运行 `bin` 目录下的 `echo` 程序
{27595}{27636}好的，所以靠这个办法
{27637}{27719}你可以构建路径到你的文件系统的任意地方
{27744}{27834}有的时候你想要用绝对路径，有的时候你想要用相对路径
{27835}{27900}一般你就用短的那一种
{27915}{28046}但是比如说你想要运行一个或者写一个程序
{28047}{28139}它调用运行了类似 `echo` 或者 `date` 的程序
{28140}{28228}你希望它可以在任何地方都能跑起来
{28229}{28324}那要么你就只给出这个要被运行的程序的名字
{28325}{28351}像 `echo` 或者 `date`
{28352}{28450}然后让 Shell 用 `path` 自己去找出它们在哪里
{28451}{28500}要么你就给出被调用运行的程序的绝对路径
{28516}{28554}因为如果你给出一个相对路径
{28555}{28679}那可能我在我的 home 目录运行，你在别的什么目录运行
{28683}{28729}可能我这里能跑起来，你那里就不能跑起来了
{28785}{28914}um，总的来说，我们运行程序的时候
{28928}{29009}程序会默认在当前目录运行
{29024}{29093}除非我们再给程序一个参数
{29112}{29149}其实运行在默认目录是相当方便的
{29150}{29244}因为这意味着我们不必给出复杂的完整路径
{29252}{29356}用到的只是文件名或者是当前目录
{29374}{29512}搞清楚我们当前目录里有啥很关键
{29522}{29547}然后我们可以发现
{29548}{29612}`PWD` 命令能输出我们当前所在的目录
{29613}{29777}有个叫 `ls` 的命令能列出当前目录下的文件
{29792}{29832}如果我在这打上 `ls`
{29845}{29931}这就是当前目录下所有的文件，对吧
{29932}{30032}这是种方便在文件系统中快速查找的方法
{30081}{30158}你可以看到，如果我输入 `cd ..`
{30159}{30186}然后执行 `ls` 指令
{30194}{30276}会输出上一级目录下的文件
{30308}{30448}我也可以 `ls` 一个 `..` 的参数
{30449}{30481}就像我给它一个路径一样
{30488}{30534}然后他就会 `ls` 上一级目录
{30535}{30572}而不是当前我所处的目录
{30574}{30623}或者直接 `ls` 上一级目录
{30690}{30749}如果我直接返回到根目录
{30750}{30817}你会发现根目录里有不同的路径
{30842}{30912}在这你可能不知道一个便捷的小技巧
{30913}{31012}你可以用两个特殊符号做点别的事
{31013}{31084}第一个，`~`
{31085}{31169}`~` 可以把你带回用户目录
{31170}{31252}所以说 `~` 总是指向用户目录
{31253}{31322}你可以通过它到达用户目录相关的目录
{31323}{31501}所以我可以输入 `cd ~/dev/pdos/classes/missing-semester`
{31502}{31539}现在我就在这个目录里了
{31540}{31634}因为 `~` 在这代表 `/home/jon`
{31656}{31823}尤其在 `cd` 命令中还有一个很方便的参数 `-`
{31831}{31875}如果你运行 `cd -`
{31882}{31965}他会将当前目录跳转到你所处的上一个目录
{31986}{32006}所以如果我运行 `cd -`
{32007}{32035}我就回到了根目录
{32058}{32097}如果我再执行一遍 `cd -`
{32142}{32189}我就回到了 `missing-semester` 这个文件夹
{32190}{32212}由此可见
{32213}{32272}这让你很方便的在两个不同文件夹之间切换
{32381}{32465}关于 `ls` 或者 `cd` 命令
{32476}{32533}还有一些你可能不知道的参数
{32563}{32577}目前为止
{32578}{32652}我们除了给出路径以外啥都没做
{32667}{32705}但是如果你想自己探索的话`
{32706}{32765}你可以首先考虑 `ls` 一个路径
{32781}{32891}大多数程序采用一些 `flag`（标志）
{32892}{32931}和 `option`（选项）等作为参数
{32943}{33000}这些一般都以半角字符 `-` 开头
{33021}{33163}其中大多数程序都涵盖了 `--help` 这个函数
{33184}{33211}举个例子
{33214}{33259}如果你执行 `ls --help`
{33260}{33430}它会很贴心地输出一大堆关于 `ls` 指令的帮助信息
{33441}{33524}这些信息阐述了 `ls` 的用途
{33525}{33580}并且你可以给出的一堆 `option`
{33581}{33629}和一堆文件
{33642}{33707}阅读用法的时候
{33729}{33831}`...` 代表不填或一个或更多
{33832}{33898}`[]` 代表可 `option`
{33912}{33988}所以现在这里给出了一些 `option`
{33989}{34029}和一些可选的文档
{34055}{34120}显然它在告诉你这个程序会做什么
{34121}{34237}并且特指了一些 `flag` 和 `option`
{34238}{34371}通常把一个 `-` 加上一个字母叫做一个 `flag`（选项）
{34372}{34477}或者把后面不跟没有数值的叫做 `flag`
{34478}{34537}而后面跟有一个值的叫做一个 `option`
{34538}{34622}举个例子，`-a` 和 `--all` 都叫 `flag`
{34722}{34818}而 `-C` 或 `--color` 都是 `option`
{34856}{34943}如果你向下翻得够远
{34963}{35091}你能发现一个 `-L` 的 `flag`
{35092}{35127}啊，翻车了
{35148}{35357}这个 `-L` 的 `flag` 是采用长列表格式[*]
{35369}{35428}通常来说，这很方便
{35438}{35478}我们来看看它到底能做什么
{35492}{35545}如果我执行 `ls -L`
{35578}{35642}它仍然会输出当前路径下的一长串文件
{35643}{35726}但是给出了关于这些文件更多的信息
{35742}{35810}你会发现你以后会经常用到这个 `flag`
{35821}{35935}因为它多给你的信息能提供很大的便利
{35999}{36074}让我们看看多出来的信息都有什么
{36194}{36307}首先，前面带 `d` 的这些条目
{36308}{36350}代表这里面还有些东西
{36365}{36476}举个例子，这个 `_data` 的条目就是一个目录
{36477}{36589}但 `404.html` 不是个目录，而是一个文件
{36604}{36799}后面的字符代表文件被授予的权限
{36812}{36951}这就像我们之前看到的，我并不能 `cd` 一个指定的文件
{36952}{37010}或者我 `cd` 不了一个目录
{37011}{37101}这都是由特定文件或目录的权限决定的
{37127}{37183}阅读这一串字母的方法如下
{37184}{37259}把后面的 9 个字母分成三组
{37260}{37345}第一组代表权限被授予给了文件的所有者
{37346}{37422}你可以看到这些文件的所有者都是我
{37463}{37628}第二组的三个字母代表给拥有这些文件的用户组的权限
{37629}{37724}也就是 `jon` 这个用户组
{37740}{37977}最后的一组字符是给非所有者的其他人的权限
{38011}{38077}这个目录某种意义上来说有些“无聊”
{38091}{38146}因为这个目录的所有者是我
{38147}{38241}但是如果我们执行 `cd /` 回到根目录
{38242}{38371}然后再 `ls -L`，会发现所有文件和目录的所有者都是 `root`
{38388}{38464}我们回到什么是根用户来
{38471}{38556}你能发现这里的权限有点意思
{38557}{38691}这一组中的三个字母代表读取、写入和执行
{38727}{38844}这些对于文件和目录又有什么不同呢
{38863}{38914}对于文件，这就很显而易见了
{38915}{38976}如果你有读取权限
{38977}{39021}你就可以读取文件的内容
{39022}{39089}如果你有文件的写入权限
{39090}{39220}你就可以保存，写入甚至是重写一遍
{39221}{39311}如果你有一个 `x`
{39312}{39358}你就可以执行这个文件
{39377}{39490}如果我们运行 `ls -l /bin`
{39491}{39577}啊，我说我是乱打的啊，应该是 `ls -l /usr/bin`
{39579}{39748}你会发现即使不是所有者都有全部的执行权限
{39749}{39822}这是因为，举例来说
{39823}{39880}我们希望这个电脑上的所有用户都能运行显示程序
{39892}{40058}没有任何理由只让某一用户能运行
{40088}{40185}对于目录来说，这些权限会显得稍有不同
{40202}{40369}所以读取权限允许你看这个文件夹里有哪些东西
{40388}{40466}你可以把读取权限当成阅读这个目录的清单
{40467}{40508}这个权限允许你列出目录里的内容
{40531}{40712}目录的写入权限就是你是否能够重命名、新建或者删除里面的文件
{40746}{40796}所以这也是一种权限
{40797}{40968}但是要注意到，这意味着如果你有文件的写入权限
{40969}{41060}但是你没有这个目录的写入权限
{41061}{41102}你就不能删除这个文件
{41103}{41169}即使你清空了文件的内容，你也不能删除它
{41170}{41266}因为这样做的话需要目录的写入权限
{41285}{41397}最后，目录的执行权限困扰了很多人
{41414}{41506}目录的执行权限通常来讲就是搜索
{41515}{41598}但这并不是一个容易理解的名字
{41599}{41720}它意味着你能不能进入这个目录
{41757}{41810}如果你想找个文件
{41811}{41904}或者打开这个目录、读取这个目录还是写入这个目录
{41920}{42001}甚至基础如 `cd` 这个目录
{42002}{42178}你都必须有所有父目录及其自身的执行权限
{42212}{42401}举例来说，如果我想访问 `/usr/bin` 下的文件， 例如 `echo`
{42411}{42506}我必须拥有路径上所有目录的执行权限
{42507}{42561}并且还得拥有 `bin` 这个目录的执行权限
{42577}{42690}如果我没有全部的这些执行权限，我就无法访问这个文件
{42722}{42803}因为我无法通过任何方法进入这个目录
{42868}{42966}另外你可能还会遇到另外一些字节
{42967}{43028}你可能会碰到 `s` 或 `t`
{43029}{43082}在这些清单里你可能还会看见 `l`
{43095}{43161}如果你对这些感到好奇的话，我们可以在工作时间聊聊
{43175}{43281}这些大多数对你在这堂课上学的东西都不是那么重要
{43310}{43357}但是了解它们会提高你的便利程度
{43358}{43429}所以如果你们实在好奇，你们可以自己查找相关资料
{43430}{43486}或者在工作时间来问我们
{43531}{43611}了解另外一些程序也能方便你自己
{43612}{43661}哦抱歉，还有一件事情
{43662}{43694}如果它显示的是一个横杠（-）
{43695}{43754}意思就是你没有对应的权限，对吧
{43758}{43834}比如说它显示 r-x
{43842}{43913}那就意味着你有读和执行权限，但没有写权限
{43982}{44075}还有很多别的趁手的工具
{44076}{44154}有一个是 `mv` 命令
{44170}{44234}如果我 `cd` 回 `missing semester`
{44242}{44323}在这里我能用 `mv` 重命名文件
{44347}{44433}它接受两个路径（path）（作为参数）
{44452}{44506}先是原有的路径（path），然后是新的
{44521}{44615}这意味着 `mv` 既可以让你重命名一个文件
{44622}{44714}如果你只想原地重命名文件的话
{44721}{44801}或者把文件移动到一个不同的目录里
{44814}{44895}原理就是你给出现有文件的路径（和文件名）
{44896}{44952}以及目标路径和新文件名
{44957}{45015}然后它可以改变文件的路径和名字
{45042}{45167}比如说我可以 `mv dotfiles.md` 到 `foo.md`
{45179}{45226}对吧，虽然没卵用
{45232}{45297}我也可以 `mv` 回去
{45437}{45532}也有一个 `cp` 命令，或者打 `copy`
{45541}{45609}`cp` 让你复制[*]文件，用法很相似的
{45681}{45782}它也接受两个参数，复制源路径和目标路径
{45794}{45824}这些得是完整路径[*]
{45841}{45887}我可以举个栗子，比如说
{45899}{46014}我想 `cp dotfiles.md ` 到 `../food.md`
{46039}{46074}对，是 `food.md`，好嘞
{46098}{46140}如果我现在 `ls ..`
{46141}{46239}看，现在这个目录里有个 `food.md`
{46261}{46311}所以 `cp` 也是接受两个参数
{46312}{46359}而且不必是同一个目录
{46401}{46469}相似地，有个 `rm` 命令
{46470}{46504}让你可以移除（删除）一个文件
{46505}{46581}这里你可以传一个路径，比如说这里
{46582}{46641}我想把 `../food` （.md）删掉
{46656}{46703}你应该注意的是移除
{46704}{46739}特别是在 Linux 上
{46749}{46824}默认的移除是非递归的（recursive）
{46843}{46914}也就是说你不能用 `rm` 移除目录
{46936}{47044}你可以传一个执行递归移除的 `-r` flag
{47057}{47109}然后传递想移除的路径（path）
{47110}{47155}它就会移除目录下的所有内容
{47175}{47319}也有 `rmdir` 命令可以让你移除目录
{47320}{47408}不过只允许移除空目录
{47433}{47464}所以设计它的匠心是
{47466}{47512}这算是给你提供一种安全机制
{47513}{47572}用它你就不会不小心扔掉一堆重要文件
{47606}{47693}最后有一个趁手的小命令
{47694}{47726}是 `mkdir` （make directory）
{47727}{47771}可以让你创建一个新目录（文件夹）
{47772}{47862}之前说过了，别想着写一些这样的命令
{47863}{47926}这样会给你整出两个目录来
{47933}{47997}一个名为 `My`，一个 `Photo`
{48009}{48072}如果你想创建那种（带空格的）目录
{48073}{48190}要么把空格转义，要么把整个字符串引起来
{48290}{48474}如果你想这些平台上了解在任意一个命令的信息
{48486}{48604}也有个非常奥里给的程序，叫做 `man`
{48614}{48668}意思是手册、说明书（manual pages）
{48669}{48791}这个程序接受其他程序的名字作为一个参数
{48792}{48844}然后显示它的说明书
{48856}{48909}比如说我们可以输入 `man ls`
{48926}{49028}就显示了 `ls` 的说明书
{49029}{49091}你会发现这里显示的内容其实和
{49092}{49154}我们运行 `ls --help` 得到的内容挺相似的
{49168}{49253}不过翻阅起来稍微容易点儿
{49270}{49325}一般来说，翻到底儿瞧瞧
{49326}{49425}你能看到一些提示，基本都是
{49433}{49483}命令示例啊，作者啊，哪儿有更多信息啊
{49484}{49518}这类东西
{49542}{49589}偶尔有个问题挺捉弄人的
{49594}{49676}啊，直到最近一个版本里他们在底下
{49677}{49695}给加了一行
{49696}{49732}显示按 `Q` 退出
{49733}{49855}他们以前不显示这种「按 `Q` 退出」的
{49864}{49927}如果你不知道这事，还挺难退出来的
{49996}{50118}有个好用的快捷键，`Ctrl` + `L`
{50119}{50203}可以清空终端，让光标回到顶部
{50268}{50352}到现在我们只是分开说了各个程序
{50360}{50468}但是 Shell 真正的本领在于
{50469}{50545}当你把不同的程序结合在一起的时候
{50591}{50678}与只是运行 `cd` 和 `ls` 相比很强
{50679}{50771}也许你想把多个程序串起来
{50772}{50821}也许是想和文件交互
{50822}{50881}或者在各个程序之间操作文件
{50925}{51046}我们借助一个叫流（stream）的概念完成
{51062}{51127}Shell 默认会给我们的每个程序创建
{51137}{51218}我简化一下，就说程序有两个主要的流（stream）
{51230}{51270}默认，程序会有一个输入流（input stream）
{51271}{51310}和一个输出流（output stream）
{51330}{51399}默认输入流里的内容来自你的键盘
{51415}{51460}基本上输入流是终端
{51461}{51503}无论你向终端输入什么
{51504}{51544}最后都会传到程序里
{51559}{51623}默认的输出流，就是说
{51624}{51672}每当程序想要输出一些内容时
{51673}{51722}它会输出到这个流里去
{51723}{51775}默认也是终端
{51786}{51844}这就是为什么，当我打入 `echo hello`
{51845}{51894}它就显示回了我的终端里面
{51908}{52046}但是 Shell 提供了重定向这些流的方法
{52047}{52132}把输入和输出都改到程序员指明的地方
{52166}{52353}这里最直接的方式是用大于小于号[*]
{52380}{52425}所以你可以写一些类似这样的事情
{52436}{52481}或者类似那样的事情
{52516}{52649}小于号表示重定向这个程序的输入流
{52650}{52709}变成这个文件的内容
{52746}{52924}大于号表示重定向上述程序的输出流
{52943}{52984}变成输出到这个文件内
{53012}{53066}我们举个例子试一下是什么样
{53079}{53208}如果我 `echo hello`，我想把这个内容
{53209}{53273}存在一个叫 `hello.txt` 的文件里
{53289}{53365}我给了，这是个相对路径（relative path），对吧？
{53366}{53471}这样会在当前目录下创建一个 `hello.txt`
{53479}{53531}至少，理论上来说，它的内容
{53532}{53584}应该是 `hello` 这个单词
{53597}{53688}如果我运行一下，注意，啥都没输出来
{53706}{53764}前一次我运行 `echo hello` 的时候
{53765}{53789}它输出了 `hello`
{53790}{53897}现在 `hello` 已经跑到 `hello.txt` 里了
{53913}{53990}我可以用这个叫 `cat` 的程序验证
{53991}{54094}`cat` 打印出一个文件的内容
{54105}{54190}所以我可以 `cat hello.txt`
{54199}{54237}哎，它就显示了 `hello`
{54262}{54386}不过 `cat` 也支持这种流的重定向
{54391}{54504}所以我可以说 `cat` 默认只是将输入打印
{54505}{54560}呃，将输入原封不动复制到输出
{54572}{54683}比如，`cat`，我想让你接受 `hello.txt` 的输入
{54708}{54815}在这个例子下，Shell 就会打开 `hello.txt`
{54830}{54936}取出它的内容，设置成 `cat` 的输入
{54937}{55023}然后 cat 就会把这些内容打印到它的输出（流）
{55024}{55114}我没有重定向它，所以是我的终端
{55122}{55185}总之就是它会把 `hello` 打印到输出
{55235}{55290}我也可以同时使用两种（重定向）
{55291}{55422}比如我想复制一个文件但不用 `cp`
{55433}{55551}我可以用这套方法，具体来说
{55552}{55637}实际上我没有告诉 `cat` 任何事
{55638}{55703}我只是命令它说「你正常干活」，对吧
{55704}{55783}`cat` 不知道是不是发生了重定向
{55794}{55866}但是我会告诉 Shell 用 `hello.txt`
{55867}{55893}去作为 `cat` 的输入
{55902}{55963}然后把 `cat` 输出的所有内容存到
{55964}{56007}`hello2.txt` 里面去
{56037}{56091}这次还是没有东西打印到终端上
{56092}{56160}但是如果我运行 `cat hello2.txt`
{56168}{56224}我得到了期望的输出
{56245}{56298}也就是一个源文件的副本
{56359}{56439}也有个东西是双大于号[*]
{56444}{56542}作用是追加（append）而不是覆写（overwrite）[*]
{56561}{56625}你会注意到如果我
{56626}{56711}`cat < hello.txt > hello2.txt`
{56718}{56771}然后我 `cat hello2.txt`
{56772}{56812}它仍然只是包含 `hello`
{56813}{56862}尽管它之前已经有过 `hello` 了
{56879}{56994}如果我给它换成双大于号，意味着追加
{57002}{57038}如果我现在再 `cat` 那个文件
{57039}{57068}它就有了两个 `hello`
{57148}{57208}这些都挺直白的
{57209}{57279}它们仅仅是和文件交互的一些方式
{57287}{57326}不过真正有趣的地方是
{57327}{57390}Shell 附赠给你的一个操作符（operator）
{57391}{57506}叫管道符（pipe），管道符就是一个竖线
{57521}{57585}管道的意思是
{57594}{57692}取左侧程序的输出
{57705}{57772}成为右侧程序的输入
{57871}{57951}这看上去会是什么样子呢
{57961}{58032}来试一个例子，比如说 `ls /`
{58033}{58092}或者 `ls -l /`
{58101}{58138}打印出了一堆东西
{58145}{58234}我就说我想要输出的最后一行
{58248}{58310}有一个命令叫 `tail`
{58321}{58436}它打印出它输入的最后 n 行
{58453}{58561}我可以 `-n1`，所以这就是个叫 n 的 flag
{58567}{58676}如果你想，也可以用更长的 `--lines`
{58684}{58784}这个例子里，它表明输出最后一行
{58796}{58883}我可以把这些连接到一起，也就是说
{58884}{59004}`ls -l / | tail -n1`
{59069}{59152}注意这里 `ls` 并不了解 `tail`
{59153}{59215}`tail` 也不认识 `ls`
{59216}{59251}它们是不同的程序
{59252}{59330}也没有刻意设计和对方相兼容
{59344}{59397}它们只知道要从输入读数据
{59398}{59426}结果写到输出
{59440}{59504}`pipe` 才是把它们连结起来的东西
{59525}{59657}这个例子，我想 `ls` 输出作为 `tail` 输入
{59661}{59732}`tail` 的输出则会输到我的终端
{59733}{59759}因为我没有重定向它
{59778}{59822}我也可以把它重定向，比如说
{59823}{59879}我想输出到 `ls.txt` 里面
{59893}{59964}这里如果我 `cat ls.txt` ，就得到
{59965}{59992}一个期望的输出
{60018}{60089}这意味着你可以做一些很妙的事情
{60090}{60148}我们会在 data wrangling （数据整理）课程
{60149}{60179}里面涉及更多
{60189}{60267}是大约四天之后
{60291}{60357}有一些特别奇妙的工具
{60358}{60417}构建高级管道的时候用得到
{60463}{60541}给你们举一个例子，我们可以做一些操作，比如
{60556}{60701}`curl --head --silent google.com`
{60753}{60805}就只是展示个大概
{60813}{60873}这会给我访问 google.com 时候
{60874}{60924}所有的 HTTP Headers
{60963}{61015}我也可以用管道给它接到
{61033}{61111}`grep --ignore-case`
{61112}{61157}或者说 `-i`
{61167}{61250}比如说我想（匹配）content-length
{61268}{61355}这样就会打印出 content-length header
{61356}{61415}`grep` 是我们之后会讲的程序
{61416}{61505}它支持在输入流里搜索给定关键字
{61544}{61621}我们还可以用管道连到 `cut` 命令
{61635}{61792}它可以接受一个分隔符，我们设成空格
{61793}{61841}我想要第二个字段
{61853}{61906}这样就只输出 content-length（的值）
{61922}{61969}这算是一个很傻的例子
{61970}{62064}只是在命令行里以字节（bytes）的形式
{62065}{62117}提取出 google.com 的内容长度
{62118}{62220}这没啥有用的，但是你可以从中窥见
{62221}{62257}把命令链接在一起
{62258}{62387}你可以做很多文本操作的特技
{62388}{62478}而且 `pipe` 不止用于文本数据
{62479}{62548}还可以拿来处理比如图片
{62549}{62666}当你有一个程序可以接受并处理二进制图片
{62667}{62720}然后输出一个二进制图片的时候
{62721}{62786}也可以像这样把它连进去
{62787}{62868}我们之后也会谈到这类例子
{62886}{62944}你甚至可以这样处理视频
{62947}{63062}你可以 - 比如说你家里有个 Chromecast [*]
{63068}{63130}你可以把一个视频文件推流
{63144}{63228}如果把管道的最后一个程序设成
{63229}{63290}Chromecast 的发送程序
{63301}{63348}然后以流的形式传给它视频文件
{63349}{63408}它就推流（或者 HTTP 形式）传到你的 Chromecast
{63542}{63632}在数据整理那节会涉及更多
{63642}{63737}但是我还想说一个事情
{63741}{63947}大概就是终端的更有趣和强大的用法
{63948}{64055}对于那些已经熟悉终端的同学来说
{64056}{64115}也许会挺有意思
{64152}{64244}我们要先提一个重要话题
{64245}{64334}就是涉及到 Linux 和 MacOS 的时候
{64339}{64408}有一个叫 root （根）用户的概念
{64419}{64515}root 用户类似 Windows 里面的管理员（Administrator）
{64529}{64582}有值为 0 的用户 ID
{64595}{64640}root 是很特别的，因为
{64641}{64718}他被允许在系统上做任意行为
{64749}{64832}就算一个文件是任何人不可读的
{64833}{64885}或者任何人不可写的
{64886}{64936}root 却可以访问这个文件（且读写）
{64948}{64987}他算是一种「超级用户」
{64988}{65019}可以做任何想做的事
{65089}{65189}大多数时候你不会用超级用户操作
{65190}{65222}你不会是 root
{65223}{65281}你应该是一个类似 `Jon`，或者别的啥
{65282}{65305}按你的名字来的用户
{65306}{65356}你该用这个用户操作（电脑）
{65368}{65478}因为如果一直在 root 下操作电脑
{65486}{65523}如果你运行了错误的程序
{65524}{65574}可能会直接炸了你的电脑
{65585}{65634}你肯定不想这样，对吧
{65664}{65771}但是从今往后你每次想用 root 做点事的话
{65793}{65878}通常这种情况是，用一个叫 `sudo` 的程序
{65893}{66024}S-U-D-O 或者说 do as su
{66035}{66097}这里 su 就是 Super User（的缩写）
{66104}{66193}这是一个用超级用户运行程序的办法
{66221}{66283}通常 `sudo` 的用法是
{66284}{66377}你先打 `sudo` 再接上平常调用的命令
{66378}{66494}它就会以 root 身份运行这个命令
{66575}{66645}你在哪里可能要用到这种东西呢
{66646}{66728}呃，有一个特别的……
{66729}{66788}在你的电脑上有很多特别的文件系统
{66789}{66865}其中有一个特定的叫 `sysfs`
{66877}{66937}如果你 `cd` 到 `/sys`
{66954}{67014}这整个儿都是新世界
{67024}{67138}这个文件系统不是真实存在的文件
{67148}{67233}相反，这是一大堆内核参数
{67234}{67329}内核（kernel）基本上就是你电脑[*]的核心
{67351}{67448}这是种访问这些内核参数的方法
{67462}{67527}通过这些看起来是文件系统的东西
{67558}{67670}你看，这里如果我 `cd` 到比如 `class`
{67671}{67766}对于一大把设备，它有各个对应的目录
{67776}{67810}我可以与它们交互
{67811}{67900}或者各种队列（queue）
{67901}{67995}或者各种奇奇怪怪的内核玩意儿
{68023}{68099}由于它们是以文件形式展露（exposed）的
{68100}{68194}这意味着我们可以用先前的所有工具
{68195}{68234}去操作他们
{68246}{68372}举个栗子，如果你去到 `sys/class/backlight`
{68398}{68509}这个 `backlight` 可以直接设置笔记本的亮度
{68510}{68535}如果你是用笔记本电脑
{68536}{68596}所以我 `cd` 进 `intel backlight`
{68597}{68629}这是个 Intel 的笔电
{68640}{68717}里边儿你可以看见有个文件叫 `brightness`
{68725}{68765}我可以 `cat` 这个 `brightness`
{68766}{68851}这是我现在的屏幕亮度
{68871}{68955}不止于此，我也可以更改它
{68956}{69019}来改变我的屏幕亮度
{69038}{69109}你也许认为我要……
{69110}{69159}来看看最大亮度是多少
{69167}{69221}好，所以现在是最大亮度
{69240}{69318}你可能会想，我会写点这样的命令
{69334}{69461}如果我 `echo`……让我们设个一半
{69476}{69526}`echo 500 > brightness`
{69544}{69601}如果我这么干，它提示我没有权限
{69602}{69657}我不允许修改亮度
{69658}{69776}因为……基本上如果你要修改内核的东西
{69777}{69818}你得是管理员才行
{69831}{69900}你也许会以为解决方案是写个
{69907}{69952}`sudo echo 500`
{69958}{70012}但我还是莫得权限
{70024}{70125}为毛呢？这是因为按我之前说的
{70134}{70267}输入输出的重定向是程序不知道的
{70288}{70341}用管道把 `ls` 连接到 `tail` 的时候
{70342}{70434}`tail` 不知道 `ls`，`ls` 也不知道 `tail`
{70435}{70520}管道和重定向都是 Shell 设好的
{70534}{70630}所以现在的情况是我告诉 Shell
{70639}{70772}去运行 `sudo`，并且包括参数 `echo 500`
{70785}{70874}然后发送输出到这个 `brightness` 文件
{70898}{70977}但是 Shell 打开 `brightness` 的时候
{70978}{71041}用的不是 `sudo`
{71066}{71165}所以这里 Shell 以我（Jon）的用户身份
{71166}{71219}去试图打开 `brightness` 文件并写入数据
{71220}{71315}而这不被允许，所以我有个无权限的错误
{71338}{71391}你也许见过（下面）这个
{71412}{71486}如果你搜了啥然后最后到了 Stackoverflow 上[*]
{71487}{71532}他们告诉你运行一下这个命令就行
{71533}{71648}你会见到像这样的，他们给你一些说明
{71650}{71944}比如 `echo 1 > sys`，呃，`net/ipv4_forward`
{71945}{72019}在设置防火墙的时候你可能见过这种东西
{72029}{72122}这个命令之所以能行
{72132}{72179}是因为前面这个小小的 `#`
{72180}{72229}意味着以 root 运行整条命令
{72237}{72344}这件事很少有人解释，但就是这个意思
{72350}{72422}你会看见在我的 prompt（提示符）上
{72426}{72492}`$` 表示你现在不是 root
{72512}{72579}重要的是我现在怎么解决问题
{72580}{72671}一是我可以切换到 root 终端
{72684}{72746}这个方法是运行 `sudo su`
{72756}{72851}`sudo su` 是说用 root 运行接下来的命令
{72866}{72978}`su` 是个蛮复杂的命令
{72979}{73076}能让你以超级用户登录 Shell
{73103}{73169}如果我运行，然后输入密码
{73177}{73304}你会看到开头的用户名从 `jon` 变成了 `root`
{73313}{73383}提示符从 `$` 变成了 `#`
{73402}{73458}如果我现在处理那个文件
{73459}{73518}`echo 500 > brightness`
{73540}{73578}我的屏幕就变暗了一点
{73579}{73642}虽然你看不见，你只能听信我
{73662}{73722}我现在就没得到错误
{73729}{73820}因为现在 Shell 以 `root` 身份运行
{73821}{73871}而不是 `jon`
{73880}{73948}而 `root` 用户允许打开这个文件
{73973}{74080}但是运用我们现有的终端知识
{74088}{74132}其实还有一个办法
{74133}{74188}能不用进入 root Shell
{74204}{74412}就是，呃，我恢复到 1060
{74461}{74507}你看到这里的区别了吗
{74539}{74660}我告诉 Shell 去运行 `echo 1060`
{74661}{74696}它会输出 `1060`, 然后我告诉它
{74706}{74788}运行 `sudo tee brightness` 命令
{74796}{74926}然后把 `echo` 的输出送入 `sudo tee` 的输入
{74950}{75024}要搞明白这个你得知道 `tee` 命令干啥
{75034}{75128}`tee` 命令取它的输入，然后写入到一个文件
{75129}{75172}并且写入到标准输出（流）
{75209}{75267}所以 `tee` 是一个很方便的命令
{75268}{75350}比如说你有个日志[*]，你想
{75351}{75408}把它传到一个文件里存着之后看
{75409}{75461}但你还想现在瞅一眼
{75476}{75517}那你就可以用管道传给 `tee`
{75518}{75612}再给它文件名，它就能把无论什么输入
{75613}{75669}写到文件和你的屏幕上
{75687}{75758}这里我就利用这个程序
{75759}{75839}这里我说「以 root 运行 `tee`」
{75848}{75907}然后输出到 `brightness` 文件
{75937}{76044}这个例子里 `tee` 程序打开了 `brightness`
{76045}{76069}并且以 root （身份）运行
{76070}{76129}所以这是可行的
{76139}{76166}如果我现在运行它
{76167}{76274}你还是看不到亮度，但是它被调高了
{76302}{76338}我没有收到任何错误提示
{76339}{76497}并且我也不必跑去危险的根目录在那运行指令
{76528}{76586}如果你想更深入的了解文件系统的话
{76587}{76646}你在浏览的时候能看到很多有趣的东西
{76672}{76835}你能发现各种各样有趣的东西
{76836}{76937}举个例子，我们已经发现了有个有趣的亮度指令
{76938}{77002}我想知道我还可以设置什么其他有趣的亮度
{77049}{77152}所以我们可以用下一讲要讲到的查找指令
{77163}{77388}我在当前目录里找找长有点像亮度的东西
{77404}{77481}啊，翻车了…也许它们不是文件？
{77517}{77666}啊，看来是我拼错了，好烦啊
{77849}{77937}看起来，它不怎么想帮我查找有关的文件
{78009}{78075}走运的是，我其实已经知道一个了
{78130}{78277}有个子目录叫 `LEDs` ，这里面也有亮度相关的文件
{78292}{78322}看看里面有啥样的 LED 灯
{78324}{78360}好家伙，还不少呢
{78370}{78468}举个例子，有滚动锁定键的 LED 灯
{78473}{78577}你们大多数人可能都不知道啥是滚动锁定键了
{78578}{78631}或者很少有人知道啥是滚动锁定
{78641}{78763}你可能在键盘上见过一个叫 `scroll lock` 的按键
{78789}{78848}基本上再也没人知道这个按键是干什么的了
{78849}{78954}它没啥用了，所以它差不多是个被淘汰的按键了
{78955}{79014}同时也是个被淘汰的 LED 灯
{79044}{79099}如果我把它配置一下
{79100}{79186}使每次在来邮件的时候滚动锁定键都会亮起来怎么样
{79193}{79247}因为没有别的东西会让它亮起来
{79272}{79335}如果我把你发配到这个有亮度配置的目录里
{79372}{79417}这里也有个 `brightness`
{79418}{79453}并且被设为 `0`
{79465}{79510}如果我们把 `1` 写入进去会发生什么
{79601}{79730}话说回来，别随便把数字写入这个目录的文件里
{79731}{79786}因为你会直接影响到内核
{79787}{79829}你得先弄明白这个文件有什么作用
{79832}{79942}现在我做好了安全措施并且我也做了充分研究
{79976}{80022}所以你们可能没发现
{80023}{80118}其实我键盘上滚动锁定的灯已经亮了
{80145}{80263}现在，如果我写一个能检查邮件之类的程序
{80264}{80383}我最终就能把 `1` 写入这个文件
{80397}{80557}现在有个让我键盘上的滚动锁定键显示有没有新邮件的方法
{80593}{80806}你大致有个用终端和 Shell 来实现这个的雏形了
{80807}{80908}并且现在你掌握的足够完成一些基本任务了
{80909}{81100}至少从理论上你不用点击界面去查找文件了
{81113}{81174}这里还有个你应该掌握的小技巧
{81175}{81238}也就是打开文件的能力
{81251}{81359}目前我只告诉你怎么查找文件
{81368}{81522}但是有一点你要知道
{81537}{81669}`xdg-open` 这个指令可能只在 `Linux` 上运行
{81670}{81731}在 MacOS 上可能叫 `open`
{81741}{81785}至于 Windows 嘛，谁知道
{81795}{81960}你给出一个文件名，然后 `xdg-open` 就会用合适的程序打开它
{81966}{82064}所以如果你用 `xdg-open` 打开一个 `HTML` 文件
{82065}{82126}它就会打开你的浏览器然后打开那个文件
{82154}{82216}所以，理论上，你有了这个程序之后
{82217}{82299}你就再也不用打开 Finder 窗口了
{82323}{82370}虽然你可能还会打开，因为别的原因
{82371}{82461}但是从理论上讲，你可以用这套工具完成任何任务
{82495}{82593}今天学的东西对你们中的一部分人可能有些基础
{82594}{82683}但是就像我提到过的，这是一个快速提升的阶段
{82684}{82739}现在我们知道了 Shell 是怎么运行的
{82740}{82820}之后还了解了我们之后的讲座中会做些什么
{82821}{82980}那就是用 Shell 去做一些真正有趣的事情
{82988}{83107}这有点像学习我们将要用到的界
{83108}{83173}所以我们需要全部了解这些东西，这很重要
{83202}{83282}我们在接下来的讲座中会讲到很多
{83283}{83337}关于诸如这种自动化任务的话题
{83338}{83418}关于怎样写出能运行一大堆程序的脚本
{83427}{83555}并且还得学习怎么在终端里写条件、循环之类的东西
{83556}{83650}还有运行一个程序，直到它出错
{83664}{83780}你的测试程序出错之后可以容易地停下来
{83808}{83884}所以这就是下周讲座的主题
{83888}{83922}你有什么问题吗
{83933}{84028}像你刚才在 `\sys` 目录下演示的那样
{84029}{84166}你是在 Linux 系统下演示的
{84167}{84233}如果在 Windows 下用 Linux 子系统会怎样呢？
{84284}{84320}这是个好问题
{84321}{84498}我不知道 Windows 的 Linux 子系统会不会展露 `\sys` 文件系统
{84499}{84611}如果显示的话，也只会展露很少的一部分
{84651}{84707}可能会吧
{84708}{84776}比如说，会有 LED 和 brightness 吗？
{84777}{84830}我不知道，自己去查吧
{84846}{84968}你会发现这个系列讲座的讲义已经上线了
{84977}{85091}并且讲义最底下有一些练习
{85098}{85181}一些练习相对简单，而一些练习有点难度
{85182}{85302}我们建议你尝试着去做这些练习
{85303}{85344}如果你已经掌握了这些东西的话
{85345}{85382}完成这些练习不会占用你太多时间
{85383}{85458}如果你还没有完全掌握
{85459}{85521}这些练习会教给你一些你可能没意识到自己不会的东西
{85527}{85694}接下来，在课后的工作时间，我们乐意解答你遇到的任何问题
{85695}{85808}或者想了解如何更高效的使用课内课外遇到的指令
{85836}{85902}下一讲，也就是明天
{85925}{86035}会在你们已经基本掌握练习教给你的东西的基础上进行
{86066}{86165}在网站上还有一个邮箱地址
{86166}{86312}你可以在工作时间之外向我们发送你的问题
{86350}{86428}今天这堂课结束之前，还有什么问题吗
{86495}{86571}没了吗？看来没了
{86572}{86606}那么大约五分钟后
{86607}{86765}我们会在 Gates Building 的九楼继续办公
{86787}{86825}大家再见！

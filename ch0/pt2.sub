{1}{1}29.970030
{43569}{43618}哦抱歉，还有一件事情
{43619}{43650}如果它显示的是一个横杠（-）
{43651}{43710}意思就是你没有对应的权限，对吧
{43715}{43790}比如说它显示 r-x
{43798}{43869}那就意味着你有读和执行权限，但没有写权限
{43938}{44031}还有很多别的趁手的工具
{44032}{44110}有一个是 `mv` 命令
{44126}{44190}如果我 `cd` 回 `missing semester`
{44198}{44279}在这里我能用 `mv` 重命名文件
{44303}{44389}它接受两个路径（path）（作为参数）
{44408}{44462}先是原有的路径（path），然后是新的
{44477}{44571}这意味着 `mv` 既可以让你重命名一个文件
{44578}{44670}如果你只想原地重命名文件的话
{44677}{44756}或者把文件移动到一个不同的目录里
{44770}{44850}原理就是你给出现有文件的路径（和文件名）
{44851}{44907}以及目标路径和新文件名
{44912}{44970}然后它可以改变文件的路径和名字
{44997}{45122}比如说我可以 `mv dotfiles.md` 到 `foo.md`
{45134}{45181}对吧，虽然没卵用
{45187}{45252}我也可以 `mv` 回去
{45392}{45487}也有一个 `cp` 命令，或者打 `copy`
{45496}{45564}`cp` 让你复制[*]文件，用法很相似的
{45635}{45737}它也接受两个参数，复制源路径和目标路径
{45748}{45778}这些得是完整路径[*]
{45795}{45841}我可以举个栗子，比如说
{45853}{45968}我想 `cp dotfiles.md ` 到 `../food.md`
{45993}{46028}对，是 `food.md`，好嘞
{46052}{46094}如果我现在 `ls ..`
{46095}{46193}看，现在这个目录里有个 `food.md`
{46215}{46265}所以 `cp` 也是接受两个参数
{46266}{46313}而且不必是同一个目录
{46355}{46423}相似地，有个 `rm` 命令
{46424}{46458}让你可以移除（删除）一个文件
{46459}{46535}这里你可以传一个路径，比如说这里
{46536}{46595}我想把 `../food` （.md）删掉
{46609}{46657}你应该注意的是移除
{46658}{46692}特别是在 Linux 上
{46703}{46777}默认的移除是非递归的（recursive）
{46796}{46867}也就是说你不能用 `rm` 移除目录
{46889}{46997}你可以传一个执行递归移除的 `-r` flag
{47010}{47062}然后传递想移除的路径（path）
{47063}{47108}它就会移除目录下的所有内容
{47128}{47272}也有 `rmdir` 命令可以让你移除目录
{47273}{47361}不过只允许移除空目录
{47386}{47417}所以设计它的匠心是
{47418}{47418}这算是给你提供一种安全机制|所以设计它的匠心是
{47419}{47465}这算是给你提供一种安全机制
{47466}{47525}用它你就不会不小心扔掉一堆重要文件
{47559}{47645}最后有一个趁手的小命令
{47646}{47678}是 `mkdir` （make directory）
{47679}{47692}可以让你创建一个新目录（文件夹）|是 `mkdir` （make directory）
{47693}{47723}可以让你创建一个新目录（文件夹）
{47724}{47814}之前说过了，别想着写一些这样的命令
{47815}{47878}这样会给你整出两个目录来
{47885}{47949}一个名为 `My`，一个 `Photo`
{47961}{48024}如果你想创建那种（带空格的）目录
{48025}{48142}要么把空格转义，要么把整个字符串引起来
{48242}{48426}如果你想这些平台上了解在任意一个命令的信息
{48438}{48556}也有个非常奥里给的程序，叫做 `man`
{48566}{48619}意思是手册、说明书（manual pages）
{48620}{48743}这个程序接受其他程序的名字作为一个参数
{48744}{48795}然后显示它的说明书
{48807}{48860}比如说我们可以输入 `man ls`
{48877}{48979}就显示了 `ls` 的说明书
{48980}{49042}你会发现这里显示的内容其实和
{49043}{49105}我们运行 `ls --help` 得到的内容挺相似的
{49119}{49204}不过翻阅起来稍微容易点儿
{49221}{49276}一般来说，翻到底儿瞧瞧
{49277}{49376}你能看到一些提示，基本都是
{49384}{49434}命令示例啊，作者啊，哪儿有更多信息啊
{49435}{49434}这类东西|命令示例啊，作者啊，哪儿有更多信息啊
{49435}{49469}这类东西
{49493}{49540}偶尔有个问题挺捉弄人的
{49545}{49626}啊，直到最近一个版本里他们在底下
{49627}{49646}给加了一行
{49647}{49682}显示按 `Q` 退出
{49683}{49805}他们以前不显示这种「按 `Q` 退出」的
{49814}{49877}如果你不知道这事，还挺难退出来的
{49946}{50068}有个好用的快捷键，`Ctrl` + `L`
{50069}{50153}可以清空终端，让光标回到顶部
{50218}{50302}到现在我们只是分开说了各个程序
{50310}{50418}但是 Shell 真正的本领在于
{50419}{50495}当你把不同的程序结合在一起的时候
{50541}{50628}与只是运行 `cd` 和 `ls` 相比很强
{50629}{50720}也许你想把多个程序串起来
{50721}{50770}也许是想和文件交互
{50771}{50830}或者在各个程序之间操作文件
{50874}{50995}我们借助一个叫流（stream）的概念完成
{51011}{51076}Shell 默认会给我们的每个程序创建
{51086}{51167}我简化一下，就说程序有两个主要的流（stream）
{51179}{51219}默认，程序会有一个输入流（input stream）
{51220}{51259}和一个输出流（output stream）
{51279}{51348}默认的输入流是你的键盘
{51364}{51409}基本上输入流是终端
{51410}{51452}无论你向终端输入什么
{51453}{51493}最后都会传到程序里
{51508}{51572}默认的输出流，就是说
{51573}{51621}每当程序想要输出一些内容时
{51622}{51671}它会输出到这个流里去
{51672}{51723}默认也是终端
{51734}{51792}这就是为什么，当我打入 `echo hello`
{51793}{51842}它就显示回了我的终端里面
{51856}{51994}但是 Shell 提供了重定向这些流的方法
{51995}{52080}把输入和输出都改到程序员指明的地方
{52114}{52301}这里最直接的方式是用大于小于号[*]
{52328}{52373}所以你可以写一些类似这样的事情
{52384}{52429}或者类似那样的事情
{52464}{52596}小于号表示重定向这个程序的输入流
{52597}{52656}变成这个文件的内容
{52694}{52871}大于号表示重定向上述程序的输出流
{52890}{52931}变成输出到这个文件内
{52959}{53013}我们举个例子试一下是什么样
{53026}{53155}如果我 `echo hello`，我想把这个内容
{53156}{53220}存在一个叫 `hello.txt` 的文件里
{53236}{53312}我给了，这是个相对路径（relative path），对吧？
{53313}{53418}这样会在当前目录下创建一个 `hello.txt`
{53426}{53478}至少，理论上来说，它的内容
{53479}{53531}应该是 `hello` 这个单词
{53544}{53635}如果我运行一下，注意，啥都没输出来
{53653}{53710}前一次我运行 `echo hello` 的时候
{53711}{53736}它输出了 `hello` 
{53737}{53843}现在 `hello` 已经跑到 `hello.txt` 里了
{53859}{53936}我可以用这个叫 `cat` 的程序验证
{53937}{54040}`cat` 打印出一个文件的内容
{54051}{54136}所以我可以 `cat hello.txt`
{54145}{54183}哎，它就显示了 `hello`
{54208}{54332}不过 `cat` 也支持这种流的重定向
{54337}{54450}所以我可以说 `cat` 默认只是将输入打印
{54451}{54506}呃，将输入原封不动复制到输出
{54518}{54628}比如，`cat`，我想让你接受 `hello.txt` 的输入
{54654}{54760}在这个例子下，Shell 就会打开 `hello.txt`
{54775}{54881}取出它的内容，设置成 `cat` 的输入
{54882}{54968}然后 cat 就会把这些内容打印到它的输出（流）
{54969}{55059}我没有重定向它，所以是我的终端
{55067}{55130}总之就是它会把 `hello` 打印到输出
{55180}{55235}我也可以同时使用两种（重定向）
{55236}{55367}比如我想复制一个文件但不用 `cp`
{55378}{55496}我可以用这套方法，具体来说
{55497}{55582}实际上我没有告诉 `cat` 任何事
{55583}{55647}我只是命令它说「你正常干活」，对吧
{55648}{55727}`cat` 不知道是不是发生了重定向
{55738}{55810}但是我会告诉 Shell 用 `hello.txt`
{55811}{55837}去作为 `cat` 的输入
{55846}{55907}然后把 `cat` 输出的所有内容存到
{55908}{55951}`hello2.txt` 里面去
{55981}{56035}这次还是没有东西打印到终端上
{56036}{56104}但是如果我运行 `cat hello2.txt`
{56112}{56168}我得到了期望的输出
{56189}{56242}也就是一个源文件的副本
{56303}{56383}也有个东西是双大于号[*]
{56388}{56488}作用是追加（append）而不是覆写（overwrite）[*]
{56505}{56569}你会注意到如果我
{56570}{56654}`cat < hello.txt > hello2.txt` 
{56662}{56714}然后我 `cat hello2.txt` 
{56715}{56755}它仍然只是包含 `hello` 
{56756}{56805}尽管它之前已经有过 `hello` 了
{56822}{56937}如果我给它换成双大于号，意味着追加
{56945}{56981}如果我现在再 `cat` 那个文件
{56982}{57011}它就有了两个 `hello`
{57091}{57151}这些都挺直白的
{57152}{57222}它们仅仅是和文件交互的一些方式
{57230}{57269}不过真正有趣的地方是
{57270}{57333}Shell 附赠给你的一个操作符（operator）
{57334}{57449}叫管道符（pipe），管道符就是一个竖线
{57464}{57528}管道的意思是
{57537}{57635}取左侧程序的输出
{57648}{57714}成为右侧程序的输入
{57813}{57893}这看上去会是什么样子呢
{57903}{57974}来试一个例子，比如说 `ls /`
{57975}{58034}或者 `ls -l /`
{58043}{58080}打印出了一堆东西
{58087}{58176}我就说我想要输出的最后一行
{58190}{58252}有一个命令叫 `tail`
{58263}{58378}它打印出它输入的最后 n 行
{58395}{58503}我可以 `-n1`，所以这就是个叫 n 的 flag
{58509}{58618}如果你想，也可以用更长的 `--lines`
{58626}{58726}这个例子里，它表明输出最后一行
{58737}{58824}我可以把这些连接到一起，也就是说
{58825}{58945}`ls -l / | tail -n1`
{59010}{59093}注意这里 `ls` 并不了解 `tail`
{59094}{59156}`tail` 也不认识 `ls`
{59157}{59192}它们是不同的程序
{59193}{59271}也没有刻意设计和对方相兼容
{59285}{59338}它们只知道要从输入读数据
{59339}{59367}结果写到输出
{59381}{59445}`pipe` 才是把它们连结起来的东西
{59466}{59597}这个例子，我想 `ls` 输出作为 `tail` 输入
{59602}{59672}`tail` 的输出则会输到我的终端
{59673}{59700}因为我没有重定向它
{59718}{59763}我也可以把它重定向，比如说
{59764}{59819}我想输出到 `ls.txt` 里面
{59833}{59904}这里如果我 `cat ls.txt` ，就得到
{59905}{59932}一个期望的输出
{59958}{60029}这意味着你可以做一些很妙的事情
{60030}{60088}我们会在 data wrangling （数据整理）课程
{60089}{60119}里面涉及更多
{60129}{60207}是大约四天之后
{60231}{60297}有一些特别奇妙的工具
{60298}{60357}构建高级管道的时候用得到
{60403}{60481}给你们举一个例子，我们可以做一些操作，比如
{60496}{60640}`curl --head --silent google.com`
{60692}{60744}就只是展示个大概
{60752}{60812}这会给我访问 google.com 时候
{60813}{60863}所有的 HTTP Headers
{60902}{60954}我也可以用管道给它接到
{60972}{61050}`grep --ignore-case`
{61051}{61096}或者说 `-i`
{61106}{61189}比如说我想（匹配）content-length
{61207}{61294}这样就会打印出 content-length header
{61295}{61354}`grep` 是我们之后会讲的程序
{61355}{61444}它支持在输入流里搜索给定关键字
{61483}{61560}我们还可以用管道连到 `cut` 命令
{61574}{61730}它可以接受一个分隔符，我们设成空格
{61731}{61779}我想要第二个字段
{61791}{61844}这样就只输出 content-length（的值）
{61860}{61907}这算是一个很傻的例子
{61908}{62002}只是在命令行里以字节（bytes）的形式
{62003}{62055}提取出 google.com 的内容长度
{62056}{62062}这没啥有用的，但是你可以从中窥见|提取出 google.com 的内容长度
{62063}{62158}这没啥有用的，但是你可以从中窥见
{62159}{62195}把命令链接在一起
{62196}{62325}你可以做很多文本操作的特技
{62326}{62416}而且 `pipe` 不止用于文本数据
{62417}{62486}还可以拿来处理比如图片
{62487}{62604}当你有一个程序可以接受并处理二进制图片
{62605}{62658}然后输出一个二进制图片的时候
{62659}{62724}也可以像这样把它连进去
{62725}{62805}我们之后也会谈到这类例子
{62823}{62881}你甚至可以这样处理视频
{62884}{62999}你可以 - 比如说你家里有个 Chromecast [*]
{63005}{63067}你可以把一个视频文件推流
{63081}{63165}如果把管道的最后一个程序设成
{63166}{63227}Chromecast 的发送程序
{63238}{63285}然后以流的形式传给它视频文件
{63286}{63345}它就推流（或者 HTTP 形式）传到你的 Chromecast
{63479}{63569}在数据整理那节会涉及更多
{63579}{63673}但是我还想说一个事情
{63677}{63883}大概就是怎样更有效地使用终端
{63884}{63991}对于那些已经熟悉终端的同学来说
{63992}{64051}也许会挺有意思
{64088}{64180}我们要先提一个重要话题
{64181}{64270}就是涉及到 Linux 和 MacOS 的时候
{64275}{64344}有一个叫 root （根）用户的概念
{64355}{64451}root 用户类似 Windows 里面的管理员（Administrator）
{64465}{64518}有值为 0 的用户 ID
{64531}{64576}root 是很特别的，因为
{64577}{64653}他被允许在系统上做任意行为
{64685}{64768}就算一个文件是任何人不可读的
{64769}{64820}或者任何人不可写的
{64821}{64871}root 却可以访问这个文件（且读写）
{64883}{64922}他算是一种「超级用户」
{64923}{64954}可以做任何想做的事
{65024}{65124}大多数时候你不会用超级用户操作
{65125}{65157}你不会是 root
{65158}{65216}你应该是一个类似 `Jon`，或者别的啥
{65217}{65216}按你的名字来的用户|你应该是一个类似 `Jon`，或者别的啥
{65217}{65240}按你的名字来的用户
{65241}{65291}你该用这个用户操作（电脑）
{65303}{65413}因为如果一直在 root 下操作电脑
{65421}{65458}如果你运行了错误的程序
{65459}{65509}可能会直接炸了你的电脑
{65520}{65569}你肯定不想这样，对吧
{65599}{65706}但是从今往后你每次想用 root 做点事的话
{65728}{65812}通常这种情况是，用一个叫 `sudo` 的程序
{65827}{65958}S-U-D-O 或者说 do as su
{65969}{66031}这里 su 就是 Super User（的缩写）
{66038}{66127}这是一个用超级用户运行程序的办法
{66155}{66217}通常 `sudo` 的用法是
{66218}{66311}你先打 `sudo` 再接上平常调用的命令
{66312}{66428}它就会以 root 身份运行这个命令
{66509}{66579}你在哪里可能要用到这种东西呢
{66580}{66661}呃，有一个特别的……
{66662}{66722}在你的电脑上有很多特别的文件系统
{66723}{66798}其中有一个特定的叫 `sysfs`
{66810}{66870}如果你 `cd` 到 `/sys`
{66887}{66947}这整个儿都是新世界
{66957}{67071}这个文件系统不是真实存在的文件

【599】哦抱歉，还有一件事情

如果它显示的是一个横杠（-）

意思就是你没有对应的权限，对吧

比如说它显示 r-x

那就意味着你有读和执行权限，但没有写权限

还有很多别的趁手的工具

有一个是 `mv` 命令

如果我 `cd` 回 `missing semester`

在这里我能用 `mv` 重命名文件

【610】它接受两个路径（path）（作为参数）

先是原有的路径（path），然后是新的

这意味着 `mv` 既可以让你重命名一个文件

如果你只想原地重命名文件的话

或者把文件移动到一个不同的目录里

原理就是你给出现有文件的路径（和文件名）

以及目标路径和新文件名

然后它可以改变文件的路径和名字

比如说我可以 `mv dotfiles.md` 到 `foo.md`

对吧，虽然没卵用

我也可以 `mv` 回去

也有一个 `cp` 命令，或者打 `copy`

`cp` 让你复制[*]文件，用法很相似的
*对应 MacOS 的拷贝（Copy）而非 MacOS 的复制（Duplicate）

它也接受两个参数，复制源路径和目标路径

这些得是完整路径[*]
*意味着你需要明确指定具体文件路径，这个命令没有搜索功能

【628】我可以举个栗子，比如说

我想 `cp dotfiles.md ` 到 `../food.md`

对，是 `food.md`，好嘞

如果我现在 `ls ..`

看，现在这个目录里有个 `food.md` 

所以 `cp` 也是接受两个参数

而且不必是同一个目录

相似地，有个 `rm` 命令

让你可以移除（删除）一个文件

这里你可以传一个路径，比如说这里

我想把 `../food` （.md）删掉

你应该注意的是移除

【639】特别是在 Linux 上

默认的移除是非递归的（recursive）

也就是说你不能用 `rm` 移除目录

你可以传一个执行递归移除的 `-r` flag

然后传递想移除的路径（path）

它就会移除目录下的所有内容

也有 `rmdir` 命令可以让你移除目录

不过只允许移除空目录

【649】所以设计它的匠心是

这算是给你提供一种安全机制

用它你就不会不小心扔掉一堆重要文件

【652】最后有一个趁手的小命令

是 `mkdir` （make directory）

可以让你创建一个新目录（文件夹）

之前说过了，别想着写一些这样的命令

这样会给你整出两个目录来

一个名为 `My`，一个 `Photo`

【660】如果你想创建那种（带空格的）目录

要么把空格转义，要么把整个字符串引起来

如果你想这些平台上了解在任意一个命令的信息

也有个非常奥里给的程序，叫做 `man`

意思是手册、说明书（manual pages）

这个程序接受其他程序的名字作为一个参数

然后显示它的说明书

比如说我们可以输入 `man ls`

就显示了 `ls` 的说明书

你会发现这里显示的内容其实和

我们运行 `ls --help` 得到的内容挺相似的

不过翻阅起来稍微容易点儿

一般来说，翻到底儿瞧瞧

【678】你能看到一些提示，基本都是

命令示例啊，作者啊，哪儿有更多信息啊

这类东西

偶尔有个问题挺捉弄人的

啊，直到最近一个版本里他们在底下

给加了一行

【683】显示按 `Q` 退出

他们以前不显示这种「按 `Q` 退出」的

如果你不知道这事，还挺难退出来的

有个好用的快捷键，`Ctrl` + `L`

可以清空终端，让光标回到顶部

到现在我们只是分开说了各个程序

但是 Shell 真正的本领在于

当你把不同的程序结合在一起的时候

与只是运行 `cd` 和 `ls` 相比很强

也许你想把多个程序串起来

也许是想和文件交互

【698】或者在各个程序之间操作文件

我们借助一个叫流（stream）的概念完成

Shell 默认会给我们的每个程序创建

我简化一下，就说程序有两个主要的流（stream）

默认，程序会有一个输入流（input stream）

和一个输出流（output stream）

默认输入流里的内容来自你的键盘

基本上输入流是终端

【707】无论你向终端输入什么

最后都会传到程序里

默认的输出流，就是说

每当程序想要输出一些内容时

它会输出到这个流里去

默认也是终端

这就是为什么，当我打入 `echo hello`

它就显示回了我的终端里面

但是 Shell 提供了重定向这些流的方法

把输入和输出都改到程序员指明的地方

这里最直接的方式是用大于小于号[*]
*也就是所谓的「尖角括号」

【720】所以你可以写一些类似这样的事情

或者类似那样的事情

小于号表示重定向这个程序的输入流

变成这个文件的内容

大于号表示重定向上述程序的输出流

变成输出到这个文件内

【727】我们举个例子试一下是什么样

如果我 `echo hello`，我想把这个内容

存在一个叫 `hello.txt` 的文件里

我给了，这是个相对路径（relative path），对吧？

这样会在当前目录下创建一个 `hello.txt`

至少，理论上来说，它的内容

应该是 `hello` 这个单词

如果我运行一下，注意，啥都没输出来

前一次我运行 `echo hello` 的时候

它输出了 `hello` 

【739】现在 `hello` 已经跑到 `hello.txt` 里了

我可以用这个叫 `cat` 的程序验证

`cat` 打印出一个文件的内容

所以我可以 `cat hello.txt`

哎，它就显示了 `hello`

不过 `cat` 也支持这种流的重定向

所以我可以说 `cat` 默认只是将输入打印

呃，将输入原封不动复制到输出

比如，`cat`，我想让你接受 `hello.txt` 的输入

在这个例子下，Shell 就会打开 `hello.txt`

取出它的内容，设置成 `cat` 的输入

然后 cat 就会把这些内容打印到它的输出（流）

我没有重定向它，所以是我的终端

总之就是它会把 `hello` 打印到输出

我也可以同时使用两种（重定向）

【759】比如我想复制一个文件但不用 `cp`

我可以用这套方法，具体来说

实际上我没有告诉 `cat` 任何事

我只是命令它说「你正常干活」，对吧

`cat` 不知道是不是发生了重定向

但是我会告诉 Shell 用 `hello.txt`

去作为 `cat` 的输入

然后把 `cat` 输出的所有内容存到

`hello2.txt` 里面去

这次还是没有东西打印到终端上

但是如果我运行 `cat hello2.txt`

我得到了期望的输出

也就是一个源文件的副本

也有个东西是双大于号[*]
*这里不是指中文的书名号

作用是追加（append）而不是覆写（overwrite）[*]
*追加指向文件尾继续添加内容；覆写则清空文件

你会注意到如果我

`cat < hello.txt > hello2.txt` 

【778】然后我 `cat hello2.txt` 

它仍然只是包含 `hello` 

尽管它之前已经有过 `hello` 了

如果我给它换成双大于号，意味着追加

如果我现在再 `cat` 那个文件

它就有了两个 `hello`

这些都挺直白的

它们仅仅是和文件交互的一些方式

不过真正有趣的地方是

Shell 附赠给你的一个操作符（operator）

叫管道符（pipe），管道符就是一个竖线

管道的意思是

【790】取左侧程序的输出

成为右侧程序的输入

这看上去会是什么样子呢

来试一个例子，比如说 `ls /`

或者 `ls -l /`

打印出了一堆东西

我就说我想要输出的最后一行

有一个命令叫 `tail`

它打印出它输入的最后 n 行

我可以 `-n1`，所以这就是个叫 n 的 flag

如果你想，也可以用更长的 `--lines`

这个例子里，它表明输出最后一行

我可以把这些连接到一起，也就是说

`ls -l / | tail -n1`

【805】注意这里 `ls` 并不了解 `tail`

`tail` 也不认识 `ls`

它们是不同的程序

也没有刻意设计和对方相兼容

它们只知道要从输入读数据

结果写到输出

`pipe` 才是把它们连结起来的东西

这个例子，我想 `ls` 输出作为 `tail` 输入

`tail` 的输出则会输到我的终端

【816】因为我没有重定向它

我也可以把它重定向，比如说

我想输出到 `ls.txt` 里面

这里如果我 `cat ls.txt` ，就得到

一个期望的输出

这意味着你可以做一些很妙的事情

我们会在 data wrangling （数据整理）课程

里面涉及更多
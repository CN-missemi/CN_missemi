{1}{1}29.970030
{40}{137}好的，感谢大家的到来。
{138}{262}这门课是《计算机科学教育中缺失的一课》[*]
{263}{319}至少这是我们给这门课起的名字
{320}{354}如果你来这儿不是上这门课的
{355}{393}那你走错地儿了
{394}{514}先说一下，我们大约得讲一个小时
{560}{677}我想先和你们谈一下为什么我们开这门课
{678}{869}这门课源于 Anish, Jose 和我在做 MIT 很多课程的 TA[*] 时'
{870}{958}观察到的一个现象：
{959}{1050}基本上，我们这些计算机科学家都清楚
{1051}{1162}计算机很善于处理重复性任务，把事情自动化
{1163}{1265}但是我们常常意识不到有很多工具
{1266}{1357}可以让我们的开发过程更好
{1358}{1437}我们用起电脑来可以更有效率
{1446}{1548}因为我们可以将电脑作为手上的一个利器
{1549}{1673}而不仅仅是用于建个网站或者写个软件这类事情
{1674}{1805}这门课就是试着告诉你这点，并做点儿尝试
{1806}{1885}介绍给你一些这样的工具，你用起来之后
{1886}{2037}可以在你生活、研究和学习上发挥很大的作用
{2056}{2316}在这门课里我们不仅想教你一些你有大致了解的工具
{2317}{2435}还希望教给你一点儿你之前不知道的工具
{2436}{2518}还有如何将这些工具结合起来
{2519}{2675}制造出一些你可能都想象不到的、更强大的东西
{2676}{2744}你们应该知道这门课的结构
{2745}{2828}将是一系列，总共 11 次的一小时课
{2829}{2937}每个都涉及一个特定的主题
{2938}{3026}你还可以去看看课程网站
{3027}{3137}上面列出了课程列表和每场的日期
{3138}{3204}它们大致上将互相独立
{3205}{3293}所以你可以只来听你感兴趣的那些
{3294}{3385}但是，我们会假设你一直在跟着上课
{3386}{3446}所以我们讲到后面的时候，就比如说
{3447}{3540}我就不会一遍遍地教 bash 怎么用了
{3584}{3857}上课的时候，我们也会立马把讲义、课程录像发到网上
{3858}{4012}当然我们现在还没上传，显然得等到上完课之后
{4013}{4181}将由我（Jon），Anish ，他坐在那个位置，还有 Jose 来上课
{4182}{4273}Jose[*] 今天没到场，不过他会上明天的课
{4290}{4387}提醒一下，在这门仅仅 11 × 1 小时的课里
{4388}{4460}我们会试图涉及很大的范围
{4461}{4563}所以我们的节奏相对会快些
{4564}{4709}但是如果你觉得跟不上了，别介意打断我们
{4710}{4786}如果你觉得有什么东西值得多花点时间讲的
{4787}{4816}也请告诉我们
{4817}{4865}有问题也请打断我们
{4866}{5056}并且每次下课之后我们都在 32 号楼 9 层有办公时间
{5057}{5114}是在计算机科学楼，也就是 Stata Center （史塔特科技中心）[*]
{5122}{5247}如果你来 Gates Tower 九楼的休息室 [*]
{5248}{5377}你可以来做做我们每节课后给的练习
{5378}{5509}或者直接问我们别的问题，有关课上讲的内容的
{5510}{5593}或者怎么高效地利用电脑
{5650}{5763}因为我们只有很有限的时间
{5764}{5875}我们不可能讲到所有工具的所有细节
{5876}{6037}只聚焦有趣的工具和怎么使用它们
{6038}{6111}我们也没必要深挖那些细节
{6112}{6196}搞明白它们是怎么运行的，或者使用上的小细节
{6197}{6290}但是如果你对这些有问题，请来问我们
{6291}{6384}讲到的绝大部分工具的是我们用了成年累月的东西
{6385}{6442}我们也许能给告诉你拿这些工具
{6443}{6507}能做什么额外的有趣的活计
{6508}{6584}要利用我们在这儿上实体课的优势
{6615}{6739}我不太想说「让我们开足马力冲吧」
{6740}{6852}但是这门课要讲的，今天这一讲要讲的
{6853}{6910}是很多基础的东西
{6911}{6988}我们也会假设后面的课里你们都了解了这些
{6989}{7059}比如怎么用 Shell 和你的终端（Terminal）
{7060}{7137}对于不熟悉这些的，我马上会解释这些是啥
{7138}{7253}然后我们就会很快速地狂奔到更高级的工具上
{7254}{7280}讲讲怎么用它们
{7281}{7395}现在已经可以从课程讲义上看到所有要讲的主题
{7423}{7572}所以我们今天的课要讲 Shell
{7573}{7722}Shell 将会是你和电脑交互的最主要方式之一
{7723}{7856}一旦你想脱离开那些可视化的界面让你做的
{7857}{7901}然后去做点别的
{7902}{8037}其实可视化界面[*]挺受限的
{8038}{8108}因为它们只让你做一些按钮啊，
{8109}{8161}滑条啊，输入框啊能按出来，输进去的事情
{8162}{8311}但这些基于文本的工具经常是能互相耦合的
{8312}{8416}也有无数种方式能把它们结合起来
{8417}{8459}或者写个程序让它们自动化
{8460}{8566}这就是这门课介绍命令行工具
{8567}{8600}和基于文本的工具的理由
{8611}{8717}Shell 则是你去做这些活计的地方
{8718}{8797}对于不熟悉 Shell 的同学们
{8798}{8879}大多数平台都会提供某种 Shell[*]
{8880}{8955}在 Windows 上基本是 Powershell[*]
{8956}{9030}而且也有其他 Shell 可以用
{9031}{9137}在 Windows 和 Linux 上你会找到成堆的终端（Terminal）
{9138}{9219}这些是能显示 Shell 的（文本）窗口
{9220}{9298}你能找到很多不同种类的 Shell
{9299}{9412}其中最普遍的是 bash，或者叫 born again shell
{9413}{9570}因为它非常普遍，我们这些课里就主要用它了
{9578}{9662}如果你用 MacOS，你大概也有 bash
{9663}{9708}如果你打开终端（Terminal）应用看看
{9709}{9749}也许还是个旧版本的 (‾◡◝)
{9750}{9854}如果你想用哪个平台上课，随意
{9855}{9906}不过注意，在我们教课的时候
{9907}{9986}大部分内容会是以 Linux 为中心
{9987}{10061}尽管大部分工具在所有平台上都能用
{10062}{10230}如果你想安装一个终端和 Shell，却不知道该咋办
{10231}{10308}我们很乐意在办公时间教你
{10309}{10419}或者去网上搜搜也挺容易
{10420}{10523}比如输入你的平台，加上像是终端啊，这种关键词
{10524}{10559}就能找到教程
{10578}{10722}好，当你打开一个终端的时候
{10723}{10794}你会看到一个长得像这样的东西
{10795}{10904}也就是说通常是在顶上有单单一行
{10905}{10971}这个一般就叫「命令行提示符」（Shell Prompt）
{10972}{11038}你可以看到我的命令行提示符看起来像这样
{11039}{11128}这里是我的用户名，还有我用的机器的名字
{11129}{11189}还有我当前所在路径（path）
{11190}{11249}我们晚一会儿再说说路径（path）
{11250}{11369}然后就是这个闪烁的东西，它在要求我输点啥
{11370}{11484}这个就是「命令行提示符」（Shell Prompt），在这里告诉 Shell 你想做什么
{11485}{11595}你可以自由地自定义这个提示符
{11596}{11629}所以当你在你机器上打开它的时候
{11630}{11671}它可能不会长得和这个一样
{11672}{11790}如果你设置了一下，那可能会是这样
{11791}{11862}或者会是各种千奇百怪的样子
{11885}{11984}这节课我们不会讲太多关于自定义 Shell 的东西
{11986}{12031}我们晚些时候再说
{12032}{12142}我们只讲怎么用 Shell 去做有用的事
{12192}{12340}这是你电脑上和 Shell 交互的主要文本界面
{12341}{12412}你可以在命令行提示符上写命令
{12413}{12498}命令相对都是一些直白的东西
{12499}{12622}比如，通常是带着参数（argument）执行程序
{12625}{12656}大概类似这样的事情
{12657}{12743}嗯，有一个我们可以运行的程序是 `date`
{12744}{12785}输入 `date` 然后按一下回车
{12786}{12862}不出所料，它会告诉你日期和时间
{12863}{12954}你也可以带着参数（arguments）执行一个程序
{12955}{13069}这是一种修改程序行为的方式
{13084}{13159}比如说有一个程序叫 `echo`
{13160}{13258}`echo` 只是打印出你传给它的参数
{13259}{13351}而参数呢，则是一些紧随程序名后面的
{13352}{13390}用空格分隔开的东西
{13391}{13507}我们可以打出 `Hello` 然后它就会回显 `Hello`
{13508}{13567}也许你不会觉得很惊奇
{13568}{13634}但这是参数最基础的运用了
{13645}{13697}你会注意到一件事就是
{13698}{13761}我提到参数是被空格分隔的
{13762}{13867}你也许会好奇，如果我想传一个多单词的参数会怎样
{13868}{13905}你可以拿引号把东西括起来
{13906}{14030}所以你可以像这样 `echo Hello` 空格 `world`
{14031}{14094}这样 `echo` 程序会收到一个
{14095}{14210}字符串参数 `"Hello world"`，中间还有个空格
{14229}{14291}呃，你也可以用单引号做这件事情
{14292}{14363}单双引号的区别
{14364}{14442}我们等到讲 bash scripting 的时候再说
{14475}{14542}你也可以用单转义字符（Escape character）
{14555}{14641}比如这样，`Hello\ World`
{14642}{14689}这样也能正常起作用
{14711}{14907}关于如何给参数、变量转义，解析和加括号
{14908}{14964}我们之后会涉及到
{14965}{15053}不过别放在心上，这都是小菜一碟
{15054}{15160}只要记好用空格分隔参数就行
{15161}{15208}因此如果你想做什么事情
{15209}{15272}比如建一个叫 my photos 的目录
{15273}{15370}你不能只是输入 `mkdir my photos`
{15371}{15405}这样系统会建立两个目录
{15406}{15456}一个叫 my，一个叫 photos
{15457}{15493}显然这不是你想要的
{15556}{15669}现在你也许会好奇一点
{15670}{15737}Shell 是怎么知道这些程序在哪儿的
{15738}{15818}当我输入 `date` 或者 `echo` 的时候
{15819}{15929}Shell 怎么知道这些程序要做什么
{15937}{16004}答案就是你的程序，呃
{16005}{16064}就是你的电脑，有很多内置（Built-in）程序
{16065}{16102}它们是系统自带的
{16103}{16223}就比如你的机器可能内嵌了终端程序
{16224}{16395}或者比如 Windows Explorer，或者某些浏览器
{16396}{16491}也内嵌了很多围绕终端工作的程序
{16492}{16571}这些程序位于你的文件系统（File System）
{16572}{16741}而 Shell 有办法知道某个程序存放在哪
{16742}{16810}说白了就是它有一个搜索程序的方法
{16811}{16985}这借助一个叫寒境，啊，环境变量的东西完成
{16986}{17123}环境变量就类似编程语言里的变量
{17124}{17237}说白了 Shell，或者就说 bash 本身
{17238}{17297}就是一种程序设计语言
{17298}{17447}你输入的提示符（Prompt）不仅能带参运行程序
{17448}{17588}你也可以写出 while 循环，for 循环，条件
{17589}{17605}等等所有这些
{17606}{17668}甚至可以定义函数，甚至变量
{17669}{17715}所有这些你能在 Shell 里做的事情
{17716}{17825}关于 Shell Scripting 的下一讲会有涉及
{17861}{17981}现在我们先关注环境变量（Environment Variable）
{17982}{18028}环境变量是 Shell 本就设定好的
{18029}{18118}无论何时启动 Shell 都无须重新设置
{18119}{18170}有一堆东西会被设定好
{18171}{18302}比如哪里是 home 目录，你的用户名是什么
{18303}{18394}也有一个是为了做这件事情的
{18395}{18454}那就是 `PATH` 变量
{18458}{18528}当我输入 `$PATH`
{18529}{18638}这里会输出一些我电脑上的目录
{18639}{18738}这些目录是 Shell 寻找程序时所查找的目录
{18759}{18817}也许你会觉得
{18818}{18944}这一大行被冒号分隔的东西看起来很费眼睛
{18945}{19003}但重要的事情在于
{19004}{19083}当你输入一个程序名称的时候
{19084}{19203}你的电脑会在这个列表中的每个目录里查找
{19204}{19419}名字与你所输入指令相同的一个程序或一个文件
{19444}{19505}刚刚的例子里当我试图运行 `date` 或者 `echo` 的时候
{19506}{19568}电脑会遍历这些目录
{19569}{19666}直到它找到一个包含 `date` 或者 `echo` 的程序的目录
{19667}{19696}然后电脑就会运行找到的这个程序
{19712}{19773}如果我们想要知道电脑具体运行了哪一个目录里的程序
{19774}{19844}我们有一个叫做 `which` 的指令，它可以整这个活
{19845}{19906}所以我现在可以输入 `which echo`
{19907}{19949}然后它就会告诉我
{19950}{20025}如果我要运行一个叫 `echo` 的程序
{20026}{20063}我就会运行——这个东西
{20100}{20194}这里有必要插入讲一下什么是路径（path）
{20207}{20334}路径是用来描述你的计算机里的文件的位置的东西
{20335}{20403}在 Linux 或者 Mac OS 上
{20404}{20509}路径被用一连串的斜杠分隔
{20520}{20669}你在这里可以看到，这个路径的起点在根目录
{20670}{20733}目录的开头有斜杠来指示它开始的地方：
{20734}{20824}整个文件系统的最顶层
{20840}{20946}然后我们进到叫做 `usr` 的目录
{20961}{21026}然后进到叫做 `bin` 的目录
{21027}{21086}然后找到名叫 `echo` 的文件
{21111}{21233}在 Windows 里，这样的路径一般以反斜杠而非斜杠分隔
{21245}{21316}在 Linux 和 MacOS 上
{21317}{21383}所有东西都在一个叫根（root）的空间下面的某处
{21384}{21484}所以所有以斜杠开头的路径都是绝对路径
{21491}{21617}在 Windows 下，每一个分区都有一个根
{21618}{21754}所以你可能见过类似 `C:\` 或者 `D:\` 的东西
{21755}{21905}所以 Windows 里每一个驱动器（硬盘）下
{21906}{21973}都有独立的一套文件系统的层次结构
{21974}{22017}相比之下，在 Linux 和 MacOS 下
{22018}{22077}所有东西都在一个命名空间里
{22123}{22193}你会注意到我提到了“绝对路径”这个词
{22194}{22253}可能有人会不知道这是什么意思，解释一下：
{22254}{22464}绝对路径是可以绝对准确地确定一个文件的位置的路径
{22465}{22501}所以在屏幕上这个例子里面
{22502}{22595}这行东西唯一地指向一个叫 `echo` 的独一无二的文件
{22596}{22691}它表示了到这个文件的完整路径
{22719}{22818}但是也有一种称作“相对路径”的东西
{22828}{22963}“相对路径”是相对于你当前所在位置的路径
{22993}{23083}所以要找出我们当前的位置在哪里
{23084}{23159}我们可以输入 `pwd`，意思是
{23169}{23219}当前工作目录（present working directory）……
{23220}{23237}当前（present）？
{23253}{23284}打印工作目录（print working directory）
{23321}{23363}所以如果我输入 `pwd`
{23364}{23474}它就会输出当前我所在的目录路径
{23492}{23602}我现在的位置是 `root` 下的 `home` 文件夹
{23603}{23676}其中的 `jon` 里，其中的 `dev` 里
{23677}{23713}然后再叭啦叭啦叭啦这一串的里面
{23714}{23862}我可以选择改变我的当前工作目录
{23863}{23968}所有相对路径都是相对当前工作目录的
{23969}{24036}基本上也就是说是相对于你所在的地方
{24058}{24175}举个例子，我可以输入 `cd /home`
{24176}{24229}`cd` 是改变目录（change directory）的意思
{24230}{24321}这是改变当前工作目录的一种方法
{24329}{24386}在这个例子里，我把当前工作目录转到 `home`
{24387}{24498}你可以看到我的 Shell 的提示也改变了
{24499}{24552}它说我在 `home` 里面
{24553}{24643}它只会给出路径的最后一段的名称
{24645}{24758}不过也可以设置下，使得它总能显示当前的完整路径
{24813}{24877}如果现在我再输入 `pwd`
{24878}{24937}它会告诉我我在 `/home` 里
{24959}{25054}同时也有一对特殊的目录
{25060}{25122}`.`（点） 和 `..`（点点）
{25138}{25313}点表示当前目录，而点点表示上一层目录
{25314}{25402}通过这种方式，你可以容易地访问整个系统
{25409}{25502}举个例子，如果我输入 `cd ..`
{25525}{25582}它会告诉我我现在在 `/`
{25592}{25645}所以我现在在整个文件系统的根
{25646}{25720}我刚刚在 `/home`，现在在 `/` 了
{25774}{25868}然后如果我输入 `pwd`，运行结果看起来也很对`
{25903}{25998}我也可以使用相对路径来向下访问文件系统
{25999}{26071}所以我可以输入 `cd ./home`
{26072}{26216}然后就会 cd 到当前的目录下的 `home` 目录
{26258}{26315}这个操作就把我带回到了 `/home` 里
{26316}{26408}然后如果我现在试着再输入一次 `cd ./home`
{26409}{26465}它会告诉我当前目录下没有 `home` 目录
{26466}{26557}我现在在刚刚 cd 进的文件夹里
{26701}{26843}一路 cd 进刚刚我在的那一个文件夹里
{26879}{26937}就可以用相对路径
{26962}{27145}我也可以用类似点点，点点，点点……的操作
{27146}{27208}来回到我的文件系统的比较靠近根的位置
{27209}{27309}这个应该是回到了根目录
{27310}{27366}然后里面有一个 `bin` 目录
{27367}{27426}然后在里面有一个 `echo` 文件
{27427}{27477}所以我就可以输一个 `world`
{27483}{27551}然后这就会运行 `bin` 目录下的 `echo` 程序
{27568}{27609}好的，所以靠这个办法
{27610}{27692}你可以构建路径到你的文件系统的任意地方
{27717}{27806}有的时候你想要用绝对路径，有的时候你想要用相对路径
{27807}{27872}一般你就用短的那一种
{27887}{28018}但是比如说你想要运行一个或者写一个程序
{28019}{28111}它调用运行了类似 `echo` 或者 `date` 的程序
{28112}{28200}你希望它可以在任何地方都能跑起来
{28201}{28296}那要么你就只给出这个要被运行的程序的名字
{28297}{28323}像 `echo` 或者 `date`
{28324}{28422}然后让 Shell 用 `path` 自己去找出它们在哪里
{28423}{28472}要么你就给出被调用运行的程序的绝对路径
{28488}{28526}因为如果你给出一个相对路径
{28527}{28651}那可能我在我的 home 目录运行，你在别的什么目录运行
{28654}{28700}可能我这里能跑起来，你那里就不能跑起来了
{28756}{28885}um，总的来说，我们运行程序的时候
{28899}{28980}程序会默认在当前目录运行
{28995}{29064}除非我们再给程序一个参数
{29083}{29120}其实运行在默认目录是相当方便的
{29121}{29215}因为这意味着我们不必给出复杂的完整路径
{29223}{29327}用到的只是文件名或者是当前目录
{29345}{29483}搞清楚我们当前目录里有啥很关键
{29493}{29518}然后我们可以发现
{29519}{29582}`PWD` 命令能输出我们当前所在的目录
{29583}{29747}有个叫 `ls` 的命令能列出当前目录下的文件
{29762}{29802}如果我在这打上 `ls`
{29815}{29901}这就是当前目录下所有的文件，对吧
{29902}{30002}这是种方便在文件系统中快速查找的方法
{30051}{30128}你可以看到，如果我输入 `cd ..`
{30129}{30156}然后执行 `ls` 指令
{30164}{30246}会输出上一级目录下的文件
{30278}{30418}我也可以 `ls` 一个 `..` 的参数
{30419}{30451}就像我给它一个路径一样
{30458}{30504}然后他就会 `ls` 上一级目录
{30505}{30542}而不是当前我所处的目录
{30544}{30593}或者直接 `ls` 上一级目录
{30660}{30719}如果我直接返回到根目录
{30720}{30786}你会发现根目录里有不同的路径
{30811}{30881}在这你可能不知道一个便捷的小技巧
{30882}{30981}你可以用两个特殊符号做点别的事
{30982}{31053}第一个，`~`
{31054}{31138}`~` 可以把你带回用户目录
{31139}{31221}所以说 `~` 总是指向用户目录
{31222}{31291}你可以通过它到达用户目录相关的目录
{31292}{31470}所以我可以输入 `cd ~/dev/pdos/classes/missing-semester`
{31471}{31508}现在我就在这个目录里了
{31509}{31602}因为 `~` 在这代表 `/home/jon`
{31625}{31791}尤其在 `cd` 命令中还有一个很方便的参数 `-`
{31799}{31843}如果你运行 `cd -`
{31850}{31933}他会将当前目录跳转到你所处的上一个目录
{31954}{31974}所以如果我运行 `cd -`
{31975}{32003}我就回到了根目录
{32026}{32065}如果我再执行一遍 `cd -`
{32110}{32157}我就回到了 `missing-semester` 这个文件夹
{32158}{32180}由此可见
{32181}{32240}这让你很方便的在两个不同文件夹之间切换
{32349}{32433}关于 `ls` 或者 `cd` 命令
{32444}{32501}还有一些你可能不知道的参数
{32531}{32545}目前为止
{32546}{32620}我们除了给出路径以外啥都没做
{32635}{32672}但是如果你想自己探索的话`
{32673}{32732}你可以首先考虑 `ls` 一个路径
{32749}{32858}大多数程序采用一些 `flag`（标志）
{32859}{32898}和 `option`（选项）等作为参数
{32910}{32967}这些一般都以半角字符 `-` 开头
{32988}{33130}其中大多数程序都涵盖了 `--help` 这个函数
{33151}{33178}举个例子
{33181}{33226}如果你执行 `ls --help`
{33227}{33397}它会很贴心地输出一大堆关于 `ls` 指令的帮助信息
{33408}{33491}这些信息阐述了 `ls` 的用途
{33492}{33547}并且你可以给出的一堆 `option`
{33548}{33596}和一堆文件
{33609}{33674}阅读用法的时候
{33696}{33797}`...` 代表不填或一个或更多
{33798}{33864}`[]` 代表可 `option`
{33878}{33954}所以现在这里给出了一些 `option`
{33955}{33995}和一些可选的文档
{34021}{34086}显然它在告诉你这个程序会做什么
{34087}{34203}并且特指了一些 `flag` 和 `option`
{34204}{34337}通常把一个 `-` 加上一个字母叫做一个 `flag`（选项）
{34338}{34443}或者把后面不跟没有数值的叫做 `flag`
{34444}{34503}而后面跟有一个值的叫做一个 `option`
{34504}{34588}举个例子，`-a` 和 `--all` 都叫 `flag`
{34687}{34783}而 `-C` 或 `--color` 都是 `option`
{34821}{34908}如果你向下翻得够远
{34928}{35056}你能发现一个 `-L` 的 `flag`
{35057}{35092}啊，翻车了
{35113}{35322}这个 `-L` 的 `flag` 是采用长列表格式[*]
{35334}{35393}通常来说，这很方便
{35403}{35443}我们来看看它到底能做什么
{35457}{35510}如果我执行 `ls -L`
{35543}{35607}它仍然会输出当前路径下的一长串文件
{35608}{35691}但是给出了关于这些文件更多的信息
{35706}{35774}你会发现你以后会经常用到这个 `flag`
{35785}{35899}因为它多给你的信息能提供很大的便利
{35963}{36038}让我们看看多出来的信息都有什么
{36158}{36271}首先，前面带 `d` 的这些条目
{36272}{36314}代表这里面还有些东西
{36329}{36440}举个例子，这个 `_data` 的条目就是一个目录
{36441}{36553}但 `404.html` 不是个目录，而是一个文件
{36568}{36762}后面的字符代表文件被授予的权限
{36775}{36914}这就像我们之前看到的，我并不能 `cd` 一个指定的文件
{36915}{36973}或者我 `cd` 不了一个目录
{36974}{37064}这都是由特定文件或目录的权限决定的
{37090}{37146}阅读这一串字母的方法如下
{37147}{37222}把后面的 9 个字母分成三组
{37223}{37308}第一组代表权限被授予给了文件的所有者
{37309}{37385}你可以看到这些文件的所有者都是我
{37426}{37591}第二组的三个字母代表给拥有这些文件的用户组的权限
{37592}{37686}也就是 `jon` 这个用户组
{37702}{37939}最后的一组字符是给非所有者的其他人的权限
{37973}{38039}这个目录某种意义上来说有些“无聊”
{38053}{38108}因为这个目录的所有者是我
{38109}{38203}但是如果我们执行 `cd /` 回到根目录
{38204}{38333}然后再 `ls -L`，会发现所有文件和目录的所有者都是 `root`
{38350}{38426}我们回到什么是根用户来
{38433}{38518}你能发现这里的权限有点意思
{38519}{38653}这一组中的三个字母代表读取、写入和执行
{38689}{38805}这些对于文件和目录又有什么不同呢
{38824}{38875}对于文件，这就很显而易见了
{38876}{38937}如果你有读取权限
{38938}{38982}你就可以读取文件的内容
{38983}{39050}如果你有文件的写入权限
{39051}{39181}你就可以保存，写入甚至是重写一遍
{39182}{39272}如果你有一个 `x`
{39273}{39319}你就可以执行这个文件
{39338}{39451}如果我们运行 `ls -l /bin`
{39452}{39538}啊，我说我是乱打的啊，应该是 `ls -l /usr/bin`
{39540}{39708}你会发现即使不是所有者都有全部的执行权限
{39709}{39782}这是因为，举例来说
{39783}{39840}我们希望这个电脑上的所有用户都能运行显示程序
{39852}{40018}没有任何理由只让某一用户能运行
{40048}{40145}对于目录来说，这些权限会显得稍有不同
{40162}{40329}所以读取权限允许你看这个文件夹里有哪些东西
{40348}{40426}你可以把读取权限当成阅读这个目录的清单
{40427}{40468}这个权限允许你列出目录里的内容
{40491}{40672}目录的写入权限就是你是否能够重命名、新建或者删除里面的文件
{40705}{40755}所以这也是一种权限
{40756}{40927}但是要注意到，这意味着如果你有文件的写入权限
{40928}{41019}但是你没有这个目录的写入权限
{41020}{41061}你就不能删除这个文件
{41062}{41128}即使你清空了文件的内容，你也不能删除它
{41129}{41225}因为这样做的话需要目录的写入权限
{41244}{41356}最后，目录的执行权限困扰了很多人
{41373}{41465}目录的执行权限通常来讲就是搜索
{41474}{41557}但这并不是一个容易理解的名字
{41558}{41679}它意味着你能不能进入这个目录
{41715}{41768}如果你想找个文件
{41769}{41862}或者打开这个目录、读取这个目录还是写入这个目录
{41878}{41959}甚至基础如 `cd` 这个目录
{41960}{42136}你都必须有所有父目录及其自身的执行权限
{42170}{42359}举例来说，如果我想访问 `/usr/bin` 下的文件， 例如 `echo`
{42369}{42464}我必须拥有路径上所有目录的执行权限
{42465}{42519}并且还得拥有 `bin` 这个目录的执行权限
{42535}{42648}如果我没有全部的这些执行权限，我就无法访问这个文件
{42679}{42761}因为我无法通过任何方法进入这个目录
{42825}{42923}另外你可能还会遇到另外一些字节
{42924}{42985}你可能会碰到 `s` 或 `t`
{42986}{43039}在这些清单里你可能还会看见 `l`
{43052}{43118}如果你对这些感到好奇的话，我们可以在工作时间聊聊
{43132}{43238}这些大多数对你在这堂课上学的东西都不是那么重要
{43267}{43314}但是了解它们会提高你的便利程度
{43315}{43386}所以如果你们实在好奇，你们可以自己查找相关资料
{43387}{43443}或者在工作时间来问我们
{43488}{43568}了解另外一些程序也能方便你自己
{43569}{43618}哦抱歉，还有一件事情
{43619}{43650}如果它显示的是一个横杠（-）
{43651}{43710}意思就是你没有对应的权限，对吧
{43715}{43790}比如说它显示 r-x
{43798}{43869}那就意味着你有读和执行权限，但没有写权限
{43938}{44031}还有很多别的趁手的工具
{44032}{44110}有一个是 `mv` 命令
{44126}{44190}如果我 `cd` 回 `missing semester`
{44198}{44279}在这里我能用 `mv` 重命名文件
{44303}{44389}它接受两个路径（path）（作为参数）
{44408}{44462}先是原有的路径（path），然后是新的
{44477}{44571}这意味着 `mv` 既可以让你重命名一个文件
{44578}{44670}如果你只想原地重命名文件的话
{44677}{44756}或者把文件移动到一个不同的目录里
{44770}{44850}原理就是你给出现有文件的路径（和文件名）
{44851}{44907}以及目标路径和新文件名
{44912}{44970}然后它可以改变文件的路径和名字
{44997}{45122}比如说我可以 `mv dotfiles.md` 到 `foo.md`
{45134}{45181}对吧，虽然没卵用
{45187}{45252}我也可以 `mv` 回去
{45392}{45487}也有一个 `cp` 命令，或者打 `copy`
{45496}{45564}`cp` 让你复制[*]文件，用法很相似的
{45635}{45737}它也接受两个参数，复制源路径和目标路径
{45748}{45778}这些得是完整路径[*]
{45795}{45841}我可以举个栗子，比如说
{45853}{45968}我想 `cp dotfiles.md ` 到 `../food.md`
{45993}{46028}对，是 `food.md`，好嘞
{46052}{46094}如果我现在 `ls ..`
{46095}{46193}看，现在这个目录里有个 `food.md`
{46215}{46265}所以 `cp` 也是接受两个参数
{46266}{46313}而且不必是同一个目录
{46355}{46423}相似地，有个 `rm` 命令
{46424}{46458}让你可以移除（删除）一个文件
{46459}{46535}这里你可以传一个路径，比如说这里
{46536}{46595}我想把 `../food` （.md）删掉
{46609}{46657}你应该注意的是移除
{46658}{46692}特别是在 Linux 上
{46703}{46777}默认的移除是非递归的（recursive）
{46796}{46867}也就是说你不能用 `rm` 移除目录
{46889}{46997}你可以传一个执行递归移除的 `-r` flag
{47010}{47062}然后传递想移除的路径（path）
{47063}{47108}它就会移除目录下的所有内容
{47128}{47272}也有 `rmdir` 命令可以让你移除目录
{47273}{47361}不过只允许移除空目录
{47386}{47417}所以设计它的匠心是
{47419}{47465}这算是给你提供一种安全机制
{47466}{47525}用它你就不会不小心扔掉一堆重要文件
{47559}{47645}最后有一个趁手的小命令
{47646}{47678}是 `mkdir` （make directory）
{47679}{47723}可以让你创建一个新目录（文件夹）
{47724}{47814}之前说过了，别想着写一些这样的命令
{47815}{47878}这样会给你整出两个目录来
{47885}{47949}一个名为 `My`，一个 `Photo`
{47961}{48024}如果你想创建那种（带空格的）目录
{48025}{48142}要么把空格转义，要么把整个字符串引起来
{48242}{48426}如果你想这些平台上了解在任意一个命令的信息
{48438}{48556}也有个非常奥里给的程序，叫做 `man`
{48566}{48619}意思是手册、说明书（manual pages）
{48620}{48743}这个程序接受其他程序的名字作为一个参数
{48744}{48795}然后显示它的说明书
{48807}{48860}比如说我们可以输入 `man ls`
{48877}{48979}就显示了 `ls` 的说明书
{48980}{49042}你会发现这里显示的内容其实和
{49043}{49105}我们运行 `ls --help` 得到的内容挺相似的
{49119}{49204}不过翻阅起来稍微容易点儿
{49221}{49276}一般来说，翻到底儿瞧瞧
{49277}{49376}你能看到一些提示，基本都是
{49384}{49434}命令示例啊，作者啊，哪儿有更多信息啊
{49435}{49469}这类东西
{49493}{49540}偶尔有个问题挺捉弄人的
{49545}{49626}啊，直到最近一个版本里他们在底下
{49627}{49646}给加了一行
{49647}{49682}显示按 `Q` 退出
{49683}{49805}他们以前不显示这种「按 `Q` 退出」的
{49814}{49877}如果你不知道这事，还挺难退出来的
{49946}{50068}有个好用的快捷键，`Ctrl` + `L`
{50069}{50153}可以清空终端，让光标回到顶部
{50218}{50302}到现在我们只是分开说了各个程序
{50310}{50418}但是 Shell 真正的本领在于
{50419}{50495}当你把不同的程序结合在一起的时候
{50541}{50628}与只是运行 `cd` 和 `ls` 相比很强
{50629}{50720}也许你想把多个程序串起来
{50721}{50770}也许是想和文件交互
{50771}{50830}或者在各个程序之间操作文件
{50874}{50995}我们借助一个叫流（stream）的概念完成
{51011}{51076}Shell 默认会给我们的每个程序创建
{51086}{51167}我简化一下，就说程序有两个主要的流（stream）
{51179}{51219}默认，程序会有一个输入流（input stream）
{51220}{51259}和一个输出流（output stream）
{51279}{51348}默认输入流里的内容来自你的键盘
{51364}{51409}基本上输入流是终端
{51410}{51452}无论你向终端输入什么
{51453}{51493}最后都会传到程序里
{51508}{51572}默认的输出流，就是说
{51573}{51621}每当程序想要输出一些内容时
{51622}{51671}它会输出到这个流里去
{51672}{51723}默认也是终端
{51734}{51792}这就是为什么，当我打入 `echo hello`
{51793}{51842}它就显示回了我的终端里面
{51856}{51994}但是 Shell 提供了重定向这些流的方法
{51995}{52080}把输入和输出都改到程序员指明的地方
{52114}{52301}这里最直接的方式是用大于小于号[*]
{52328}{52373}所以你可以写一些类似这样的事情
{52384}{52429}或者类似那样的事情
{52464}{52596}小于号表示重定向这个程序的输入流
{52597}{52656}变成这个文件的内容
{52694}{52871}大于号表示重定向上述程序的输出流
{52890}{52931}变成输出到这个文件内
{52959}{53013}我们举个例子试一下是什么样
{53026}{53155}如果我 `echo hello`，我想把这个内容
{53156}{53220}存在一个叫 `hello.txt` 的文件里
{53236}{53312}我给了，这是个相对路径（relative path），对吧？
{53313}{53418}这样会在当前目录下创建一个 `hello.txt`
{53426}{53478}至少，理论上来说，它的内容
{53479}{53531}应该是 `hello` 这个单词
{53544}{53635}如果我运行一下，注意，啥都没输出来
{53653}{53710}前一次我运行 `echo hello` 的时候
{53711}{53736}它输出了 `hello`
{53737}{53843}现在 `hello` 已经跑到 `hello.txt` 里了
{53859}{53936}我可以用这个叫 `cat` 的程序验证
{53937}{54040}`cat` 打印出一个文件的内容
{54051}{54136}所以我可以 `cat hello.txt`
{54145}{54183}哎，它就显示了 `hello`
{54208}{54332}不过 `cat` 也支持这种流的重定向
{54337}{54450}所以我可以说 `cat` 默认只是将输入打印
{54451}{54506}呃，将输入原封不动复制到输出
{54518}{54628}比如，`cat`，我想让你接受 `hello.txt` 的输入
{54654}{54760}在这个例子下，Shell 就会打开 `hello.txt`
{54775}{54881}取出它的内容，设置成 `cat` 的输入
{54882}{54968}然后 cat 就会把这些内容打印到它的输出（流）
{54969}{55059}我没有重定向它，所以是我的终端
{55067}{55130}总之就是它会把 `hello` 打印到输出
{55180}{55235}我也可以同时使用两种（重定向）
{55236}{55367}比如我想复制一个文件但不用 `cp`
{55378}{55496}我可以用这套方法，具体来说
{55497}{55582}实际上我没有告诉 `cat` 任何事
{55583}{55647}我只是命令它说「你正常干活」，对吧
{55648}{55727}`cat` 不知道是不是发生了重定向
{55738}{55810}但是我会告诉 Shell 用 `hello.txt`
{55811}{55837}去作为 `cat` 的输入
{55846}{55907}然后把 `cat` 输出的所有内容存到
{55908}{55951}`hello2.txt` 里面去
{55981}{56035}这次还是没有东西打印到终端上
{56036}{56104}但是如果我运行 `cat hello2.txt`
{56112}{56168}我得到了期望的输出
{56189}{56242}也就是一个源文件的副本
{56303}{56383}也有个东西是双大于号[*]
{56388}{56486}作用是追加（append）而不是覆写（overwrite）[*]
{56505}{56569}你会注意到如果我
{56570}{56654}`cat < hello.txt > hello2.txt`
{56662}{56714}然后我 `cat hello2.txt`
{56715}{56755}它仍然只是包含 `hello`
{56756}{56805}尽管它之前已经有过 `hello` 了
{56822}{56937}如果我给它换成双大于号，意味着追加
{56945}{56981}如果我现在再 `cat` 那个文件
{56982}{57011}它就有了两个 `hello`
{57091}{57151}这些都挺直白的
{57152}{57222}它们仅仅是和文件交互的一些方式
{57230}{57269}不过真正有趣的地方是
{57270}{57333}Shell 附赠给你的一个操作符（operator）
{57334}{57449}叫管道符（pipe），管道符就是一个竖线
{57464}{57528}管道的意思是
{57537}{57635}取左侧程序的输出
{57648}{57714}成为右侧程序的输入
{57813}{57893}这看上去会是什么样子呢
{57903}{57974}来试一个例子，比如说 `ls /`
{57975}{58034}或者 `ls -l /`
{58043}{58080}打印出了一堆东西
{58087}{58176}我就说我想要输出的最后一行
{58190}{58252}有一个命令叫 `tail`
{58263}{58378}它打印出它输入的最后 n 行
{58395}{58503}我可以 `-n1`，所以这就是个叫 n 的 flag
{58509}{58618}如果你想，也可以用更长的 `--lines`
{58626}{58726}这个例子里，它表明输出最后一行
{58737}{58824}我可以把这些连接到一起，也就是说
{58825}{58945}`ls -l / | tail -n1`
{59010}{59093}注意这里 `ls` 并不了解 `tail`
{59094}{59156}`tail` 也不认识 `ls`
{59157}{59192}它们是不同的程序
{59193}{59271}也没有刻意设计和对方相兼容
{59285}{59338}它们只知道要从输入读数据
{59339}{59367}结果写到输出
{59381}{59445}`pipe` 才是把它们连结起来的东西
{59466}{59597}这个例子，我想 `ls` 输出作为 `tail` 输入
{59602}{59672}`tail` 的输出则会输到我的终端
{59673}{59700}因为我没有重定向它
{59718}{59763}我也可以把它重定向，比如说
{59764}{59819}我想输出到 `ls.txt` 里面
{59833}{59904}这里如果我 `cat ls.txt` ，就得到
{59905}{59932}一个期望的输出
{59958}{60029}这意味着你可以做一些很妙的事情
{60030}{60088}我们会在 data wrangling （数据整理）课程
{60089}{60119}里面涉及更多
{60129}{60207}是大约四天之后
{60231}{60297}有一些特别奇妙的工具
{60298}{60357}构建高级管道的时候用得到
{60403}{60481}给你们举一个例子，我们可以做一些操作，比如
{60496}{60640}`curl --head --silent google.com`
{60692}{60744}就只是展示个大概
{60752}{60812}这会给我访问 google.com 时候
{60813}{60863}所有的 HTTP Headers
{60902}{60954}我也可以用管道给它接到
{60972}{61050}`grep --ignore-case`
{61051}{61096}或者说 `-i`
{61106}{61189}比如说我想（匹配）content-length
{61207}{61294}这样就会打印出 content-length header
{61295}{61354}`grep` 是我们之后会讲的程序
{61355}{61444}它支持在输入流里搜索给定关键字
{61483}{61560}我们还可以用管道连到 `cut` 命令
{61574}{61730}它可以接受一个分隔符，我们设成空格
{61731}{61779}我想要第二个字段
{61791}{61844}这样就只输出 content-length（的值）
{61860}{61907}这算是一个很傻的例子
{61908}{62002}只是在命令行里以字节（bytes）的形式
{62003}{62055}提取出 google.com 的内容长度
{62056}{62158}这没啥有用的，但是你可以从中窥见
{62159}{62195}把命令链接在一起
{62196}{62325}你可以做很多文本操作的特技
{62326}{62416}而且 `pipe` 不止用于文本数据
{62417}{62486}还可以拿来处理比如图片
{62487}{62604}当你有一个程序可以接受并处理二进制图片
{62605}{62658}然后输出一个二进制图片的时候
{62659}{62724}也可以像这样把它连进去
{62725}{62805}我们之后也会谈到这类例子
{62823}{62881}你甚至可以这样处理视频
{62884}{62999}你可以 - 比如说你家里有个 Chromecast [*]
{63005}{63067}你可以把一个视频文件推流
{63081}{63165}如果把管道的最后一个程序设成
{63166}{63227}Chromecast 的发送程序
{63238}{63285}然后以流的形式传给它视频文件
{63286}{63345}它就推流（或者 HTTP 形式）传到你的 Chromecast
{63479}{63569}在数据整理那节会涉及更多
{63579}{63673}但是我还想说一个事情
{63677}{63883}大概就是终端的更有趣和强大的用法
{63884}{63991}对于那些已经熟悉终端的同学来说
{63992}{64051}也许会挺有意思
{64088}{64180}我们要先提一个重要话题
{64181}{64270}就是涉及到 Linux 和 MacOS 的时候
{64275}{64344}有一个叫 root （根）用户的概念
{64355}{64451}root 用户类似 Windows 里面的管理员（Administrator）
{64465}{64518}有值为 0 的用户 ID
{64531}{64576}root 是很特别的，因为
{64577}{64653}他被允许在系统上做任意行为
{64685}{64768}就算一个文件是任何人不可读的
{64769}{64820}或者任何人不可写的
{64821}{64871}root 却可以访问这个文件（且读写）
{64883}{64922}他算是一种「超级用户」
{64923}{64954}可以做任何想做的事
{65024}{65124}大多数时候你不会用超级用户操作
{65125}{65157}你不会是 root
{65158}{65216}你应该是一个类似 `Jon`，或者别的啥
{65217}{65240}按你的名字来的用户
{65241}{65291}你该用这个用户操作（电脑）
{65303}{65413}因为如果一直在 root 下操作电脑
{65421}{65458}如果你运行了错误的程序
{65459}{65509}可能会直接炸了你的电脑
{65520}{65569}你肯定不想这样，对吧
{65599}{65706}但是从今往后你每次想用 root 做点事的话
{65728}{65812}通常这种情况是，用一个叫 `sudo` 的程序
{65827}{65958}S-U-D-O 或者说 do as su
{65969}{66031}这里 su 就是 Super User（的缩写）
{66038}{66127}这是一个用超级用户运行程序的办法
{66155}{66217}通常 `sudo` 的用法是
{66218}{66311}你先打 `sudo` 再接上平常调用的命令
{66312}{66428}它就会以 root 身份运行这个命令
{66509}{66579}你在哪里可能要用到这种东西呢
{66580}{66661}呃，有一个特别的……
{66662}{66722}在你的电脑上有很多特别的文件系统
{66723}{66798}其中有一个特定的叫 `sysfs`
{66810}{66870}如果你 `cd` 到 `/sys`
{66887}{66947}这整个儿都是新世界
{66957}{67071}这个文件系统不是真实存在的文件
{67081}{67166}相反，这是一大堆内核参数
{67167}{67262}内核（kernel）基本上就是你电脑[*]的核心
{67284}{67381}这是种访问这些内核参数的方法
{67395}{67460}通过这些看起来是文件系统的东西
{67491}{67602}你看，这里如果我 `cd` 到比如 `class`
{67603}{67698}对于一大把设备，它有各个对应的目录
{67709}{67742}我可以与它们交互
{67743}{67832}或者各种队列（queue）
{67833}{67927}或者各种奇奇怪怪的内核玩意儿
{67955}{68031}由于它们是以文件形式展露（exposed）的
{68032}{68126}这意味着我们可以用先前的所有工具
{68127}{68166}去操作他们
{68178}{68304}举个栗子，如果你去到 `sys/class/backlight`
{68330}{68441}这个 `backlight` 可以直接设置笔记本的亮度
{68442}{68467}如果你是用笔记本电脑
{68468}{68528}所以我 `cd` 进 `intel backlight`
{68529}{68561}这是个 Intel 的笔电
{68572}{68649}里边儿你可以看见有个文件叫 `brightness`
{68657}{68697}我可以 `cat` 这个 `brightness`
{68698}{68782}这是我现在的屏幕亮度
{68802}{68886}不止于此，我也可以更改它
{68887}{68950}来改变我的屏幕亮度
{68969}{69040}你也许认为我要……
{69041}{69090}来看看最大亮度是多少
{69098}{69152}好，所以现在是最大亮度
{69171}{69249}你可能会想，我会写点这样的命令
{69265}{69392}如果我 `echo`……让我们设个一半
{69407}{69457}`echo 500 > brightness`
{69475}{69532}如果我这么干，它提示我没有权限
{69533}{69588}我不允许修改亮度
{69589}{69706}因为……基本上如果你要修改内核的东西
{69707}{69749}你得是管理员才行
{69762}{69830}你也许会以为解决方案是写个
{69837}{69882}`sudo echo 500`
{69888}{69942}但我还是莫得权限
{69954}{70055}为毛呢？这是因为按我之前说的
{70064}{70197}输入输出的重定向是程序不知道的
{70218}{70271}用管道把 `ls` 连接到 `tail` 的时候
{70272}{70364}`tail` 不知道 `ls`，`ls` 也不知道 `tail`
{70365}{70450}管道和重定向都是 Shell 设好的
{70464}{70560}所以现在的情况是我告诉 Shell
{70569}{70702}去运行 `sudo`，并且包括参数 `echo 500`
{70714}{70803}然后发送输出到这个 `brightness` 文件
{70827}{70906}但是 Shell 打开 `brightness` 的时候
{70907}{70970}用的不是 `sudo`
{70995}{71094}所以这里 Shell 以我（Jon）的用户身份
{71095}{71148}去试图打开 `brightness` 文件并写入数据
{71149}{71244}而这不被允许，所以我有个无权限的错误
{71267}{71320}你也许见过（下面）这个
{71341}{71415}如果你搜了啥然后最后到了 Stackoverflow 上[*]
{71416}{71461}他们告诉你运行一下这个命令就行
{71462}{71576}你会见到像这样的，他们给你一些说明
{71579}{71872}比如 `echo 1 > sys`，呃，`net/ipv4_forward`
{71873}{71947}在设置防火墙的时候你可能见过这种东西
{71957}{72050}这个命令之所以能行
{72060}{72107}是因为前面这个小小的 `#`
{72108}{72157}意味着以 root 运行整条命令
{72165}{72272}这件事很少有人解释，但就是这个意思
{72278}{72350}你会看见在我的 prompt（提示符）上
{72354}{72420}`$` 表示你现在不是 root
{72440}{72507}重要的是我现在怎么解决问题
{72508}{72599}一是我可以切换到 root 终端
{72611}{72673}这个方法是运行 `sudo su`
{72683}{72778}`sudo su` 是说用 root 运行接下来的命令
{72793}{72905}`su` 是个蛮复杂的命令
{72906}{73003}能让你以超级用户登录 Shell
{73030}{73096}如果我运行，然后输入密码
{73104}{73231}你会看到开头的用户名从 `jon` 变成了 `root`
{73240}{73310}提示符从 `$` 变成了 `#`
{73329}{73385}如果我现在处理那个文件
{73386}{73445}`echo 500 > brightness`
{73467}{73505}我的屏幕就变暗了一点
{73506}{73569}虽然你看不见，你只能听信我
{73588}{73649}我现在就没得到错误
{73656}{73746}因为现在 Shell 以 `root` 身份运行
{73747}{73797}而不是 `jon`
{73806}{73874}而 `root` 用户允许打开这个文件
{73899}{74006}但是运用我们现有的终端知识
{74014}{74058}其实还有一个办法
{74059}{74114}能不用进入 root Shell
{74130}{74338}就是，呃，我恢复到 1060
{74387}{74433}你看到这里的区别了吗
{74465}{74585}我告诉 Shell 去运行 `echo 1060`
{74586}{74621}它会输出 `1060`, 然后我告诉它
{74632}{74713}运行 `sudo tee brightness` 命令
{74722}{74851}然后把 `echo` 的输出送入 `sudo tee` 的输入
{74875}{74949}要搞明白这个你得知道 `tee` 命令干啥
{74959}{75053}`tee` 命令取它的输入，然后写入到一个文件
{75054}{75097}并且写入到标准输出（流）
{75134}{75192}所以 `tee` 是一个很方便的命令
{75193}{75275}比如说你有个日志[*]，你想
{75276}{75333}把它传到一个文件里存着之后看
{75334}{75386}但你还想现在瞅一眼
{75401}{75442}那你就可以用管道传给 `tee`
{75443}{75537}再给它文件名，它就能把无论什么输入
{75538}{75594}写到文件和你的屏幕上
{75611}{75683}这里我就利用这个程序
{75684}{75764}这里我说「以 root 运行 `tee`」
{75772}{75831}然后输出到 `brightness` 文件
{75861}{75968}这个例子里 `tee` 程序打开了 `brightness`
{75969}{75993}并且以 root （身份）运行
{75994}{76053}所以这是可行的
{76063}{76090}如果我现在运行它
{76091}{76198}你还是看不到亮度，但是它被调高了
{76226}{76262}我没有收到任何错误提示
{76263}{76421}并且我也不必跑去危险的根目录在那运行指令
{76452}{76510}如果你想更深入的了解文件系统的话
{76511}{76570}你在浏览的时候能看到很多有趣的东西
{76596}{76759}你能发现各种各样有趣的东西
{76760}{76860}举个例子，我们已经发现了有个有趣的亮度指令
{76861}{76925}我想知道我还可以设置什么其他有趣的亮度
{76972}{77075}所以我们可以用下一讲要讲到的查找指令
{77086}{77311}我在当前目录里找找长有点像亮度的东西
{77327}{77404}啊，翻车了…也许它们不是文件？
{77440}{77589}啊，看来是我拼错了，好烦啊
{77771}{77859}看起来，它不怎么想帮我查找有关的文件
{77931}{77997}走运的是，我其实已经知道一个了
{78052}{78199}有个子目录叫 `LEDs` ，这里面也有亮度相关的文件
{78214}{78244}看看里面有啥样的 LED 灯
{78246}{78282}好家伙，还不少呢
{78292}{78390}举个例子，有滚动锁定键的 LED 灯
{78395}{78499}你们大多数人可能都不知道啥是滚动锁定键了
{78500}{78553}或者很少有人知道啥是滚动锁定
{78563}{78684}你可能在键盘上见过一个叫 `scroll lock` 的按键
{78711}{78769}基本上再也没人知道这个按键是干什么的了
{78770}{78875}它没啥用了，所以它差不多是个被淘汰的按键了
{78876}{78935}同时也是个被淘汰的 LED 灯
{78965}{79020}如果我把它配置一下
{79021}{79107}使每次在来邮件的时候滚动锁定键都会亮起来怎么样
{79114}{79168}因为没有别的东西会让它亮起来
{79193}{79256}如果我把你发配到这个有亮度配置的目录里
{79293}{79338}这里也有个 `brightness`
{79339}{79374}并且被设为 `0`
{79386}{79431}如果我们把 `1` 写入进去会发生什么
{79522}{79650}话说回来，别随便把数字写入这个目录的文件里
{79651}{79706}因为你会直接影响到内核
{79707}{79749}你得先弄明白这个文件有什么作用
{79752}{79862}现在我做好了安全措施并且我也做了充分研究
{79896}{79942}所以你们可能没发现
{79943}{80038}其实我键盘上滚动锁定的灯已经亮了
{80065}{80183}现在，如果我写一个能检查邮件之类的程序
{80184}{80303}我最终就能把 `1` 写入这个文件
{80317}{80477}现在有个让我键盘上的滚动锁定键显示有没有新邮件的方法
{80513}{80725}你大致有个用终端和 Shell 来实现这个的雏形了
{80726}{80827}并且现在你掌握的足够完成一些基本任务了
{80828}{81019}至少从理论上你不用点击界面去查找文件了
{81032}{81093}这里还有个你应该掌握的小技巧
{81094}{81157}也就是打开文件的能力
{81170}{81278}目前我只告诉你怎么查找文件
{81287}{81441}但是有一点你要知道
{81456}{81588}`xdg-open` 这个指令可能只在 `Linux` 上运行
{81589}{81649}在 MacOS 上可能叫 `open`
{81660}{81704}至于 Windows 嘛，谁知道
{81713}{81878}你给出一个文件名，然后 `xdg-open` 就会用合适的程序打开它
{81884}{81982}所以如果你用 `xdg-open` 打开一个 `HTML` 文件
{81983}{82044}它就会打开你的浏览器然后打开那个文件
{82072}{82134}所以，理论上，你有了这个程序之后
{82135}{82217}你就再也不用打开 Finder 窗口了
{82241}{82288}虽然你可能还会打开，因为别的原因
{82289}{82379}但是从理论上讲，你可以用这套工具完成任何任务
{82413}{82511}今天学的东西对你们中的一部分人可能有些基础
{82512}{82601}但是就像我提到过的，这是一个快速提升的阶段
{82602}{82656}现在我们知道了 Shell 是怎么运行的
{82657}{82737}之后还了解了我们之后的讲座中会做些什么
{82738}{82897}那就是用 Shell 去做一些真正有趣的事情
{82905}{83024}这有点像学习我们将要用到的界
{83025}{83090}所以我们需要全部了解这些东西，这很重要
{83119}{83199}我们在接下来的讲座中会讲到很多
{83200}{83254}关于诸如这种自动化任务的话题
{83255}{83335}关于怎样写出能运行一大堆程序的脚本
{83344}{83472}并且还得学习怎么在终端里写条件、循环之类的东西
{83473}{83567}还有运行一个程序，直到它出错
{83580}{83696}你的测试程序出错之后可以容易地停下来
{83725}{83800}所以这就是下周讲座的主题
{83804}{83838}你有什么问题吗
{83849}{83944}像你刚才在 `\sys` 目录下演示的那样
{83945}{84082}你是在 Linux 系统下演示的
{84083}{84149}如果在 Windows 下用 Linux 子系统会怎样呢？
{84200}{84236}这是个好问题
{84237}{84414}我不知道 Windows 的 Linux 子系统会不会展露 `\sys` 文件系统
{84415}{84527}如果显示的话，也只会展露很少的一部分
{84567}{84623}可能会吧
{84624}{84692}比如说，会有 LED 和 brightness 吗？
{84693}{84746}我不知道，自己去查吧
{84762}{84883}你会发现这个系列讲座的讲义已经上线了
{84892}{85006}并且讲义最底下有一些练习
{85013}{85096}一些练习相对简单，而一些练习有点难度
{85097}{85217}我们建议你尝试着去做这些练习
{85218}{85259}如果你已经掌握了这些东西的话
{85260}{85297}完成这些练习不会占用你太多时间
{85298}{85373}如果你还没有完全掌握
{85374}{85436}这些练习会教给你一些你可能没意识到自己不会的东西
{85442}{85609}接下来，在课后的工作时间，我们乐意解答你遇到的任何问题
{85610}{85723}或者想了解如何更高效的使用课内课外遇到的指令
{85750}{85816}下一讲，也就是明天
{85839}{85949}会在你们已经基本掌握练习教给你的东西的基础上进行
{85980}{86079}在网站上还有一个邮箱地址
{86080}{86226}你可以在工作时间之外向我们发送你的问题
{86264}{86342}今天这堂课结束之前，还有什么问题吗
{86409}{86485}没了吗？看来没了
{86486}{86520}那么大约五分钟后
{86521}{86678}我们会在 Gates Building 的九楼继续办公
{86700}{86738}大家再见！

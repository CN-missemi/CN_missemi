{39}{145}  好，欢迎来到今天的课堂
{146}{197}今天我们讲数据的整理（Data Wrangling）
{209}{305}这个英文名可能听上去有点怪
{306}{370}但它解决的核心问题就是
{371}{487}把一种格式的数据转换成另一种
{498}{552}那这个任务再平常不过了
{553}{616}不过我不仅仅说的是图片格式之间的转换
{617}{712}还有可能是你现有的文本文件、日志文件
{720}{815}你想得到它们的其他格式
{816}{890}比如画成图或者进行统计
{899}{986}那么我认为的数据处理
{987}{1073}就是像这样把一个数据
{1074}{1133}以另一种方式表达
{1158}{1301}我们在前面几节课已经见过几个例子了
{1306}{1399}例如当你使用管道操作符的时候
{1400}{1520}它会把一个程序的输出喂给另一个程序
{1521}{1595}其实此时，你就在进行某种形式的数据处理
{1611}{1688}那么我们这节课的主要内容就是
{1689}{1778}看看有什么神秘的数据处理魔法
{1779}{1873}以及数据处理的高效方法
{1930}{1993}要处理数据
{1994}{2027}首先你得有数据来源
{2028}{2099}要有能加以实践的数据
{2137}{2239}那优质的数据来源就多了去了
{2240}{2299}那么我们今天的课堂笔记的练习里
{2300}{2342}就会给你许多的样例数据
{2358}{2460}而今天的课呢，我打算用系统日志
{2474}{2575}我在荷兰那地儿跑着个服务器
{2584}{2640}呃，当时来说这十分合理[*]
{2646}{2742}在那个服务器上呢，跑着一个
{2743}{2838}`systemd` 自带的记录日志的后台进程
{2839}{2927}这是一个挺标准的 Linux 日志机制
{2940}{3017}然后我们可以通过 Linux 有的一个
{3018}{3121}`journalctl` 命令来看系统日志
{3131}{3164}那么我要做的事
{3165}{3248}就是对这些日志施展一些“魔法”
{3249}{3313}然后看看里面有没有啥有趣的东西
{3347}{3406}|你可以看到我跑完这个命令以后
{3407}{3493}获得了这么多的数据
{3503}{3643}因为这个日志文件，它里面有超多东西
{3645}{3704}我的服务器上发生了不少事情
{3705}{3706}你看这一条是一月一日的|我的服务器上发生了不少事情
{3707}{3784}你看这一条是一月一日的
{3789}{3890}后面还有更久远的
{3902}{3986}那我们要做的第一件事就是缩小日志量
{3987}{4054}我们只看一部分的内容
{4061}{4114}此时 `grep` 就是你的最佳伙伴了
{4131}{4235}我们用管道把 `ssh` 的输出接到 `grep` 上
{4244}{4328}我们还没仔细聊过 `ssh`
{4334}{4429}但它是一种通过命令行访问远程计算机的方式
{4441}{4566}当你把服务器放到公网上之后
{4567}{4666}世界各地的人都想连接然后登录进去
{4667}{4702}然后控制你的服务器
{4703}{4791}那我就想看看他们是咋整的[*]
{4801}{4852}那我就 `grep SSH`
{4881}{5056}然后你就能够~~很快的~~看到这会输出很多东西
{5102}{5156}理论上来说是这样的但是实际上很慢...
{5177}{5193}好
{5242}{5273}你可以看到它生成了
{5277}{5324}这么这么这么多的内容
{5339}{5434}哪怕是发生了什么也压根展现不出来
{5435}{5528}所以我们只来看看这些人
{5529}{5585}用了什么用户名来尝试登录
{5586}{5767}你可以看到这里有几行写着「无效用户，断开连接」[*]
{5768}{5806}然后后面是用户名
{5812}{5852}现在我只想要这种日志条目
{5853}{5884}我只关注这些东西
{5901}{5990}那我现在再来点修改
{6003}{6063}我在最后加上个`断开连接`*
{6064}{6167}你想想底部的这条命令流水线是如何运作的
{6190}{6407}首先它会通过网络，把整个日志传到这个电脑里
{6417}{6525}然后在本地跑 `grep` 找出所有含 `ssh` 的行
{6538}{6593}然后再在本地更进一步的去筛选
{6603}{6638}这是不是有点浪费 [*]
{6639}{6698}因为我根本不关心其他的条目
{6711}{6766}远程服务器上也有个 Shell
{6767}{6929}那我就把整个命令搬到服务器上运行
{6943}{6981}那么现在，你，SSH
{6982}{7091}你给我在服务器上整这三个活
{7104}{7179}然后拿回来的数据我再接到 `less` 上面
{7224}{7262}那这会发生什么呢
{7263}{7325}其实是一样的数据筛选
{7326}{7375}只是把工作搬到服务器上了
{7376}{7490}而服务器只会回传我想要的行
{7524}{7613}然后我在本地把数据用管道接到了 `less` 上
{7625}{7666}其实 `less` 是个分页显示程序
{7667}{7714}你会看到一些例子…
{7715}{7764}其实当你键入 `man`
{7765}{7829}或者一些其他使用分页器显示的命令时
{7830}{7883}你实际上已经见过这个程序了
{7884}{7980}使用分页器程序可以方便的把长长的内容
{7981}{8044}适配到终端的大小
{8045}{8128}然后让你上下滚动来浏览
{8139}{8210}而不是在你的屏幕上一滚而过
{8224}{8312}执行这个命令的时候还是要花一些时间
{8313}{8368}因为服务器要解析一堆日志文件
{8381}{8483}特别是 `grep` 会先缓存输出*
{8486}{8598}所以它还卡在这
{8599}{8689}让我看看不这样的话会不会好一点[*]
{8988}{9066}为啥不听我的话...
{9109}{9172}好吧让我搞点小手段
{9192}{9242}你假装没看见
{9520}{9596}也有可能是这个网络差得离谱
{9602}{9641}可能是这两个原因之一
{9642}{9695}还好我有备而来
{9710}{9850}上课前我执行了这个命令
{9879}{10009}它会把前面的这串命令的输出
{10010}{10069}放到我电脑里的这个文件里
{10078}{10191}而前面这串命令所做的事就是
{10192}{10294}把所有包含 `disconnect from` 的
{10295}{10372}SSH 日志下载到本地
{10373}{10412}这真是个好东西
{10413}{10505}因为我并没有必要去传输整个日志
{10506}{10601}因为我只想要这个开头的东西
{10620}{10697}那我们现在来看看 `ssh.log`
{10698}{10775}你可以看到这里有这么这么多
{10776}{10859}写着与无效的用户断开连接
{10860}{10902}与已认证的用户断开连接，等等
{10944}{11021}我们要做的就是在这些日志上整活
{11024}{11051}这也意味着
{11052}{11140}在这之后我们并不需要再走 SSH 的流程
{11141}{11188}我们可以直接 `cat` 这个文件
{11189}{11228}然后在它上面进行操作
{11286}{11357}此外让我来展示一下这个分页器
{11358}{11462}如果我 `cat ssh.log`
{11463}{11492}然后把管道接到 `less` 上
{11493}{11535}他就会给我一个分页器
{11536}{11582}我就可以上下滚动了
{11583}{11618}把字体调小一点点？
{11664}{11743}那么我还可以用些
{11744}{11842}类似 Vim 的按键操作来浏览
{11851}{11936}`Ctrl+u` 向上翻，`Ctrl+d` 向下翻
{11937}{11972}以及按 `q` 退出
{12036}{12224}但是这里面还是有很多我不想看的垃圾信息
{12225}{12305}我只想看看这些用户名是些啥
{12318}{12396}那么我们就要来用
{12397}{12437}一个叫做 `sed` 的工具了
{12438}{12519}`sed` 是一个更早期的
{12520}{12662}一个叫做 `ed` 的东西的改版
{12663}{12788}这东西非常之怪，你们肯定不想用
{12789}{12806}诶你有啥问题
{12816}{12872}_抱歉我可能漏听了_
{12873}{12920}_但是 `tsp` 是个啥 [*]_
{12921}{13031}哦 `tsp` 是我的远程计算机的名字
{13093}{13172}所以 `sed` 是一个“流”编辑器
{13173}{13357}可以让你修改流（stream）中的内容
{13358}{13447}你可以认为这个命令大概是做文本替换
{13448}{13510}但实际上 `sed` 是一个在输入流上操作的
{13511}{13570}完整的编程语言 [*]
{13588}{13670}那么 `sed` 的一个最常用操作就是
{13671}{13786}在输入流之上跑替换表达式
{13804}{13838}那么这东西长什么样呢
{13847}{13888}让我写给你看看
{13971}{14032}好 现在我要把管道接到 `sed` 上
{14033}{14079}然后我告诉它我想把
{14080}{14183}所有 `disconnected from` 前面的东西
{14185}{14218}全部丢掉
{14319}{14369}这可能有些奇怪
{14375}{14415}但是你会观察到
{14416}{14570}这些 SSH 里的日期、域名、进程 ID
{14571}{14645}我并不关心，干脆统统把它删掉
{14646}{14824}`Disconnected from` 这几个字每条日志都有
{14827}{14857}也可以删掉
{14871}{14951}那我就要写一个 `sed` 表达式
{14959}{15031}而此处我写的是一个 `s/` 表达式
{15032}{15080}也就是替换表达式（**s**ubstitute）
{15087}{15238}这个表达式接受两个以斜线分隔的参数
{15250}{15323}第一个参数是要找的字符串
{15333}{15376}而第二个是要换成的字符串
{15377}{15377}这个参数现在是置空的|而第二个是要换成的字符串
{15378}{15407}这个参数现在是置空的
{15421}{15511}这里的意思就是，按这个字符串模式搜索
{15512}{15550}然后把它换成空的
{15575}{15641}最后我把它接到 `less` 上
{15656}{15774}看到了吗？它把这些行的开头剪掉了
{15821}{15885}用起来真的爽
{15886}{15928}但是你可能会疑惑
{15929}{15999}我在这写的这玩意是个啥
{16019}{16112}那个 `.*` 是干啥的
{16128}{16197}这实际上是正则表达式的一个例子
{16211}{16349}正则表达式，你之前写程序可能见过
{16353}{16421}但是你一旦用起命令行
{16422}{16460}你会发现这东西用得特别多
{16461}{16520}特别是对于像这样的数据处理
{16534}{16681}特别是对于像这样的数据处理
{16695}{16754}你不一定要把它用在文本上
{16755}{16806}但匹配文本是最普遍的用途
{16819}{16861}在正则表达式里
{16862}{16997}你可以活用一套特殊字符
{16998}{17089}这些字符不会直接匹配它们本身
{17090}{17223}而是匹配某一类的字符或者字符串
{17247}{17306}本质上来说它生成了一个程序
{17307}{17354}来在文本中进行查找
{17371}{17474}例如 `.` 代表「匹配任意的一个字符」
{17526}{17624}而如果在某一字符后面加上 `*`
{17625}{17716}那它代表匹配零次或多次该字符
{17740}{17802}那么这个 pattern（模式）所描述的就是
{17803}{17876}任意的、零个或多个字符 [*]
{17885}{17969}然后跟着一个字符串 `Disconnected from`
{18001}{18048}这里就是说，我找到这样的字符串|
{18049}{18089}然后把它们换成空的
{18121}{18237}正则表达式有一大把像这样的特殊字符
{18245}{18271}各有各的含义
{18272}{18297}你可以好好运用
{18306}{18340}我说了个 `*`
{18341}{18376}它匹配零或多个
{18377}{18405}还有一个 `+`
{18406}{18441}它是匹配一个或多个字符
{18450}{18482}那么这样的意思就是
{18483}{18539}我想要前面那个 pattern 匹配至少一次
{18597}{18643}此外还有方括号
{18658}{18780}可以让你匹配多种字符中的一种
{18790}{18867}好 我现在搞个字符串
{18868}{18911}比如说 `aba`
{18938}{19104}我想把 `a` 和 `b` 换成空的
{19185}{19283}那么我就让 pattern 去把
{19284}{19388}要么是 `a` 要么是 `b` 的字符
{19389}{19412}换成空的
{19467}{19519}就算我把第一个字符换成了 `b`
{19520}{19558}还是会输出 `ba`
{19574}{19598}那你可能就会想了
{19599}{19642}为啥它只替换一次呢
{19643}{19711}这是因为正则表达式
{19712}{19764}在默认模式下
{19765}{19903}每行只匹配一次、替换一次
{19915}{19961}这是**默认**模式下做的事
{19980}{20043}你可以再加个 `g` 修饰符
{20044}{20120}意思是只要能，就尽量多匹配
{20151}{20212}然后整行就没了
{20213}{20288}因为每个字符都是 `a` 或 `b` 之一
{20304}{20348}如果我再加个 `c`
{20349}{20391}它就移除 `c` 之外的所有东西
{20412}{20456}如果再向字符串里边加其它字符
{20457}{20538}也都会保留下来
{20539}{20612}但是 `a` 和 `b` 都会被去掉|
{20724}{20858}你还可以给他加点修饰符
{21094}{21120}跑这个命令会发生什么呢
{21135}{21251}它的意思是我想要把零个或多个
{21272}{21316}`ab` 这个字符串
{21343}{21386}换成空的
{21411}{21438}那么这就意味着
{21439}{21503}单独的一个 `a` 不会被替换掉
{21514}{21572}单独一个 `b` 也不会被替换掉
{21586}{21635}但是 `ab` 连一起
{21636}{21663}它就会被替换掉了
{21834}{21902}`sed` 你好蠢啊
{21958}{22082}这里加上 `-E` 是因为 `sed` 真的很老了
{22092}{22205}它只支持很旧版本的正则表达式
{22212}{22299}一般你要加上 `-E` 开关跑
{22300}{22346}这样他就会用一套支持更多东西的
{22347}{22385}更现代的语法
{22386}{22461}如果它没法使用 `-E` 开关
{22473}{22548}那你就得在括号前面加 `\`
{22549}{22640}来告诉它使用“特殊含义”的括号
{22656}{22715}不然它就只会匹配括号本身
{22727}{22754}那可能不是你想要的
{22815}{22906}注意它把这里的 `ab` 替换掉了
{22926}{22986}把这里的 `ab` 也替换掉了
{22987}{23018}但是把这个 `c`
{23032}{23078}还有末尾的 `a` 留下来了
{23090}{23165}因为它和 pattern 不匹配
{23205}{23278}你可以把 pattern 的任意部分括成一组
{23285}{23349}你也有「逻辑或」之类的东西
{23361}{23466}例如你可以让它移除
{23467}{23515}任意匹配 `ab` 或 `bc` 的字符串
{23597}{23668}然后你会注意到这个 `ab` 没了
{23686}{23750}但就算这个 `bc` 和 pattern 相匹配
{23751}{23801}它并没有被删除
{23811}{23870}这是因为 `ab` 已经被删除了
{23897}{23963}这个 `ab` 被删掉了，对吧
{23964}{23990}`c` 还留着
{23991}{24036}这里的 `ab` 被删去了
{24054}{24126}因为这个 `c` 依然不匹配，还留着
{24150}{24224}如果我把这个 `a` 删掉
{24235}{24302}这个 `ab` 的 pattern
{24303}{24345}就不会匹配到这个 `b`
{24347}{24373}然后它就会被留下来
{24379}{24428}然后 `bc` 就会匹配到这个 `bc`
{24432}{24458}随后就会被删掉
{24483}{24565}你刚开始接触的时候
{24566}{24611}正则会用起来很麻烦
{24612}{24671}就算当你熟练之后
{24672}{24712}这东西看起来也很吓人 [*]
{24728}{24782}这也是为什么
{24786}{24877}人们常常会使用正则调试器的原因
{24878}{24917}过一会儿我们会看到
{24926}{24995}但首先让我们编写一个 pattern
{24996}{25142}能够匹配日志条目…呃…匹配我们在搞的条目
{25161}{25282}让我们先从文件里拿几行出来
{25283}{25323}那就拿前五行吧
{25332}{25385}看，这几行现在是这样一个形式
{25451}{25610}但是我们要做的是，只留用户名
{25633}{25688}那么我们就会想把它写成这样...
{25713}{25867}等下 让我先给你看一个东西
{26032}{26147}我们先整出来
{26148}{26354}写着（红字内容）这样一串的一行
{26368}{26431}来自叫做 `Disconnected from` 的用户
{26558}{26629}那么这是一条登录记录
{26796}{26839}_（学生）少了个 `s`_
{26840}{26986}少了个 `s` 吗？emmmm...
{26989}{27017}_（学生）第一个 `Disconnected`_
{27018}{27023}**`Disconnected`** 多谢|_（学生）第一个 `Disconnected`_
{27024}{27077}**`Disconnected`** 多谢|
{27120}{27215}那么你会发现这个命令连用户名一起移除了
{27227}{27301}这是因为像 `.*`
{27302}{27377}这种范围匹配的正则表达式
{27378}{27426}它们是用贪心策略
{27427}{27488}去尽可能多的匹配
{27503}{27634}因此虽然我们在这里想保留用户名
{27635}{27797}但是这个 pattern 会一路匹配到它第二次
{27798}{27838}也就是最后一次出现
{27839}{27880}所以包括用户名在内
{27883}{27946}在这之前出现的文本都会被删掉
{27966}{27998}那么我们就要想一个
{27999}{28051}机智一点的方法来匹配
{28052}{28105}而不仅仅是使用 `.*`
{28117}{28223}这会使得当输入比较毒瘤的时候
{28224}{28256}可能就会输出一些奇怪的东西
{28278}{28374}   好 让我们来看看怎么匹配这些行
{28395}{28457}首先先跑个 `head`
{28561}{28738}嗯...让我们从头开始构造这个 pattern
{28800}{28874}显然我们不想 `\` 满地跑
{28886}{28997}因此首先我们整个 `-E`
{29004}{29069}这些行是这样一个形式
{29073}{29096}先是 `from`
{29097}{29199}有些写了 `invalid` 
{29235}{29283}有些又没有 是吧
{29284}{29348}那这里的问号就是匹配 0 或 1 次`
{29349}{29422}那这样写就是说
{29440}{29561}0 或 1 个 invalid 后面跟个空格
{29577}{29622}然后是 `user`……？
{29666}{29788}啊——多了个空格 可不敢乱多
{29837}{29888}然后后面有个我们想要的用户名
{29913}{30004}然后后面是...
{30005}{30088}然后后面是个 IP 地址
{30116}{30183}这里我们可以用区间语法
{30184}{30266}这个的意思就是 匹配 `0` 到 `9` 或者 `.` 
{30285}{30422}而且我们要匹配多次
{30468}{30534}然后后面是 `port`（端口）
{30535}{30583}所以我们匹配一个字面意思的字符串 `port` 
{30596}{30747}然后再来一次数字 `0` 到 `9`，匹配多次
{30828}{30878}除此之外我们还要做一件事
{30879}{30944}我们要给表达式打锚点
{30954}{31028}正则表达式里有两个特殊字符 
{31040}{31145}`^` 匹配行开头
{31158}{31217}而 `$` 匹配行结尾
{31253}{31295}那我们这样写
{31296}{31383}就代表着这个正则表达式匹配了一整行
{31413}{31459}为什么要这样写呢
{31460}{31534}假设有个人把它的用户名
{31535}{31594}设成了这一整条日志文本
{31626}{31677}那当你匹配的时候
{31678}{31774}就会匹配到用户名
{31788}{31822}坏耶——`
{31838}{31928}一般来说锚点能加尽量加
{31929}{31968}避免这种偶然事件发生
{31988}{32025}现在让我们来看看
{32026}{32064}跑这个命令有什么效果
{32065}{32109}这个命令删掉了好多行
{32110}{32144}但还是留下来了一些
{32150}{32246}例如这个 最后有个 `[preauth]`
{32268}{32301}那我们把它炖了吧
{32302}{32485}空格，`preauth`，方括号
{32486}{32526}方括号是特殊字符要转义
{32558}{32574}好耶
{32584}{32657}再多来几行呢
{32694}{32749}啊 还是有奇怪的东西
{32750}{32795}这些行非空
{32796}{32849}那就意味着 pattern 和它不匹配
{32888}{32924}拿这个来说
{32925}{33013}它写的是 `authenticating` 而不是 `invalid`
{33033}{33058}好吧
{33100}{33164}改成 `authenticating` 或者 `invalid` 之一
{33165}{33214}匹配零次或一次
{33215}{33266}现在如何
{33312}{33348}看上去挺稳的
{33385}{33462}但是这个输出没太大用啊
{33480}{33535}它只是成功地
{33536}{33596}把日志的每一行都清空了
{33597}{33640}这不太有用啊

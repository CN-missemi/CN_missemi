{66647}{66727}稍等，让我试着修一下这个锅
{66834}{66935}运行这个试试，啊！
{67008}{67058}显然，fish 不想让我这么做
{67061}{67240}看， `BEGIN` 在第一行的开头被匹配到
{67242}{67389}`END` 在最后一行的末尾被匹配到
{67405}{67514}然后这些是普通的逐行匹配正则
{67516}{67552}所以，我写的这些意思是
{67554}{67651}在第零行开始， `rows` 这个变量被赋值为 0
{67652}{67723}对于能匹配这个规则的文本行
{67724}{67774}`rows` 的值就会增加
{67775}{67859}当你匹配完最后一行的时候
{67860}{67918}就把 `rows` 这个变量的值打印出来
{67932}{68014}这和运行 `wc -l` 差不多
{68016}{68059}但是这些都是用 awk 运行的
{68061}{68161}通常 `wc -l` 就有不错的效果
{68163}{68243}但是如果你想做些别的
{68244}{68343}比如维护一个字典或者 map [*]
{68345}{68399}或者统计一些数据
{68400}{68520}再或者是…我想找第二个符合匹配的结果
{68521}{68576}所以你需要一个有状态的匹配器
{68577}{68623}比方说忽略匹配到的第一个结果
{68624}{68689}从第二个符合条件的结果开始逐个输出
{68690}{68800}这样的话，懂几行 awk 就很有用了
{68897}{68966}实际上，在现在这种情况下
{68967}{69013}我们可以撇掉之前处理文件使用的
{69014}{69167}`sed sort uniq` 和 `grep` 这些命令
{69168}{69209}然后用 awk 取而代之
{69210}{69259}但你大概不愿意这样做
{69260}{69353}这样做不值得，反倒可能让你很痛苦
{69406}{69515}再来说一说命令行里
{69518}{69587}别的非常好用的工具
{69588}{69689}首先是一个很方便的程序，叫做 bc
{69690}{69776}或许 bc 是 **B**erkeley **C**alculator?
{69777}{69802}我想应该是吧
{69803}{69841}`man bc`
{69880}{69956}我想 bc 应该是起源于 Berkeley calculator 吧？
{69966}{70051}无所谓了，它是一个简洁的命令行计算器
{70052}{70115}它并没有给你个提示符，让你输入
{70116}{70165}而是直接从标准输入读数据
{70166}{70304}所以我能这样 `echo "1 + 2" | bc -l` 
{70305}{70369}（要加 `-l`）因为好多这样的程序
{70370}{70479}默认的运行模式都很不智能
{70536}{70610}好，它输出了 3
{70611}{70654}哇，太强了
{70670}{70731}同时这也说明它用起来挺方便的
{70732}{70823}想象一下，你有一个有很多行的文件
{70824}{70956}比如说，唔，不知道整啥好了
{70991}{71052}比方说，在这个文件里
{71053}{71230}我想把登录的次数加起来
{71231}{71318}把出现不止一次的名字个数加起来
{71319}{71461}这里写，第一个匹配组的内容不为 1
{71474}{71558}然后只把这个次数输出
{71612}{71665}程序就会告诉我
{71666}{71755}所有登录了不止一次的用户都登录了几次
{71756}{71837}然后我还想了解一下总数是多少
{71838}{71887}注意我不能只数一下有多少行
{71888}{71924}这样是有问题的，对吧
{71925}{72028}因为每一行都有对应的次数，我得把他们都加起来
{72029}{72088}那么，我可以用 `paste` 命令
{72089}{72157}一边粘贴输入，一边附上加号
{72158}{72288}这样就把所有行用 `+` 连接成了一行加法式
{72317}{72388}这就是一个算术表达式
{72389}{72468}这样就可以把它 pipe 到 `bc -l` 
{72469}{72610}可以看到，总共有十九万一千多个用户名
{72611}{72703}登录了不止一次
{72704}{72796}你可能并不关心这个结果
{72797}{72926}这只是展示一下你可以轻松提取这些数据
{72994}{73073}你还可以用这些数据做很多别的事
{73074}{73187}有用来计算和统计输入数据的工具
{73206}{73301}比如说，对于刚刚这列数字
{73302}{73393}这样，我们重新只输出数字
{73419}{73481}按顺序输出数字
{73508}{73636}然后我可以用 R 跑一下
{73637}{73683}R 是一门独立的编程语言
{73684}{73761}针对数据的统计分析而设计
{73783}{73833}我可以这样写
{73852}{73915}看看我能不能搞对
{73935}{74093}它也是一个新的编程语言，你要专门去学
{74141}{74250}先假设你会用 R，但也可以 pipe 给别的语言
{74475}{74616}这样我就得到了一个输入数字的统计结果
{74642}{74768}所以各用户名登录次数的中位数是 3
{74784}{74863}最大值是一万多，我们之前看过了，这个是 root 产生的
{74864}{74912}还告诉我平均值是 8
{74947}{75004}这些在目前的这个例子里可能没有意义
{75005}{75053}这些不是什么有意义的数据
{75054}{75148}但是，处理比如统计脚本的输出，或者别的一些
{75157}{75234}会有明显数值分布的数据时
{75235}{75326}如果你想看这种数据，这些工具就有用了
{75381}{75455}我们甚至可以画个简单的图表
{75506}{75556}这里是一堆数字
{75565}{75713}我们回到前面，`sort -nk1,1`
{75723}{75823}然后只保留，就最前面五个吧
{75862}{75934}`gnuplot` 是一个画图表的工具
{75947}{76017}可以接受标准输入
{76126}{76214}我不期望你们都会这些编程语言
{76263}{76345}毕竟他们都是实打实的一门门编程语言
{76356}{76414}只是展示一下你的工具选择
{76502}{76565}现在这就有了一个大直方图
{76566}{76661}是前五个用户，自从 1 月 1 日开始
{76662}{76768}都各被用了多少次的图表
{76818}{76870}这只用了一行命令
{76896}{77011}虽然它特别长特别复杂，但只用一行就可以
{77144}{77224}这节课的最后我再说两句
{77225}{77321}还有两种特别的数据处理
{77334}{77450}首先是命令行参数的处理
{77475}{77646}有时候你会遇到一些情况……
{77647}{77747}比如上节课讲过的 `find` 命令
{77748}{77816}会产生一连串的文件名
{77817}{77927}或者一些命令可能产生一连串的……
{77995}{78064}参数，传给你的评测脚本
{78065}{78150}比如你想带上有特定数值分布的参数运行
{78151}{78181}比如你有一个脚本
{78182}{78287}会给一个程序提供它迭代次数的数值
{78288}{78359}然后你想让这组数值呈指数分布之类的
{78360}{78440}然后这个脚本会逐行输出每个迭代次数
{78441}{78527}你想要照此依次运行程序
{78528}{78608}正好，这有个叫 `xargs` 的工具是你的好帮手
{78614}{78800}`xargs` 接受若干行输出，把它们转为参数形式
{78816}{78950}这可能有点怪，我看看有啥好例子吗
{78951}{79014}这样，我会用 Rust 编程[*]
{79015}{79132}Rust 允许你安装前后多个版本的编译器
{79133}{79225}在这里你可以看到稳定版、Beta 版
{79226}{79328}还有几个早期的稳定发布版
{79329}{79390}还有一堆过期了的 nightly 版本
{79400}{79447}这功能还挺不错的
{79448}{79486}但是很长时间过去之后
{79487}{79580}就不需要留着这些 nightly 版本了
{79581}{79650}像这种去年三月份的
{79651}{79682}我可以删掉这些
{79683}{79753}我从今往后可能还想清理一下
{79776}{79855}这是一个多行的列表
{79862}{79904}我可以先找出 nightly
{79940}{80033}我可以去掉……`-V` 是不要匹配
{80080}{80148}我不想匹配最新的 nightly
{80159}{80251}好，这是一些有年头的 nightly

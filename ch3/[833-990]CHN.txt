【833】 稍等，让我试着修一下这个锅

运行这个试试，好耶

显然， fish 不想让我这么做

呃，看这， BEGIN 这里是只匹配第零行的特殊标识

 END 这里是匹配最后一行下一行的特殊标识

然后这些是平平无奇的逐行匹配

【841】 所以，我写的这些意思是

第零行的时候给 rows 这个变量赋值成 0

每行如果找到了这样的文本

 rows 的值就会增加

当你匹配完最后一行的时候

就把 rows 这个变量的值打印出来

【847】 这和运行 `wc -l` 差不多

但是这些都是用 awk 运行的

通常 `wc -l` 就能达到不错的效果

但是如果你想做些别的

比如维护某些 dictionary 或者 map 

或者统计一些数据

再或者是我想找第二个符合匹配的结果

【855】 所以你需要一个灵活的匹配器

比方说忽略匹配到的第一个结果

从第二个符合条件的结果开始逐个输出

这样的话，懂几行 awk 小程序就很有用了

实际上，在这种模式下

我们可以撇掉平时常用的

例如 sed sort uniq 和 grep 这些命令

来生成这些文档

【863】 然后用 awk 取而代之

但你应该不会这么做

这么做不值得，反倒可能让你很痛苦

那我来介绍下其它便于在命令行里用的小东西

首先介绍一个很方便的程序叫做 bc 

【870】 或许 bc 是 Berkeley calculator ?

【871】 我想应该是吧

 `man bc` 

我想 bc 应该是起源于 Berkeley calculator 吧

不管咋说，它是一个简洁的命令行计算器

它并没有给你个提示符

而是直接从标准输入读入数据

所以我能这样 `echo "1 + 2" | bc -l` 

因为很多程序通常会用挺傻的傻瓜模式运行

然后他在这输出了一个3

哇，震撼我妈

【881】 同时这也说明它用起来挺方便的

想象一下，你有一个里面有很多行的文件

比如说，额，不知道整啥好了

那就比方说，在这个文件里

我想把登录的次数加起来

把出现不止一次的名字个数加起来

找到那些次数不为 1 的用户名

【889】 然后把次数输出

程序就会告诉我所有登录了不止一次的用户到底登录了多少次

然后我还想了解一下有多少这样的用户

注意一下，我不能只数一下有多少行

这样会得到错误的结果，对吧

因为每一行都有对应的次数，我得把他们都加起来

那么，我可以用 paste 命令

一边把上一行的粘贴过来一边加上加号

【897】 最后 paste 命令就把所有数字用 + 连接在了一起，对吧？

这就是我们得到的一个算术表达式

然后我们就可以把它 pipe 到 `bc -l` 

我们得到总共有十九万一千多个用户名登录了不止一次

你可能并不关心这个结果

但是这只是展示一下你可以轻松提取这些数据

【907】 你还可以用这个做很多别的事

打个比方，

【917】 

【927】 

【937】 

【947】 

【957】 

【967】 

【977】 

【987】 

【990】
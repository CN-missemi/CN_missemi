【833】 稍等，让我试着修一下这个锅

运行这个试试，啊！

显然，fish 不想让我这么做

看， `BEGIN` 在第一行的开头被匹配到

`END` 在最后一行的末尾被匹配到

然后这些是普通的逐行匹配正则

【841】 所以，我写的这些意思是

在第零行开始， `rows` 这个变量被赋值为 0

对于能匹配这个规则的文本行

`rows` 的值就会增加

当你匹配完最后一行的时候

就把 `rows` 这个变量的值打印出来

【847】 这和运行 `wc -l` 差不多

但是这些都是用 awk 运行的

通常 `wc -l` 就有不错的效果

但是如果你想做些别的

比如维护一个字典或者 map [*]
* 可以类比 Python 里这两个术语的概念

或者统计一些数据

再或者是…我想找第二个符合匹配的结果

【855】所以你需要一个有状态的匹配器

比方说忽略匹配到的第一个结果

从第二个符合条件的结果开始逐个输出

这样的话，懂几行 awk 就很有用了

实际上，在现在这种情况下

我们可以撇掉之前处理文件使用的

`sed sort uniq` 和 `grep` 这些命令

【863】然后用 awk 取而代之

但你大概不愿意这样做

这样做不值得，反倒可能让你很痛苦

再来说一说命令行里

别的非常好用的工具

首先是一个很方便的程序，叫做 bc

【870】或许 bc 是 **B**erkeley **C**alculator?

我想应该是吧

`man bc`

我想 bc 应该是起源于 Berkeley calculator 吧？

无所谓了，它是一个简洁的命令行计算器

它并没有给你个提示符，让你输入

而是直接从标准输入读数据

所以我能这样 `echo "1 + 2" | bc -l` 

（要加 `-l`）因为好多这样的程序

默认的运行模式都很不智能

好，它输出了 3

哇，太强了

【881】同时这也说明它用起来挺方便的

想象一下，你有一个有很多行的文件

比如说，唔，不知道整啥好了

比方说，在这个文件里

我想把登录的次数加起来

把出现不止一次的名字个数加起来

这里写，第一个匹配组的内容不为 1

【889】然后只把这个次数输出

程序就会告诉我

所有登录了不止一次的用户都登录了几次

然后我还想了解一下总数是多少

注意我不能只数一下有多少行

这样是有问题的，对吧

因为每一行都有对应的次数，我得把他们都加起来

那么，我可以用 `paste` 命令

一边粘贴输入，一边附上加号

【897】这样就把所有行用 `+` 连接成了一行加法式

这就是一个算术表达式

这样就可以把它 pipe 到 `bc -l` 

可以看到，总共有十九万一千多个用户名

登录了不止一次

你可能并不关心这个结果

这只是展示一下你可以轻松提取这些数据

【907】你还可以用这些数据做很多别的事

有用来计算和统计输入数据的工具

比如说，对于刚刚这列数字

【913】这样，我们重新只输出数字

按顺序输出数字

然后我可以用 R 跑一下

R 是一门独立的编程语言

针对数据的统计分析而设计

我可以这样写

看看我能不能搞对

它也是一个新的编程语言，你要专门去学

先假设你会用 R，但也可以 pipe 给别的语言

这样我就得到了一个输入数字的统计结果

【926】所以各用户名登录次数的中位数是 3

最大值是一万多，我们之前看过了，这个是 root 产生的

还告诉我平均值是 8

这些在目前的这个例子里可能没有意义

这些不是什么有意义的数据

但是，处理比如统计脚本的输出，或者别的一些

【933】会有明显数值分布的数据时

如果你想看这种数据，这些工具就有用了

我们甚至可以画个简单的图表

这里是一堆数字

我们回到前面，`sort -nk1,1`

然后只保留，就最前面五个吧

`gnuplot` 是一个画图表的工具

可以接受标准输入

我不期望你们都会这些编程语言

毕竟他们都是实打实的一门门编程语言

只是展示一下你的工具选择

现在这就有了一个大直方图

是前五个用户，自从 1 月 1 日开始

都各被用了多少次的图表

这只用了一行命令

虽然它特别长特别复杂，但只用一行就可以

【954】这节课的最后我再说两句

还有两种特别的数据处理

首先是命令行参数的处理

有时候你会遇到一些情况……

比如上节课讲过的 `find` 命令

会产生一连串的文件名

或者一些命令可能产生一连串的……

参数，传给你的评测脚本

比如你想带上有特定数值分布的参数运行 # REVIEW 这句子太长了要不要考虑拆成两个小句

比如你有一个脚本

会给一个程序提供它迭代次数的数值

然后你想让这组数值呈指数分布之类的

然后这个脚本会逐行输出每个迭代次数

你想要照此依次运行程序

正好，这有个叫 `Xargs` 的工具是你的好帮手

`xargs` 接受若干行输出，把它们转为参数形式

这可能有点怪，我看看有啥好例子吗

这样，我会用 Rust 编程 [*]
* 一门系统编程语言，由 Mozilla 主持推动。

Rust 允许你安装前后多个版本的编译器

在这里你可以看到稳定版、Beta 版

还有几个早期的稳定发布版

还有一堆过期了的 nightly 版本

这功能还挺不错的

但是很长时间过去之后

就不需要留着这些 nightly 版本了

像这种去年三月份的

【990】我可以删掉这些

我从今往后可能还想清理一下

这是一个多行的列表

我可以先找出 nightly

我可以去掉……`-V` 是不要匹配

【995】我不想匹配最新的 nightly

好，这是一些有年头的 nightly


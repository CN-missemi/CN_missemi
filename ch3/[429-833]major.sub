{33650}{33722}相反我们真正想要做的是
{33723}{33802}当我们在这里匹配用户名时
{33809}{33892}我们更想要记录下来用户名是什么
{33893}{33947}因为这是我们想要输出的内容
{33983}{34046}在正则表达式中做这件事的方法
{34056}{34134}是用一个叫「捕获组」的玩意（Capture Groups）
{34161}{34273}「捕获组」用来表示
{34274}{34369}我想要记住这个值
{34377}{34416}并在之后使用
{34423}{34480}在正则表达式中
{34481}{34566}任何圆括号括起来的表达式
{34575}{34624}就是这样一个捕获组
{34629}{34688}所以我们已经在这里用了一个了
{34704}{34794}这是第一组，现在我们在这儿再建第二组
{34810}{34898}注意这些括号并不影响匹配
{34920}{34958}对吧？因为它们仅仅表达了
{34959}{35011}将这个表达式作为一个单元
{35012}{35069}但它的后面没有任何修饰符
{35070}{35111}所以还是只匹配一次
{35156}{35284}然后捕获组有用的原因是
{35289}{35376}你可以在替换式（replacement）中使用它
{35385}{35429}这样，在这里的替换式处
{35430}{35489}我可以键入 `\2` [*]
{35498}{35583}这是你指代捕获组编号的方法
{35590}{35643}这里我写的意思是
{35644}{35683}先匹配整行
{35690}{35866}之后在替换式处放入你在第二个捕获组匹配到的值
{35883}{35936}好的，记住这是第一个捕获组
{35945}{35975}这是第二个
{36023}{36066}现在它给了我所有的用户名
{36083}{36145}现在来看看写出来的表达式
{36146}{36229}它还挺复杂的，对吧
{36235}{36275}当我们一步步地完善它之后
{36276}{36304}你现在可能会明白
{36306}{36353}为什么它必须是它现在这个样子
{36354}{36406}但要搞懂代码执行起来如何
{36407}{36458}其实并不是很直观的事情
{36464}{36619}这就是正则表达式调试器的用武之地了
{36641}{36673}我们这里有一个
{36681}{36795}网上有很多，这个我已经提前填好了
{36796}{36852}我们刚刚用过的表达式
{36853}{36990}注意到，它上面显示了所有的匹配结果
{37007}{37147}这个窗口配这个字体，字太小了
{37162}{37310}但是如果我……这里，这个注释说
{37311}{37450}`.*` 匹配所有字符 0 次到任意次
{37470}{37580}后面是 `Disconnected from` 这几个词
{37589}{37625}后面是一个捕获组
{37626}{37685}下面还有各种别的
{37692}{37741}这是一个功能
{37742}{37803}它还允许你指定测试字符串
{37804}{37929}之后对给定的每个测试串跑正则表达式
{37933}{38030}并且像这样给不同的捕获组着色
{38051}{38158}这里，我们将用户作为一个捕获组，对吧
{38213}{38265}它显示整个串都匹配到了
{38266}{38325}整个串是蓝色的所以匹配完成
{38337}{38389}绿色部分是第一个捕获组
{38395}{38440}红色是第二个捕获组
{38445}{38477}这是第三个
{38487}{38555}因为 preauth 也被括号括起来了
{38577}{38669}这会是一个调试正则表达式的好方法
{38670}{38777}例如如果我放 Disconnected from……
{38822}{38901}我们这里新添一行
{38993}{39070}如果我把 Disconnected from 作为用户名
{39131}{39216}好吧现在这行已经有这个用户名了
{39231}{39276}我这是未卜先知
{39293}{39346}你会注意到利用这种匹配模式
{39378}{39462}这不再是一个问题
{39465}{39513}因为它正确地匹配了用户名
{39521}{39773}如果我们把这整行或这行变成用户名会发生什么
{39801}{39843}如你所见
{39919}{39955}真让人摸不着头脑
{40008}{40092}将正则表达式调对会很痛苦
{40111}{40175}它现在尝试匹配……
{40200}{40257}它匹配到的第一个组
{40258}{40361}也就是用户名，似乎是第一个 invalid
{40394}{40429}啊，第二个 invalid
{40430}{40462}因为它是贪心的
{40475}{40517}通过在这里加一个 `?`
{40527}{40569}我可以将它变为非贪心的
{40589}{40721}所以如果你在 `+` 或者 `*` 后加 `?`
{40730}{40790}它会变成非贪心匹配
{40791}{40856}也就是不会尽可能地向后匹配
{40865}{40923}这样你可以看到，这个串被正确地解析了
{40935}{41049}因为 `.*` 匹配会在第一个 Disconnected from 处停止 [*]
{41055}{41143}也就是 SSH 指令固定输出的那个
{41153}{41207}是实际出现在我们记录中的那一个
{41297}{41374}讲到现在，你大概也发现了
{41375}{41452}正则表达式会非常复杂
{41459}{41530}你也很可能会在你写的匹配模式中
{41531}{41589}用到各种各样迷惑的修饰符
{41598}{41651}真正学会它的唯一方式
{41652}{41699}是从简单的表达式开始
{41700}{41721}之后堆砌起来
{41722}{41755}直到它匹配到你想要的
{41767}{41851}通常你仅仅是在做一些一次性工作
{41852}{41897}比如刚才我要提取用户名
{41898}{41988}你不需要去考虑那么多特殊情况，对吧
{41992}{42095}你不需要考虑某人的 SSH 的用户名
{42096}{42149}完美地匹配了登录记录的格式
{42165}{42214}这也不算什么大事
{42215}{42269}因为你只是找用户名而已
{42283}{42326}正则表达式确实很强大
{42327}{42422}处理的内容很重要的时候，记得万分小心
{42435}{42455}你要提问吗？
{42635}{42764}总之正则表达式默认只逐行匹配
{42799}{42878}它不会跨行匹配
{43124}{43199}所以 sed 运行的方式是
{43200}{43255}它逐行处理
{43269}{43399}所以 sed 会对每一行匹配这个表达式
{43493}{43583}好，正则表达式或者模式相关问题到此为止
{43584}{43622}它是一个复杂的模式
{43623}{43709}所以如果感到迷惑，别担心
{43710}{43769}课上完了，回去在调试器中看一看
{44103}{44170}所以记住
{44171}{44204}我们在这里假设
{44205}{44306}用户只能控制他们的用户名，对吗？
{44337}{44377}所以他们能做的最坏的事
{44378}{44468}就是把这种整条记录设为用户名
{44469}{44528}我们看会发生什么
{44627}{44665}好的，这是运行结果
{44666}{44788}它的原因是，`?` 意味着
{44789}{44848}我们一遇到 Disconnected (from) 这个词
{44857}{44908}就立刻匹配后面的模式，对吧
{44950}{45065}第一个 Disconnected 是 SSH 自己输出的
{45066}{45125}一定在用户可编辑的内容之前
{45137}{45181}所以在这个特例下
{45182}{45252}即使这样也不会干扰模式串
{45258}{45274}你要提问吗？
{45297}{45446}_（学生有关模式串的数据安全性的问题）_
{45483}{45611}啊，如果你在写一个……
{45612}{45701}这种比较怪的的匹配模式……
{45708}{45782}总的来说，你在做数据整理的时候
{45783}{45885}一般它不会涉及（信息）安全
{45890}{45969}但你很可能会得到很怪异的数据
{45984}{46036}所以如果你在做一些像
{46037}{46064}绘制图表之类的事
{46065}{46109}你可能会丢掉重要的数据点
{46110}{46169}你可能解析出错误的数值
{46170}{46288}之后你的表突然出现了原始数据中没有的数据点
{46289}{46321}所以重要的是
{46322}{46417}如果你发现你在写一个复杂的正则
{46418}{46459}多检查几下
{46460}{46513}它匹配出来的是不是你想要的
{46514}{46589}即使它与信息安全无关
{46677}{46705}和你想的一样
{46706}{46779}这些模式串可能会非常复杂
{46780}{46855}例如这里有一个讨论
{46856}{46945}关于如何用正则表达式匹配一个 email 地址
{46956}{46999}你可能会想到像这样的
{47001}{47082}这是一个非常直观的表达式
{47083}{47237}只是字母，数字，一些字符，后面一个 `+`
{47238}{47343}因为在 Gmail 里，email 地址里可以有 `+` [*]
{47367}{47530}这里的 `+` 只表示任何这些字符至少出现一个
{47537}{47609}因为你不会有一个 @ 前为空的 email 地址
{47618}{47683}后面域名的规则也差不多，对吧
{47696}{47809}顶级域需要至少两个字符并且不能包括数字
{47816}{47895}你可以是 .com 但是不能是 .7
{47928}{47996}事实上这并不完全正确
{47997}{48097}这里有一堆有效的 email 地址不会被它匹配
{48098}{48175}还有一堆无效的 email 地址会被它匹配
{48188}{48316}所以有很多很多建议
{48317}{48398}还有热心网友写了的完整的测试套件
{48399}{48476}尝试判断哪一个正则表达式是最好的
{48531}{48609}这是一个专门给 URL 的
{48610}{48670}这是类似的给 email 的
{48671}{48731}他们发现最好的就是这个
{48776}{48851}我不建议你去试着理解这个模式串 [*]
{48857}{48982}但这个很明显会几乎完美的匹配到
{48983}{49086}像符合互联网标准的 email 地址
{49087}{49125}就是所说的有效 email 地址
{49132}{49224}它还包含 Unicode 里奇奇怪怪的编码
{49231}{49321}这只是想说明正则表达式可以非常长
{49328}{49373}如果最后你写出像这样的表达式
{49374}{49433}很可能会有更好的方式去做
{49461}{49576}比如，如果你自己在试着解析 HTML 
{49577}{49751}或者解析 JSON 格式，对于这种格式来说
{49752}{49793}去用其它工具大概会比较好
{49802}{49879}我们也有这样的练习
{49883}{49940}不是用正则表达式，提醒你
{50039}{50142}这里有各种各样的建议
{50143}{50233}还非常非常深入地展示了它的运行过程
{50234}{50314}如果你想查阅，它在课程笔记里
{50408}{50479}好的，我们有了这些用户名
{50502}{50545}让我们回到数据整理
{50546}{50597}像这列用户名
{50607}{50671}它仍然对我很不友好，对吗？
{50672}{50717}让我们看看总共有几行
{50718}{50782}如果我键入 `wc -l`
{50798}{50831}这有……
{50903}{50965}一十九万八千行
{50974}{51043}这个 `wc` 是计数程序（**w**ord **c**ount）
{51044}{51100}`-l` 选项是统计行数
{51112}{51164}所以这么多行
{51165}{51266}如果我只是边翻边看，意义也不大
{51270}{51329}对吧，我需要的是统计数据
{51330}{51382}我需要找个方法合计数据
{51476}{51541}虽然 `sed` 这个工具用途很广
{51542}{51587}它支持一个完整的编程语言
{51588}{51673}可以做一些，比如插入文本
{51674}{51739}或者只输出匹配行的操作
{51740}{51831}但它不是应付一切的完美工具，明白吗
{51832}{51884}有时候有更好的选择
{51885}{51944}就比如说，你可以用 `sed` 
{51945}{51995}编程实现行数统计
{51996}{52039}但绝对别这么干
{52040}{52096}除了搜索替换之外
{52097}{52144}`sed` 的语法挺烂的
{52194}{52251}但是，还有别的好用的工具
{52252}{52347}比如有个叫 `sort` 的
{52427}{52486}虽然它泛用性不高
{52487}{52565}`sort` 会接受很多行的输入
{52573}{52632}排一个序，然后输出到输出流
{52649}{52759}现在，我有了这个排序后的列表
{52760}{52853}它仍然有二十万行，所以还不是很好
{52868}{52974}但现在我可以把 `uniq` 结合进来
{52985}{53011}这个工具 `uniq` 
{53012}{53089}作用在多行有序的输入上
{53099}{53182}输出去重后的输入
{53189}{53277}也即，如果你有重复的行
{53282}{53321}这些行只会被打印一次
{53336}{53408}我可以执行 `uniq -c`
{53417}{53580}意为，对重复的行，计算它们重复的数量
{53581}{53612}然后将其（从输出中）去除
{53628}{53654}这会输出什么呢？
{53662}{53771}呃，如果我执行它，会处理一会
{53780}{53878}里边有 13 个 `zzz` 用户名
{53879}{53973}10 个 `zxvf` 用户名，等等
{53978}{54022}我可以上下翻看
{54023}{54083}这仍是一个很长的表单，对吧
{54084}{54202}但现在，至少比原来稍微条理点了
{54209}{54281}看看现在我们提出来多少行
{54393}{54480}好，两万四千行，仍然很多
{54481}{54530}虽然对我而言，这些信息没用
{54539}{54624}但我可以用更多工具，不断缩减它
{54638}{54703}比如我可能想知道
{54704}{54769}哪个用户名出现的最多
{54789}{54845}我可以再排个序
{54856}{54996}我想要对输入的第一列做数值排序
{55019}{55098}所以 `-n` 意为数值排序
{55099}{55154}`-k` 允许你在输入中
{55155}{55263}选中空白字符分隔的一列，执行排序
{55269}{55351}这里我加了一个 `,1` 的原因是
{55352}{55457}我想要计数第一列到第一列
{55472}{55501}除此之外我也可以要求
{55502}{55586}依据所有的列排序 [*]
{55598}{55663}但这里我只想用第一列
{55720}{55820}然后我只想要最后十列
{55821}{55961}`sort` 默认是以升序输出
{56011}{56093}所以计数最高的一条在最底下
{56094}{56158}然后我就只要最后十列
{56223}{56262}现在再跑的时候
{56270}{56344}我就有比较有用的数据了，对吧
{56345}{56476}它告诉我用户名 `root` 有一万多次登录尝试
{56481}{56633}用户名 `123456` 有四千多次
{56661}{56714}这就很棒了
{56738}{56907}现在这个大日志突然就给我有用信息了
{56912}{56986}这是我真正想从日志里要的信息
{56994}{57046}现在我可能就想，比如
{57047}{57129}快速地禁用一下我机器上
{57130}{57200}比如 SSH 登录的 `root` 用户名
{57223}{57271}顺便我也建议你们这样做
{57364}{57400}其实对于这个情况
{57401}{57460}我们不需要 `sort` 的 `-k`
{57474}{57567}因为 `sort` 默认按（从前到后的）列排序
{57568}{57619}而数字又恰巧是最前面一列
{57625}{57685}但了解这些额外的 flag 是有益的
{57708}{57794}你可能想问，我是怎么知道有这些 flag 的
{57795}{57854}我是怎么了解这些程序的存在的
{57873}{57945}嗯，通常这些程序是
{57946}{58009}在这种课堂上知道的
{58018}{58074}至于这些 flag
{58097}{58154}经常是，我想按照某个基准排序
{58155}{58205}但不是按整行
{58226}{58304}那你的第一反应是键入 `man sort`
{58305}{58343}然后把页面读一遍
{58359}{58407}你很快就能知道怎么能
{58408}{58457}优雅地选中一行
{58458}{58517}怎么能像这样，选这行数字
{58604}{58699}好，如果，我们现在有了这个……
{58700}{58749}就让它是前 20 的表单
{58779}{58836}假设我并不关心具体数量
{58845}{58938}我只要一个逗号分隔开的用户名表单
{58949}{58989}因为我可能打算通过电邮
{58990}{59065}每天都把它发给自己，之类的
{59066}{59170}像是《震惊！今天攻击者最喜欢的二十个用户名竟是...》
{59188}{59278}嗯，我可以这样——
{59372}{59431}好，出现了更多怪怪的命令
{59432}{59488}但了解它们都是有意义的
{59499}{59643}这个 `awk` 是基于列的流编辑器
{59656}{59734}我们提到了流编辑器 `sed`
{59741}{59835}它主要是编辑输入进来的文本 
{59843}{59960}此外，`awk` 也让你编辑文本
{59961}{60012}也是一个完整的编程语言
{60017}{60083}但它专注于基于「列」的数据
{60093}{60151}所以这里 `awk` 会以默认方式
{60152}{60262}解析空格分隔的输入
{60272}{60343}然后你可以分别处理这些行
{60350}{60415}我这里告诉它只打印第二行
{60422}{60476}就是用户名那行，对吧
{60531}{60568}`paste` 这个程序
{60572}{60659}能借助 `-s` 选项，将一大堆行的输入
{60662}{60725}处理成以 tab 分隔的一行
{60732}{60782}这里 `-d` 使其以 `,` 分隔，而不是 tab
{60819}{60895}这里，这个例子，我想要一个
{60896}{60970}逗号分隔的最靠前的用户名列表
{60989}{61057}然后我就可以物尽其用
{61068}{61132}比如我把它丢进一个配置文件
{61133}{61192}去禁止这些用户名啥的
{61258}{61341}`awk` 值得我多费几句口舌
{61342}{61430}讲白了，对于这样的数据整理
{61431}{61490}它是一个非常有力的语言
{61542}{61657}我简单说了这个 `print $2` 做什么
{61682}{61820}但你可以用 `awk` 施展一些绚丽的魔法
{61821}{61922}比如，我们先回到处理用户名这里
{61932}{62053}然后……我们还是执行 `sort` 和 `uniq` 吧
{62112}{62161}不然这个表单就太长了
{62172}{62254}然后让我们只输出那些
{62260}{62320}和特定模式相符的用户名
{62365}{62459}比如，让我想想……
{62591}{62643}`uniq -c`
{62666}{62834}我要只出现一次，并且
{62852}{62953}以 c 开头、e 结尾的所有用户名
{62985}{63040}虽然我们在搜索一个奇怪的东西
{63051}{63128}但在 `awk` 里面写出来还挺容易
{63134}{63200}我可以让第一列是 `1` 
{63236}{63403}并且第二列匹配这个正则
{63628}{63687}*好像这里只用 `.` 就行*
{63797}{63858}然后我想按整行打印
{63959}{63995}除非我搞错了什么东西
{64008}{64142}不然这就是所有以 c 开头，e 结尾
{64143}{64202}并且只出现了一次的用户名
{64256}{64352}虽然对数据做这种处理没有意义
{64358}{64417}但我在课上想讲的是
{64418}{64466}各种可以运用的工具
{64475}{64566}并且虽然我们举的例子很奇怪
{64567}{64626}但这个 pattern 并不复杂
{64636}{64753}这是因为某些 Linux 的工具
{64754}{64802}以及普遍的命令行工具
{64820}{64942}都是按照以行为单位的输入输出而设计
{64947}{65054}并且这些行经常会分为多列
{65055}{65127}而 `awk` 就是处理列的能手
{65339}{65509}`awk` 不仅能做这种匹配每行的操作
{65546}{65628}而且，比如说……
{65629}{65688}让我先输出一下行数
{65689}{65768}我想知道多少用户名符合这个模式
{65778}{65855}我可以执行 `wc -l`，这样就挺好
{65901}{65965}有 31 个这样的用户名
{65974}{66025}但 `awk` 是编程语言啊
{66040}{66178}这个黑魔法，你估计不会想去碰它
{66186}{66236}但要知道你可以运用
{66237}{66348}知道这些，对现在和以后都有益
{66426}{66516}在我屏幕上可能不太好读懂
{66518}{66554}我也发现了……
{66647}{66701}我马上处理一下

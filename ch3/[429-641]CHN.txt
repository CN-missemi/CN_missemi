【429】但是这不太有用

相反我们真正想要做的是

当我们在这里匹配用户名时

我们确实想要记住用户名是什么

因为这是我们想要输出的内容



【435】在正则表达式中

我们可以使用匹配组

它用来表示

我想要记住这个值

并在之后使用

在正则表达式中

【440】任何圆括号括起来的表达式

就是这样一个匹配组

这样实际上我们这里已经有一个了

这是第一组，现在我们在这儿再建第二组



【445】注意这些括号并不影响匹配

对吗？因为它们仅仅表达了

将这个表达式作为一个单元

但后面我们没做任何修改

所以还是只匹配一次

【450】然后匹配组有用的原因是

你可以在 replacement 中回顾它们

这样，在这里的 replacement 处

我可以键入 `\2` [*]
[*] 在部分编辑器中使用 `$2`

【455】这是你指代匹配组编号的方法

既然这样，我正在表达

先匹配整行

之后在 replacement 处放入你在第二个匹配组匹配到的值



【460】好的，记住这是第一个捕获组

这是第二个匹配组

这给了我所有的用户名

现在来看看写出来的表达式

它很复杂，好的，它可能现在有意义了

【465】当我们写过这个过程

它为什么必须是它现在这个样子

但是这似乎并不是很明显

这些命令行是如何运行的

这就是正则表达式调试器非常有用的地方了

【470】我们这里有一个

网上有很多，但是在这里我已经

提前填好了这个我们刚刚用过的表达式

注意到，它上面有

所有的匹配结果，

【475】其实因为前面框框的尺寸现在这个窗口有一点小

但是如果我……这里，这个注释说

.* 匹配所有字符

0 次到任意次

后面是 `Disconnected from` 这几个词

【480】后面是一个匹配组

之后滚轮你看到了所有的东西

这是一点

此外

它还允许你指定测试字符串

之后根据你给的每个测试串匹配这种模式



【485】

并且像这样给不同的匹配组着色

这里，我们将用户作为一个匹配组，对吗？

好的整个串匹配了对吗？

整个串是蓝色的所以匹配完成

【490】绿色部分是第一个匹配组

红色是第二个匹配组

这是第三个，

因为 preauth 也被括号括起来了

这会是一个调试你的正则表达式的有效方式

【495】例如如果我放 Disconnected from ……

我们这里新添一行

如果我把 Disconnected from 作为用户名

好吧现在这行已经有这个用户名了



【500】我想想之前的

你会注意到在这种模式下

这不再是一个问题

因为它已经匹配了用户名

如果我们把这整行或这行变成用户名会发生什么

【505】

如你所见

真让人摸不着头脑

这就是正则表达式很难写对的地方了

因为它现在在尽量的匹配

它匹配了用户名出现的第一个位置

【510】

或者第一个 `invalid` 但在这种情况下

去了第二个位置

因为它是贪心的，我可以将它变为非贪心

通过在这里加一个 ?

所以如果你在 + 或者 * 后缀上 ?

【515】它会变成非贪心匹配

它就不会尽量匹配更多的字符

之后你会看到

串被正确解析

因为 .* 匹配会在第一个 Disconnected from 处停止

【520】

这也正是被 SSH 发出的，

实际出现在我们日志中的那一个

讲到现在

你可以发现了



【525】正则表达式会非常复杂

并且你很可能会在你的模式串中

用到各种各样迷惑的修饰符

真正学会它们的唯一方式是从简单的表达式开始

【530】之后把它们堆起来直到它匹配到你所需要的



通常你仅仅是在做一些一次性的工作

像这里我们破解用户名时

你不需要去考虑所有特殊情况，对吗？

【535】

你不需要去想有人用 SSH 的用户名成功地

匹配了你的登录名格式，这可能并不是问题



因为你只是找出用户名

【540】

然而正则表达式确实很强大

而且你要格外仔细当你做一些真正重要的事



你要提问吗？

【545】总之正则表达式默认只逐行匹配

它不会跨行匹配

所以说它运行的方式是

它逐行运行

所以说我们会在每一行匹配这个表达式

【550】

好的，正则表达式或者模式相关问题到此为止

它是一个复杂的模式

所以如果感到迷惑别担心

完了在调试器中看一看

【555】所以记住

我们在这里假设

用户只能修改他们的用户名，对吗？

所以他们能做的最糟糕的事就是将像这样的整条



【560】变成他们的用户名，我们看会发生什么

好的，这是运行结果

它的原因是 ? 意味着

当我们遇到 Disconnected 关键词的瞬间

我们开始解析剩下的模式串，对吗？

【565】

第一个 Disconnected 的出现是由 SHH 打出

在任何用户编辑的内容前

所以在这个特例下

即使这样也不会干扰模式串

【570】啊，如果你在写一个……

这是一种旧的匹配模式……

总的来说，当你在做数据整理就好像

它和（信息）安全无关

并且它很可能意味着你会收到很迷惑的数据

【575】所以如果你在做一些像

绘制图表之类的事

你可能会丢掉重要的数据点

你可能解析出错误的数值

之后你的表突然出现了原始数据中没有的数据点

【580】

更多的是，如果你发现

你在写一个复杂的正则表达式

多检查几下

它匹配出来的是不是你想要的

【585】即使它与信息安全无关

正如你所想这些模式串可以非常复杂

例如这里有一个讨论

关于你可以如何用正则表达式匹配一个 email 地址



【590】你可能会想到像这样的

这是一个非常直接的表达式

只是字母，数字，. % 后面一个 +



因为在 Gmail 中你可以在 email 地址后缀 +

【595】

这里的 + 只表示任何这些字符至少出现一个

因为你不会有一个 @ 前为空的 email 地址



【600】后面的域也是一样的，对吗？

顶级域需要至少两个字符并且不能包括数字



你可以是 .com 但是不能是 .7



【605】事实上这并不完全正确

这里有一堆有效的 email 地址不会被它匹配



还有一堆无效的 email 地址会被它匹配



【610】所以有很多很多建议

这里是人们建的

完整的测试套件，尽力去找出

哪一个正则表达式是最好的

这是一个专门给 URL 的

【615】这是类似的给 email 的

他们发现最好的就是这个

我不建议你去试着理解这个模式串

但这个很明显会几乎完美的匹配到

像符合互联网标准的 email 地址

【620】就是所说的有效 email 地址



它囊括了所有迷惑的编码点

这只是想说明正则表达式可以非常长



【625】如果最后你写出像这样的表达式

很可能会有更好的方式去做

比如，如果你发现自己试着解析

HTML 或者解析 JSON 串出现了类似表达式 #REVIEW ~635



【630】你可能得用其它工具了

这里有一些你需要做的练习

不是用正则表达式，提醒你

这里有所有的建议

它们让你深入它们的运行过程

【635】如果你想要查阅，它在讲座笔记里



好的，我们有了这些用户名

让我们回到数据整理

像这列用户名

【640】它仍然对我很不友好，对吗？

让我们看看总共有几行

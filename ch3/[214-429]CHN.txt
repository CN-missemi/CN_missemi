【214】但是你可能会疑惑

我在这写的这玩意是个啥

那个 `.*` 是干啥的

这实际上是正则表达式的一个例子

这东西你之前写程序可能见过

但是你一旦用起命令行

你会发现这东西用得特别多

特别是对于像这样的数据处理

正则表达式是一个很有力的文本匹配方式

你不一定要把它用在文本上

但这是最普遍的用途

在正则表达式里

你有一把的特殊字符可以使用

【231】这些字符不一定匹配他们本身 #REVIEW 这里说的是 dont just match 但是翻译成“不仅”感觉不对劲

而可能匹配特定类型的字符

或者某个字符集里的字符

某种程度上来说它生成了一个程序 #REVIEW 

来在文本中进行查找

例如 `.` 这个字符

会匹配任意字符

而如果你在后面再加上一个 `*`

那他就会匹配零次或多次

前面这个字符*
*其实是前面这个规律

那么这个 pattern 所描述的就是

任意零个或多个字符

然后在后面跟着一个字符串 `Disconnected from`

我要找到这些字符串

然后把它们换成空的

正则表达式有一把像这样的特殊字符

各自有各自的含义

你可以按你想要的来

我说了个 `*`

这东西匹配零个或多个字符

还有一个 `+`

它会匹配一个或多个字符

那么这就意味着

我想要前面那个 pattern 匹配至少一次

此外还有方括号

可以让你匹配多种字符中的一种

好 我现在整个字符串 

里面写 `aba`

我想把 `a` 和 `b` 换成空的

那么我就让 pattern 去把

要么是 `a` 要么是 `b` 的字符

换成空的

就算我把第一个字符换成了 `b`

还是会输出 `ba`

那你可能就会想了

为啥它只替换一次呢

这是因为正则表达式

在默认模式下

每行只匹配一次，替换一次

这是**默认**模式下做的事

你可以再加个 `g` 修饰符

这样他就会尽量多匹配

然后整行就没了

因为每个字符都是 `a` 或 `b` 之一

如果我再加个 `c`

它就会去掉除了 `c` 之外的所有东西

如果我再在字符串里加个其它字符

它也会保留下来

【278】但是 `a` 和 `b` 都会被去掉

你还可以给他加点修饰符

跑这个命令会发生什么呢

它的意思是我想要把零个或多个 

`ab` 这个字符串

换成空的

那么这就意味着

单独的一个 `a` 不会被替换掉 

单独一个 `b` 也不会被替换掉

但是 `ab` 连一起

它就会被替换掉了

加上这个破东西试试...

这里加上 `-E` 是因为 `sed` 真的很老了

它只支持很旧版本的正则表达式

一般你要加上 `-E` 开关跑

这样他就会用一套支持更多东西的

更现代的语法

如果你不能使用 `-E` 开关跑

那你就得在括号前面加 `\`

来告诉它我想要特殊含义下的括号

不然他就只会匹配括号本身

那这可能就不是你想要的东西了

【302】注意它把这里的 `ab` 替换掉了

把这里的 `ab` 也替换掉了

但是把这个 `c` 

还有末尾的 `a`

留下来了

因为它和 pattern 不匹配

【307】你还可以把这些 pattern 任意组合 #REVIEW 

你可以给它加替代项 #REVIEW alternation 

例如你可以让它移除

任意匹配 `ab` 或 `bc` 的字符串

然后你会注意到这个 `ab` 没了

但是就算这个 `bc` 和 pattern 相匹配

它并没有被删除

这是因为 `ab` 已经被删除了

这里的 `ab` 被删掉了

`c` 还留着

这里的 `ab` 被删去了

这个 `c` 因为依然不匹配还留着

如果我把这个 `a` 删掉

这个 `ab` 的 pattern 

就不会匹配到这个 `b`

然后它就会被留下来

然后 `bc` 就会匹配到 `pc` 

随后就会被删掉

你刚开始接触的时候

正则会用起来很麻烦

【325】就算当你熟练之后

这东西看起来也很吓人

这也是为什么

人们常常会使用正则调试器的原因

这个东西后面会提到

但是让我们先来整个匹配日志

？

让我们先从文件里拿几行出来

那就拿五行吧

那我们可以看到

这几行现在是这样一个形式

但是我们只想要用户名

那么我们就会想把它写成这样...

等下 让我先给你看一个东西

我们先整出来

写着（顶部字幕）的这么一行*
*`Disconnected from invalid user disconnected from 84.211`

那么这是一条来自

叫做 `Disconnected from` 的用户的登录记录

（学生）少了个 `s`

少了个 `s` 吗？emmmm...

（学生）第一个 `Disconnected`

**`Disconnected`** 多谢

那么你会发现这个命令连用户名一起移除了

【352】这是因为像 `.*` 这种正则表达式 #REVIEW range expression 是否为口误；和 regex 什么关系（and/in）；参考 385

他们会采用贪心策略

去尽可能多的匹配

因此虽然我们在这里想保留用户名

但是这个 pattern 会一路匹配到它第二次

也就是最后一次出现

所以包括用户名在内

在这之前出现的文本都会被删掉

那么我们就要想一个

机智一点的方法来匹配

而不仅仅是使用 `.*`

这会使得当输入比较毒瘤的时候

可能就会输出一些奇怪的东西

好 让我们来看看怎么匹配这些行

首先先跑个 `head`

嗯...让我们从头开始构造这个 pattern

显然我们不想 `\` 满地跑

因此首先我们整个 `-E`

这些行是这样的一个形式

有些写了 `invalid` 

有些又没有 是吧

那这里的问号就是匹配 0 或 1 次

那我这样写 意思就是说

我想要 0 或 1 个 invalid 后面跟个空格

啊 多了个空格 可不敢乱多

然后后面有个我们想要的用户名

然后后面是...

然后后面是个 IP 地址

我们可以在这里用上区间语法

IP 地址由 0 到 9 以及 `.` 组成

而且要匹配多次 #REVIEW 意译

然后后面是 `port`（端口）

紧接着要匹配一个端口

那就再来一次数字 0 到 9，匹配多次

除此之外我们还要做一件事

我们要给表达式打锚点

正则表达式里有两个特殊字符 

`^` 匹配行开头

而 `$` 匹配行结尾

那我们这样写

就代表着这个正则表达式匹配了一整行

为什么要这样写呢

假设有个人把它的用户名

设成了这一整条日志文本

那当你匹配的时候

就会匹配到用户名

【406】坏耶

一般来说锚点能加尽量加

避免这种偶然事件发生

现在让我们来看看

跑这个命令有什么效果

这个命令删掉了好多行

但还是留下来了一些

例如这个 最后有个 `[preauth]`

那我们把它炖了吧

空格，`preauth`，方括号

方括号是特殊字符要转义

好耶

再多来几行呢

啊 还是有奇怪的东西

这些行非空

那就意味着 pattern 和它不匹配

拿这个来说

它写的是 `authenticating` 而不是 `invalid`

好吧

那 `authenticating` 或者 `invalid` 之一

匹配零次或一次

现在如何

看上去挺稳的

但是这个输出没太大用啊

它只是成功地

【429】把日志的每一行都清空了

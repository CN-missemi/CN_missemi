[1464]
这条 commit
既是 `dog` commit 的子节点
又是 `cat` commit 的子节点
所以从这个 commit 往回看
可以同时看到两条分支
而我们现在所在的这个 commit
同时有 `dog` 和 `cat` 两个 commit 里实现的功能
所以如果我们用 `cat` 参数跑 `animal.py`
它就会猫叫
如果用 `dog` 参数跑
它就会狗叫
如果用其他参数跑
它就会采取默认行为
所以 我们这里展示了
你要怎么分支出去
并行开发不同的部分
然后用 `merge` 命令
[1478]
把他们合到一起 #REVIEW `resolve those different branches`
来同时具有这几个并行开发的分支里实现的功能
然后我们来说一下合并时
会发生的一个冲突的问题
这些冲突会以冲突标记的形式在文本文件里出现
你可以手动解决这些冲突
而 git 也有一些高级的工具来帮助你解决冲突
[1491]
但我们只在课程笔记里具体地说明了 # REVIEW lecture note
并不会在这节课上展示
这就是 git 的分支和合并
有什么疑惑吗
没有啊 好耶
这节课的下一个部分
我们来聊聊 `git remote`
这是你与其他人 git 协作的一个方式
一个 git 仓库
也就是 `.git` 文件夹里的东西
代表了这个仓库的整个历史
里面有着所有对象文件和引用
[1502]
仓库的所有快照也都在里面
而你和其他人进行 git 协作的方式是
其他人也有整个 git 仓库的副本
而你可以让你本地的仓库实例
知道其他仓库的存在
这个概念在 git 里叫做 remote
而 `git remote` 命令
会列出所有它现在知道的远程仓库
而对于我们现在这个仓库
因为我们啥都还没告诉它
`git remote` 就啥也没打出来
现在它只知道它自己存在
实践上 在和别人协作的时候
你的 git 仓库会知道 GitHub 上也有个仓库
[1523]
然后就会有把你的修改发送到远程仓库
例如把修改发到 GitHub
和把例如 GitHub 上远程的修改
取回到本地的命令
在这一部分
我们并不会演示怎么注册 GitHub
登录 新建仓库
这些教程一搜一大把
我们这次就直接用
这台机器上另一个文件夹
把它当作 git remote
让我换到上一层目录
开个新的文件夹叫做 remote
然后用 `git init --bare` 初始化
[1544]
*--bare as a way to mark a repository as a storage facility, as opposed to a development environment
*`--bare` 告诉 git 这个仓库用来储存而不是开发
这些操作在你实际用远程操作的时候
并不会用到
*注意这里并没有 `.git` 文件夹
这样一波组合拳下来
我们就开出了一个
能拿来做远程仓库的文件夹
然后我们回到 `demo` 文件夹
再跑一次 `git remote`
啥都没有
但是我可以用 `git remote add` 这个功能
来让它知道有个远程仓库的存在
这个命令的格式是这样的
远程仓库有个名字 有个 URL
[1560]
我在这里根据~~老祖宗的决定~~
选了 `origin` 这个名字
一般只有一个远程仓库时就会选这个名字
然后 URL 这里
如果你用在线的托管服务的话
一般来说这里填的是
GitHub 或者 GitLab 这些给的 URL
而我们这里演示的
就只是本地机器上另一个仓库的路径
也就是上层目录里当成远程仓库的 `remote` 文件夹
我加完远程仓库了以后
我就能用许多的命令可以与这个仓库交互了
其中一个特别有用的
是 `git push` 命令
用来把本地的修改发给远程仓库
它还要输入远程仓库的名字
本地的分支名 冒号 远程仓库的分支名
它就会把远程仓库的分支
更新成本地这个分支名里的内容
如果远程没有这个分支的话就会开个新分支
[1585]
一个实际的例子是
我 push 到我唯一的一个远程仓库
叫做 `origin`
我看看我该 push 啥
看看历史图
我这有好多好东西可以 push
那我把我本地的 `master` 分支
push 到 `origin` 的同名分支
这样远程仓库会有一个这样的同名分支
然后跑起来
然后这里最后一行写了
我在远程仓库上面开了个新分支
本地的 master 指向远程的 master（右边）
* 视频上光标的移动和本地/远程的关系没有对应 #REVIEW 本地试过了
[1601]
然后我现在再跑 `git log`
它就会告诉我
我现在处在蓝色的 `HEAD` 这里
绿色的是我本地 git 仓库的最新 commit
然后我们看到这里有个我们没见过的红色玩意
代表着我本地副本所知道的
远程仓库的引用
这里 在远程仓库 `origin` 里
好巧不巧有个同名分支 `master`
和本地的 master 分支指向同一个 commit
[1612]
然后我现在把本地的副本修改一下
全部换成小写字母开头
然后跑 `git add animal.py` 和 `git commit`
用 `-m` 可以直接指定 commit message
就不会弹出来个编辑器了
然后现在再去看历史图
然后你就会注意到
这里多出来了个快照
这里面输出是小写开头的
但是 `origin/master` 没变
所以别人在远程仓库看到的
还是这个旧的版本
我们可以验证一下
开一个新的标签
切进 `playground` 目录
用 `git clone` 这个命令
来获得远程仓库的一个本地副本
[1634]
通常来说
要基于现有 git 仓库推进 #REVIEW
例如 GitHub 上有些好东西
你想把它下载到本地
来仔细观赏或是进行开发的话
就会用到这个命令
而 `git clone` 的格式是
它会需要远程仓库的 URL
以及本地的目标文件夹名
对于这个例子来说
我们就只是要把
本地这个假装是在远程的 `remote` 仓库
克隆到 `demo2` 这个文件夹
然后它告诉我在路上了 已经到了
然后我就切进目录
我把底部的标签页重命名一下
分别叫做一号机二号机
我们假装两个人在两台不同机器上工作
*其实一个人也可以
分别有着自己的一份仓库副本
但是在和同一个远程仓库交互
如果我和一号机一样
跑一下 `git log`
在二号机上我会看到这些历史
[1659]
二号机的主分支
和 `origin/master` 指向同一个 commit
而 commit message 是
合并猫猫和狗狗
我把 `animal.py` 打出来 # REVIEW ~~我用猫猫跑动物.蛇蛇~~ 没有要 review 的
发现它并没有我在二号机上的修改
尽管一号机上有这条新 commit
但是它只在这台机器上有
并不会在远程仓库里或是二号机上
如果我想把修改传到远程仓库里
例如传到 GitHub 存源码的机器上
我可以再用一次 `git push`
[1675]
`git push origin master:master`
能用
但是每次都要打
就很不爽
而且这命令又很常用
那 git 实际有个简化的用法
它能够记住
你本地和远程仓库分支之间的对应关系
从而知道远程的分支对应本地哪个分支 #REVIEW 废话
然后你就只需要打简化过的 `git push`
它就知道要怎么展开你的命令了
设置这个对应关系有好几种方式
一种是 `git branch --set-upstream-to`
它会把目前的分支的上游
设成你给的 `origin/master`
然后他就会复读你和他说了什么
然后如果我现在用 `git branch -vv`
加了个 `-vv` 就可以看到
* v 是 verbose 的意思，添加两个 v 表示加强，也就是**更**啰嗦的输出，同样的还有 GCC 编译器使用的 -gg 选项，表示更多的调试符号信息
git 对各个分支最详细的了解情况
一号机上有三个分支
猫猫狗狗和主分支
然后这里
本地机器上的主分支
对应着远程仓库上的主分支
然后我现在只用 `git push`
它就知道我想 push 到 `origin/master` 了
[1712]
然后我们切到二号机
假装是另一个远程仓库用户
*住在远程仓库里刚 push 就知道
现在再跑一次 `git log`
哈哈 还是没有
实际上 我们还要再跑一个命令
这些改变才会出现
默认情况下
所有的 git 命令都不会联网
*甚至是和本地的远程仓库“联网”
只在本地工作 跑得超快
那么就会有一个命令来告诉它
把其他地方的修改拿过来
而这个命令就是 `git fetch`
这个命令需要远程仓库的名字
但是这里只有一个 它就会用那一个
跑一下
和远程仓库交互
告诉我们远程仓库有更新
我们跑一下 `git log`
我们会发现本地的主分支没有改变
`git fetch` 这个命令
并不会改变本地的历史或者引用啥的
但是看这里
它现在知道
`origin/master` 已经被更新到了
指向这个新 commit
然后我们就可以用另一个
`git merge` 命令
来把 `master` 挪到这里
而 `git pull` 这个命令
则是 `git fetch` 和 `git merge` 的缝合
[1750]
那我们这里就用 `git pull`
它就会 Fast-Forward
*因为这里只有远程更新了，所以直接把
*主分支指向的 commit 挪上去就可以了
*而不需要添加 merge commit 或是更高级的
*rebase 等等
然后再看一下历史图
本地的主分支和远程的主分支
就指向同一个 commit 了
现在一号机和二号机的修改就同步了
那这些就是和远程仓库交互的基本操作了
`git remote` 列出来所有已知远程仓库
可以增加或删掉已知的仓库等等
然后是 `git push` 命令
用来把修改发到远程仓库
而 `git fetch` 则会把远程仓库修改
取回到本地机器
然后就可以用 `git merge`
来使得本地机器和远程指向同一个 commit
*不一定 你可能会新增一个 merge commit
*或是你本地有修改没 push 的情况下 pull
你也可以用 `git pull` 命令
来达到 `git fetch` + `git merge` 的效果
[1776]
除此之外还有一个刚刚讲的 `git clone`
获得一个远程仓库的副本
那这就是和远程仓库交互的一些基本命令了
有点复杂 要多用才能熟练不同的变体
以及理解它是在干啥
但是希望通过这个简短介绍
你可以了解到不同命令背后的储存模型
本质上他们做的事
也就是把对象文件发送到远端
或者从远程接收到本地
然后修改本地的引用
把这些丑陋的设计对应到储存模型
对帮助理解很有用
[1800]
今天我们最后来讲点
git 能干的其他事
我们并不会讲得很深入
去告诉你怎么去做
只是告诉你有这些东西
需要时你可以对着文档读
第一个是 `git config` 命令
像我们之前说到的 tmux shell 这些
git 可以通过一个文本文件配置
也可以通过命令行的 `git config` 命令配置
而它也就是用收到的参数
拿去改配置文件
通过文本文件配置
你可以直接改家里的 `~/.gitconfig` 文本文件
* git 的配置有 all users (--system), per user （--global）和 per repo (--local) 三种模式
为了这堂课
我把我的 git 配置
删到只剩 commit 要用到的
用户名和邮箱了
[1823]
但是实际上这里还可以加好多东西
让 git 变得和你的预期一致
变得更好用
你可以在 GitHub 啥的上面
搜到别人的 git 配置
而且里面还有文档
还有几种有用的命令
其中一个是你克隆仓库的时候
因为 git 默认从远程仓库
复制整个历史
所以克隆下来的仓库是十分庞大的
但是你可以传一个 `--shallow` 参数进去
来避免这种情况的发生
假如说你想从 GitHub 上面克隆个仓库
但是这个仓库里有几百万个 commit
* billion 还是太离谱了
用上 `--shallow` 会快很多
但是当然你就不会有版本历史
只会有最新版本的代码
还有一个在本地开发时
非常非常实用的命令是
交互式的 `git add` 命令
为了演示这个特性
让我先把 `animal.py` 改个好几处
我把这里改成大写
然后这里加一句
假设这个改成大写
是例如修了个 bug
这种我真正想要做的修改
[1860]
而这另一处改变
是我用来调试的输出
但是我并不想把它 commit 进去
当我跑 `git diff` 的时候
它就会告诉我我改了这两处地方
如果我跑 `git add animal.py`
这两处修改都会
被加入要 commit 的改变之中（stage）
我可以手动删掉这行调试输出
再来 `git add animal.py`
但是有一个更简便的方式
有一个 `git add -p` 命令
可以让我通过这个界面
交互式地 stage 一部分的改变
现在它在问我要不要两个修改都 stage
我说不
我要把它分（[s]plit）成两个小改变
我想要这个改变 所以我说 [y]es
这个我不想要 所以我说 [n]o
然后现在跑 `git diff --cached`
它会告诉我哪些修改将要被 commit
现在它只显示这一个我真正想要的
而当我只 `git diff` 的时候
它就会告诉我这处修改
并不是下一次 commit 的一部分
而这一处修改我并不想要
现在我就可以 `git commit`
写点 commit message
现在我就只剩下这一处修改了
然后我就可以用 `git checkout animal.py`
来把这处修改丢掉
因此用 `git add -p`
来交互式地选择要 stage 的修改
非常的实用
还有一些你可以了解一下的功能
[1897]
例如 `git blame` 命令
*blame = 指责
听着非常坏坏
但是实际上你可以用这个命令
来找出谁改了这行代码
*原来是自己写的啊
以及对应的 commit 和 commit message
在现在展示的这个仓库
跑这个命令并不是很有意义
*全是他自己写的
但是我们可以去课程网站的仓库看看
我们可以选一个文件
然后随便跳到某一行
可能会想 为什么这里会有一行这种东西
拿来干啥的啊
我就可以看它的 `git blame`
当我跑 `git blame _config.yml`
在最右边是代码
在最左边是最后修改这行的 commit
中间是谁改的
然后往下滚动到 `collections` 这行
发现是在这个 commit 里最后修改的这行
[1922]
然后我就可以用 `git show`
来获取这个 commit 的详情
啊这还挺有用的
“把讲座重新做成合集”
这是为什么它和 `collections` 这行有关
除了 commit 和 commit message
它还告诉我这条 commit 的所有修改内容
我就可以仔细琢磨 知道发生了什么
另一个有趣的命令是 `git stash`
让我们回到演示仓库来演示
假设这里有些改变
但是我想暂时把它们放一边
当我跑 `git stash` 的时候
它就会把我的工作目录
回滚到最后一条 commit 时的状态
现在我 `cat hello.txt`
我的修改就会消失了
但是它不只是丢掉这些修改
它会把这些修改存到妙妙屋
当我用 `git stash pop` 的时候
它就会把我的修改还回来了
现在我再看 `hello.txt`
修改就回来了
这个命令也很有用
另外一个非常香的命令
则是 `git bisect`
它的用法挺复杂的
我们不会深入地讲
大致来说 这个命令
可以替代你人工在历史里找东西
[1954]
例如你写一个项目写了很久
有了几千个 commit
然后你发现有几个单元测试挂了
但是你知道一年前它没挂
* 挂了还 commit 那可真是
你想知道它啥时候挂的
或者说这个问题啥时候回归的
你可以往上退一个 commit
跑一下测试 看挂了没有
没挂 那再往上一个
然后你会一路找到
第一个挂掉的 commit
可能你也就知道了啥玩意炸了
但是这也太累了吧
`git bisect` 会通过二分搜索
非常高效地替代你的工作
而且它还可以通过一个脚本
来知道这到底是坏是好
因此这是一个全自动的过程
你可以塞给 `git bisect`
一个单元测试的脚本
让他给你找出来第一个出锅的 commit
真的非常强悍
还有一个实用的东西
是 `gitignore` 文件
[1984]
让我新建个 `.DS_STORE` 文件
啊这
然后跑 `git status`
`.DS_STORE` 文件是 MacOS 烦人的东西
我也不知道里面塞了个啥
但是只要这个文件在文件夹里
我一跑 `git status`
git 可高兴了
~~给我最爱吃的 Untracked File~~
说它之前不知道有这个文件
问我要不要加进版本管理
就很烦
除了系统垃圾
还有编译时产生的 `.o` 对象文件
可执行文件
你绝对不要希望二进制文件
在你的仓库里出现
你应该只想要你的仓库里有源代码
所以 git 让你选择
你不想让它管什么样的文件
并且忽略掉它们
被称作 `gitignore` 文件
我在目录下面编辑 `.gitignore` 文件的时候
我可以指定文件名或文件名特征
例如 `*.o`
这样 `.o` 的拓展名和 `.DS_STORE`
就会被忽略了
我现在来个新文件 `foo.o`
跑 `git status`
它就会告诉我
`hello.txt` 变动过了
我知道
有个新的 `.gitignore` 文件
你应该用 git 对它进行版本管理
但是它并没有提到我目录下面有个
`.DS_STORE` 和 `foo.o`
因为已经被忽略了
* 注意如果文件已经被跟踪了，这时候 `.gitignore` 对它是不生效的
这就是一些高级的 git 功能
让你对这个工具能做的事有更深的印象
还有几个课程笔记里
写得更详细的内容
[2034]
我列举一下 这样你好知道有啥
git 的图形界面
我们不用这东西 我们倾向于用命令行
* 就只是树状图好看了点
但是我们有些人对这个也没啥意见 #REVIEW
你可以去看看你喜不喜欢用
还有 shell 集成
你可以发现这一整节课
我跑了好几次 `git status`
来看我仓库有什么变化
可能这会有些烦人
有些人
就在 shell prompt 里
加了仓库的概况
例如在哪个 branch 上
有多少文件修改
有多少没版本管理的文件
课程笔记里有
获取 git 显示仓库状态的
shell 集成的相关链接
文本编辑器也有类似的集成
例如我用 vim
我就装了个插件
来做 git 相关的操作
例如我可以看 `git blame`
这样我就不用去命令行去看了
效率也高多了 脖子也不疼了
我在看 git blame 的时候
可以在 commit 上面按回车
就可以在文本编辑器里显示这个 commit
还会把其他文件折叠掉
只展开 blame 的文件
这样更命中重点
课程笔记里也有链接
还有几个东西你感兴趣也可以了解一下
这堂课并不足以完整的告诉你
所有 git 相关的要学的东西
这是通过学习诸如对象引用等储存模型
以及 git 怎么对版本历史建模
开的一个好头
以及介绍了一些 git 命令
如果你真的想学得特别深入
在课程笔记的资源一节
有一本叫做 Pro Git 的书的链接
这是一本简短但是很好的免费书籍
读完这本书的前几节
你就可以知道如何专业地使用 git
来开发软件或是在 GitHub 等上做贡献
除此之外 和其他几节课一样
有些课后练习你有空可以做一下

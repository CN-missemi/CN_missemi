[1464]
这条 commit
既是 `dog` commit 的子节点
又是 `cat` commit 的子节点
所以从这个 commit 往回看
可以同时看到两条分支
而我们现在所在的这个 commit
同时有 `dog` 和 `cat` 两个 commit 里实现的功能
所以如果我们用 `cat` 参数跑 `animal.py`
它就会猫叫
如果用 `dog` 参数跑
它就会狗叫
如果用其他参数跑
它就会采取默认行为
所以 我们这里展示了
你要怎么分支出去
并行开发不同的部分
然后用 `merge` 命令
[1478]
把他们合到一起 #REVIEW `resolve those different branches`
来同时具有这几个并行开发的分支里实现的功能
然后我们来说一下合并时
会发生的一个冲突的问题
这些冲突会以冲突标记的形式在文本文件里出现
你可以手动解决这些冲突
而 git 也有一些高级的工具来帮助你解决冲突
[1491]
但我们只在课程笔记里具体地说明了 # REVIEW lecture note
并不会在这节课上展示
这就是 git 的分支和合并
有什么疑惑吗
没有啊 好耶
这节课的下一个部分
我们来聊聊 `git remote`
这是你与其他人 git 协作的一个方式
一个 git 仓库
也就是 `.git` 文件夹里的东西
代表了这个仓库的整个历史
里面有着所有对象文件和引用
[1502]
仓库的所有快照也都在里面
而你和其他人进行 git 协作的方式是
其他人也有整个 git 仓库的副本
而你可以让你本地的仓库实例
知道其他仓库的存在
这个概念在 git 里叫做 remote
而 `git remote` 命令
会列出所有它现在知道的远程仓库
而对于我们现在这个仓库
因为我们啥都还没告诉它
`git remote` 就啥也没打出来
现在它只知道它自己存在
实践上 在和别人协作的时候
你的 git 仓库会知道 GitHub 上也有个仓库
[1523]
然后就会有把你的修改发送到远程仓库
例如把修改发到 GitHub
和把例如 GitHub 上远程的修改
取回到本地的命令
在这一部分
我们并不会演示怎么注册 GitHub
登录 新建仓库
这些教程一搜一大把
我们这次就直接用
这台机器上另一个文件夹
把它当作 git remote
让我换到上一层目录
开个新的文件夹叫做 remote
然后用 `git init --bare` 初始化
[1544]
*--bare as a way to mark a repository as a storage facility, as opposed to a development environment
*`--bare` 告诉 git 这个仓库用来储存而不是开发
这些操作在你实际用远程操作的时候
并不会用到
*注意这里并没有 `.git` 文件夹
这样一波组合拳下来
我们就开出了一个
能拿来做远程仓库的文件夹
然后我们回到 `demo` 文件夹
再跑一次 `git remote`
啥都没有
但是我可以用 `git remote add` 这个功能
来让它知道有个远程仓库的存在
这个命令的格式是这样的
远程仓库有个名字 有个 URL
[1560]
我在这里根据~~老祖宗的决定~~
选了 `origin` 这个名字
一般只有一个远程仓库时就会选这个名字
然后 URL 这里
如果你用在线的托管服务的话
一般来说这里填的是
GitHub 或者 GitLab 这些给的 URL
而我们这里演示的
就只是本地机器上另一个仓库的路径
也就是上层目录里当成远程仓库的 `remote` 文件夹
我加完远程仓库了以后
我就能用许多的命令可以与这个仓库交互了
其中一个特别有用的
是 `git push` 命令
用来把本地的修改发给远程仓库
它还要输入远程仓库的名字
本地的分支名 冒号 远程仓库的分支名
它就会把远程仓库的分支
更新成本地这个分支名里的内容
如果远程没有这个分支的话就会开个新分支
[1585]
一个实际的例子是
我 push 到我唯一的一个远程仓库
叫做 `origin`
我看看我该 push 啥
看看历史图
我这有好多好东西可以 push
那我把我本地的 `master` 分支
push 到 `origin` 的同名分支
这样远程仓库会有一个这样的同名分支
然后跑起来
然后这里最后一行写了
我在远程仓库上面开了个新分支
本地的 master 指向远程的 master（右边）
* 视频上光标的移动和本地/远程的关系没有对应 #REVIEW 本地试过了
[1601]
然后我现在再跑 `git log`
它就会告诉我
我现在处在蓝色的 `HEAD` 这里
绿色的是我本地 git 仓库的最新 commit
然后我们看到这里有个我们没见过的红色玩意
代表着我本地副本所知道的
远程仓库的引用
这里 在远程仓库 `origin` 里
好巧不巧有个同名分支 `master`
和本地的 master 分支指向同一个 commit
[1612]
然后我现在把本地的副本修改一下
全部换成小写字母开头
然后跑 `git add animal.py` 和 `git commit`
用 `-m` 可以直接指定 commit message
就不会弹出来个编辑器了
然后现在再去看历史图
然后你就会注意到
这里多出来了个快照
这里面输出是小写开头的
但是 `origin/master` 没变
所以别人在远程仓库看到的
还是这个旧的版本
我们可以验证一下
开一个新的标签
切进 `playground` 目录
用 `git clone` 这个命令
来获得远程仓库的一个本地副本
[1634]
通常来说
要基于现有 git 仓库推进 #REVIEW
例如 GitHub 上有些好东西
你想把它下载到本地
来仔细观赏或是进行开发的话
就会用到这个命令
而 `git clone` 的格式是
它会需要远程仓库的 URL
以及本地的目标文件夹名
对于这个例子来说
我们就只是要把
本地这个假装是在远程的 `remote` 仓库
克隆到 `demo2` 这个文件夹
然后它告诉我在路上了 已经到了
然后我就切进目录
我把底部的标签页重命名一下
分别叫做一号机二号机
我们假装两个人在两台不同机器上工作
*其实一个人也可以
分别有着自己的一份仓库副本
但是在和同一个远程仓库交互
如果我和一号机一样
跑一下 `git log`
在二号机上我会看到这些历史
[1659]
二号机的主分支
和 `origin/master` 指向同一个 commit
而 commit message 是
合并猫猫和狗狗
我把 `animal.py` 打出来 # REVIEW ~~我用猫猫跑动物.蛇蛇~~ 没有要 review 的
发现它并没有我在二号机上的修改
尽管一号机上有这条新 commit
但是它只在这台机器上有
并不会在远程仓库里或是二号机上
如果我想把修改传到远程仓库里
例如传到 GitHub 存源码的机器上
我可以再用一次 `git push`
[1675]
`git push origin master:master`
能用
但是每次都要打
就很不爽
而且这命令又很常用
那 git 实际有个简化的用法
它能够记住
你本地和远程仓库分支之间的对应关系
从而知道远程的分支对应本地哪个分支 #REVIEW 废话
然后你就只需要打简化过的 `git push`
它就知道要怎么展开你的命令了
设置这个对应关系有好几种方式
一种是 `git branch --set-upstream-to`
它会把目前的分支的上游
设成你给的 `origin/master`
然后他就会复读你和他说了什么
然后如果我现在用 `git branch -vv`
加了个 `-vv` 就可以看到
git 对各个分支最详细的了解情况
一号机上有三个分支
猫猫狗狗和主分支
然后这里
本地机器上的主分支
对应着远程仓库上的主分支
然后我现在只用 `git push`
它就知道我想 push 到 `origin/master` 了
[1712]
然后我们切到二号机
假装是另一个远程仓库用户
*住在远程仓库里刚 push 就知道
现在再跑一次 `git log`
哈哈 还是没有
实际上 我们还要再跑一个命令
这些改变才会出现
默认情况下
所有的 git 命令都不会联网
*甚至是和本地的远程仓库“联网”
只在本地工作 跑得超快
那么就会有一个命令来告诉它
把其他地方的修改拿过来
而这个命令就是 `git fetch`
这个命令需要远程仓库的名字
但是这里只有一个 它就会用那一个
跑一下
和远程仓库交互
告诉我们远程仓库有更新
我们跑一下 `git log`
我们会发现本地的主分支没有改变
`git fetch` 这个命令
并不会改变本地的历史或者引用啥的
但是看这里
它现在知道
`origin/master` 已经被更新到了
指向这个新 commit
然后我们就可以用另一个
`git merge` 命令
来把 `master` 挪到这里
而 `git pull` 这个命令
则是 `git fetch` 和 `git merge` 的缝合
[1750]
那我们这里就用 `git pull`
它就会 Fast-Forward
*因为这里只有远程更新了，所以直接把
*主分支指向的 commit 挪上去就可以了
*而不需要添加 merge commit 或是更高级的
*rebase 等等
然后再看一下历史图
本地的主分支和远程的主分支
就指向同一个 commit 了
现在一号机和二号机的修改就同步了
那这些就是和远程仓库交互的基本操作了
`git remote` 列出来所有已知远程仓库
可以增加或删掉已知的仓库等等
然后是 `git push` 命令
用来把修改发到远程仓库
而 `git fetch` 则会把远程仓库修改
取回到本地机器
然后就可以用 `git merge`
来使得本地机器和远程指向同一个 commit
*不一定 你可能会新增一个 merge commit
*或是你本地有修改没 push 的情况下 pull
你也可以用 `git pull` 命令
来达到 `git fetch` + `git merge` 的效果
[1776]
除此之外还有一个刚刚讲的 `git clone`
获得一个远程仓库的副本
那这就是和远程仓库交互的一些基本命令了
有点复杂 要多用才能熟练不同的变体
以及理解它是在干啥
但是希望通过这个简短介绍
你可以了解到不同命令背后的储存模型
本质上他们做的事
也就是把对象文件发送到远端
或者从远程接收到本地
然后修改本地的引用
把这些丑陋的设计对应到储存模型
对帮助理解很有用
[1800]
今天我们最后来讲点
git 能干的其他事
我们并不会讲得很深入
去告诉你怎么去做
只是告诉你有这些东西
需要时你可以对着文档读
第一个是 `git config` 命令
像我们之前说到的 tmux shell 这些
git 可以通过一个文本文件配置
也可以通过命令行的 `git config` 命令配置
而它也就是用收到的参数
拿去改配置文件
通过文本文件配置
你可以直接改家里的 `~/.gitconfig` 文本文件
* git 的配置有 per user （--global）和 per repo 两种模式


【972】注意输出和之前的有一点不一样

我们实际上存在的历史内容

也就是这些 commits 以及它们的相互关系

这些都没有发生变化

但是我们的引用发生了变化

注意到 `HEAD` 指针下来这儿了

但是 `master` 还在上面这里

所以纵观全局，它告诉我目前我在查看这个版本

如果我想回到这里

我应该输入 `git checkout` 和这个 commit 哈希

有人知道除了这个很长的哈希值

我还能在这里输入什么，来回到这个 commit 吗

_（同学）master_

对，你可以输入这个名字

这是一个分支，所以拿绿色标出来了

它指向这个 commit

所以我可以输入这个简名，或者说人类可读的名字

然后现在我再 `cat hello.txt`

注意到它又有了第二行

_（同学的问题）_

对，对

我复述一下，`git checkout` 实际上会改变

你的工作目录下的内容

这方面来说，使用不当的话，它可能会有点危险

比如说，注意看，我修改一下 `hello.txt`

然后我再试一下之前的 `git checkout`

看这里，它说错误

它说，有一个文件被修改过了

`git checkout` 会破坏这个修改

所以你也许需要处理一下

但是有一些 flags，比如说 `git checkout -f`

会强制执行 `checkout`

那现在它把我的修改都丢掉了

所以 `git checkout` 有能力

呃，它确实会修改工作目录下的内容

并且一旦不慎，真的会破坏更改

要提问吗？

_（同学的问题）_

没错！

这就是我想让你们思考的

这些疯狂的 git 接口命令是如何对应到

这个历史图上的变动，和这些引用的变动

或者说着历史图上的追加，和引用映射的变动

你说的好，`git checkout` 移动了 `HEAD` 指针

然后将当前工作目录的内容，替换成指向的内容

也就是指向的那个 commit

还有别的问题吗？

好的。

我想教给你的另一个基础命令

是 `git diff` 命令

现在我修改一下这个文件

加入一些改动

`git diff` 会告诉你

上次快照之后，什么又变动了

对了解项目的进展大有裨益

它也支持额外的参数

比如你可以用 `git diff` 获得

并不是相对于最后一个快照，或称 commit

而是这个参数

它说自这个节点以来，新添了两行

在 hello.txt 里

有问题吗？

_（同学的问题）_

啊，所以问题是

这个命令不加这个额外参数会做什么？

问得好，所以它计算的是相对于 `HEAD` 的不同

看一下我的 git log，`HEAD` 指向这里

所以它在相对于这个 commit 做比对

然后你可以显式地声明这一点

你可以 `git diff HEAD hello.txt`

_（同学的问题）_

嗯嗯 好的

这是一个好问题

所以为什么 hello.txt 会和 `HEAD` 不一样呢

`HEAD` 不是目前所在位置的引用吗

明确一下，`HEAD` 指向的是最近一个快照

比如在我这里的图片里面

`HEAD` 和 `master` 都在这里

而当前目录和这个结构是一个独立的关系

比如就算删掉这里的所有文件

这不会改变历史图和这些引用

所以在这两者之间会有不同

而且从上层来看，这就是你在项目上工作的方法

你在这里做出一些改动

你用 `git add` 去暂存它们

你 `git commit` 在这里创造一个新的快照

问得好，还有问题吗？

_（同学的问题）_

好，问题就是 git 是直接把这些内容

简单粗暴地存下来

还是做了更先进复杂的处理呢？

答案是它的实际存储确实更加复杂 [*]
* 为了权衡存储空间和处理速度

但它的接口可以让你将其视为简单的快照

实际上 git 使用了 Delta 表达式和其他的一切东西

对，所以它在实际磁盘上的存储是很优的

问题？

_（同学的问题）_

这也是个好问题

问题是，这里我们在比对当前的工作目录

和一个特定的、过去的快照

那我们能比对两个快照吗？

两个历史上的不同节点？

是可以的，`git diff` 可以再接受一个参数

我可以比较 `HEAD`…… 哦我搞错顺序了

我可以比较从此处开始，到 `HEAD` 这里

hello.txt 发生了什么

它告诉我这里我新增了第二行

还有别的问题吗？

_（同学的问题）_

好，那么问题是

你在用 Dropbox 管理的文件夹做一个团队项目 [*]
* 可以理解为一个联机同步的存储提供和项目管理方案

你想把它迁移到用 git 管理

可以直接把这个 Dropbox 文件夹变成一个 git 仓库吗

*不要*在 Dropbox 文件夹里面用 git

Dropbox 会龙卷风摧毁你的~停车场~ git 仓库格式 # REVIEW 这里不知道能不能整

有一些好的解决方案，可以直接用 github

或者可以课后和我聊聊

有很多方法可以安全地把 Dropbox 当作 git 远程仓库

还有别的问题吗？

下面我们来讲一讲管理分支和合并分支

这也是 git 中很常用的一个趁手功能

自己做项目、合作工作的时候都可以用

这系列演示，比起处理一个文本文件

我们不妨来写一个简单的程序

它可以更好地展示分支和合并的作用

在演示的同时，我们再熟悉一下 git 的接口命令

怎样和它底层的数据模型相连

怎样和对象、引用相连

又是怎样修改这两个数据结构的

我来执行 `git status` 看看当前仓库的状态

这里我修改了 hello.txt

实际上我现在不关心这些改动了

这些文件已经无所谓了

如果我再 `git checkout hello.txt`

这是 `checkout` 命令的另外一种用法

它会把我在工作目录下（对这个文件）的更改丢弃

把 hello.txt 的内容设为

它在 `HEAD` 指针指向的这个快照里的内容

现在看看 `git log --all --graph --decorate`

它告诉我这里我添加了初始的 hello.txt

然后这里加了一行儿

现在 hello.txt 没有之前加的第三行了

只有最初的两行儿

接下来我们要写一个很简单的程序

命其名为 animal.py

我就直接开写了，让它输出一点东西就行

嗯……

运行的时候会进入 `main()` 函数

`main()` 又调用 `default()`

然后咱来定义 `default()`

它就直接输出 Hello

这就是一个可以问候用户的程序

如果我运行 animal.py，可以看到它输出 `Hello`

这是我们的起点

如果执行 `git status`，它告诉我

animal.py 是一个未跟踪的文件

首先，我想要它在快照里作为一部分出现

所以 `git add animal.py` 把它加入暂存区 [*]
* "Staging" Area

然后 `git commit` 提交

这里我再写一个没用的提交信息

在真格的项目里别写这种信息，但是现在无所谓

现在我有了基础的 animal.py

如果我看看 git 历史

现在这个最新的快照，这是提交哈希

也是 `master` 分支指向的地方

现在来说一下怎样使用分支实现并行开发

`git branch` 命令，或者说 `branch` 这个子命令

可以操作与分支有关的功能

单单运行 `git branch` 会列出所有本地仓库的分支

也可以用一个额外参数 `-vv` 让它多废话几句

来得到更多的相关信息

如果我们在 `git branch` 之后指明新分支的名字

git 就会创造一个新的分支，也就是一个引用

指向我们当前在的快照地点

所以现在有一个新的引用叫 `cat`

这里我们说的引用和分支可以看作一样

有一个叫 `cat` 的新分支

现在和 `HEAD` 指向同一个地方

如果我再看看 git log 的话

会看到这里 `HEAD` 指向这里的 `master`

`cat` 分支也在这里

所以现在我有两个分支，两个引用

解析到了同一个提交上

git 实际上不仅知道

你当前处于历史记录中的哪个快照

也就是这里 `HEAD` 指向的提交

也维护了 `HEAD` 关联到了哪个分支

所以这里 `HEAD` 关联到了 `master`

现在如果我拍个新快照

如果我现在输入 `git commit`

那新的快照会被创建好

`master` 会指向这个新快照

`master` 会随着 `HEAD` 一起更新

如果我执行 `git checkout cat`

这就切换到了 `cat` 分支

并把工作目录下的内容替换成

`cat` 指向的快照内的内容

在这个例子里，内容和之前一样

但如果我现在再看看 git log

`HEAD` 现在指向的是 `cat`，而不是 `master`

而 `master` 依旧指向同一处，同一个基础 commit

如果我现在对当前的工作目录做点改动

然后做一个新的 commit 的话

`cat` 分支，也就是 `cat` 指针

会更新到指向新的 commit

但是 `master` 指向的位置依旧

那我继续修改一下 animal.py

加一些与猫猫有关的功能

这里我要写 `if sys.argv[1]` 是 `'cat'`

那就运行 `cat()` 函数

否则运行 `default()` 函数

现在继续定义 `cat()` 函数

所以猫猫不会说 Hello，它们是喵的

所以 `cat()` 打印出 `Meow!`

这很直白

所以现在我运行 animal.py，给一下 `cat` 这个参数

它就输出 `Meow!`

如果给定其他的参数，就会落回默认的 `Hello`

做了些简单的改动

如果再执行 `git status`，它说

animal.py 已经被修改了

如果执行 `git diff`

就会展示自上次来有什么变动

这里我添加了 `cat()` 函数，绿色高亮的

我也小幅修改了 `main()` 函数

如果我执行 `git add animal.py`

`git commit`

这次我写了一些稍微有用的提交信息

我加入了猫的功能

如果现在再看下 git log 的话

能看到多了一点东西

再给你们说一个 `git log` 命令的参数

有一个杠杠 One Line（单行）的参数

`--oneline`，这次拼对了

它给出了这个日志图的，更紧凑的形式

这还是挺有用的，因为我们缩放得很大

没有多少空间输出很长的提交历史

我们看到这个提交序列还是线性的

`master` 还是指向之前的位置

也就是我们完成了基础的 animal.py 功能

现在我们有 `cat` 分支，增加了猫的功能

比如我们还可以 `git checkout master`


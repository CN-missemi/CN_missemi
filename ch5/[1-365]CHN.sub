{0}{-1}* （MIT内一栋著名的复合式建筑）
{0}{-1}* （G 塔是 Gates Tower，D 塔是 Dreyfoos Tower [维基百科]）
{0}{-1}* 这三个词分别是无用的饭桶、破环颠覆、汞制剂，这代表着人们对版本管理的态度
{0}{-1}* 哈哈 原来是自己改的
{0}{-1}* 在课程官网
{0}{-1}* 一种算法，可以在值单调的列表（数组）里快速定位元素
{0}{-1}* 有开源的，也有商用收费的
{0}{-1}* (此处应是指 Merkle Tree, Git 基于这种数据结构设计，尽管 Git 使用的版本应当被称为 Merkle DAG)
{0}{-1}*（Directed Acylic Graph，一种图论结构）
{0}{-1}* ？？？这真的可能吗？？？
{68}{135} 好，我们开始上今天的课了
{169}{261}所以在我们实际开始之前稍微说一下
{272}{353}根据大家的反馈来看
{354}{400}你们好多人都觉得
{411}{461}每天上完课后的答疑时间
{471}{505}都只能问关于当天的课程内容的东西
{506}{532}但事实上不是这回事儿
{542}{579}你可以在答疑时间问
{580}{630}关于所有我们所教的所有课程的问题
{631}{683}不管它是前一天的还是上一周的
{689}{749}甚至我们课上没讲过的东西
{750}{789}只要你对这个东西好奇 就都可以问
{803}{887}所以可以在答疑时间问任何问题
{958}{1067}答疑在 32 号楼 G9 休息室
{1076}{1139}32 号楼也被称作史塔特科技中心[*] 
{1145}{1169}这栋楼由两个结构构成
{1170}{1215}分别是 G 塔和 D 塔 [*]
{1223}{1280}我们是在 G 塔的九楼答疑
{1281}{1318}所以如果你坐电梯上去
{1323}{1358}那你一出电梯，休息室就在你右手边
{1496}{1516}所以今天呢
{1517}{1576}我们要讨论下版本控制系统
{1588}{1624}一开始我先想了解下
{1625}{1668}之前有哪些人
{1669}{1718}用过版本控制系统
{1726}{1784}如果你之前用过 Git、Subversion、Mercurial [*]
{1785}{1874}或者其他的版本控制系统
{1875}{1927}那你就举个手
{1959}{2008}啊好，看来用过的人还不少
{2042}{2111}所以我就不讲版本控制系统相关的
{2112}{2157}一些比较烂大街的东西了
{2194}{2243}那么，我们将很快深入 `git` 的细节
{2273}{2322}比如它的数据模型和内在实现
{2334}{2371}但我们先大概讲一下
{2375}{2419}版本控制系统是用来
{2424}{2573}跟踪源代码、文件、文件夹修改的工具
{2587}{2629}正如“版本控制系统”这个名字所说
{2635}{2689}这些工具帮我们追踪
{2690}{2780}我们对一组文件做出的历史更改
{2792}{2881}并且还可以让团队合作更加便捷
{2893}{2972}所以它在一群人一起开发软件项目时
{2981}{3013}非常有用
{3068}{3164}版本控制系统通过（记录）一串快照的方式
{3173}{3212}来追踪对一个文件夹和它的内容的更改
{3227}{3296}所以你就能把整个文件夹的状态
{3297}{3334}还有里面的软件项目之类的玩意
{3345}{3394}像拍照一样定格下来
{3395}{3429}所以你就有一串快照
{3444}{3495}每个快照都描述了
{3496}{3555}你跟踪的这个顶层目录下的
{3556}{3587}所有文件和文件夹的信息
{3609}{3662}然后版本控制系统维护的东西
{3663}{3697}除了你对这些文件内容的实际更改之外
{3708}{3764}还有一堆元数据（Metadata）
{3774}{3861}这是为了让我们弄清楚
{3870}{3943}“某个文件的某个修改是谁写的”
{3951}{4000}“某个修改是什么时候发生的”
{4013}{4078}所以版本控制系统维护了
{4079}{4154}像是作者、提交时间戳之类的元数据
{4164}{4243}你也可以给这些快照附加其他你想要的额外信息
{4307}{4361}为什么版本控制系统作用很大呢？
{4367}{4408}就算你自己一个人做项目的时候
{4409}{4439}它也很有用
{4453}{4496}你可以用它来看
{4497}{4556}你之前写的旧版本的代码
{4563}{4616}可以通过看提交信息来弄明白
{4617}{4656}为什么当时要做这个更改
{4668}{4733}还可以通过分支来
{4737}{4814}不冲突地同时做多个工作
{4826}{4917}还可以同时修 bug 和开发新功能
{4918}{4967}并使其互不影响
{4974}{5027}所以版本控制系统是无价之宝
{5028}{5106}对于自己一个人写东西或者写小型项目也是如此
{5118}{5221}就比如我认为这门课的讲师
{5236}{5342}除了做研究和写大型软件项目时
{5343}{5380}他们甚至还在安排作业和课程设计
{5389}{5454}这些小型的东西上也用 `git` 
{5498}{5552}当然和其他人一起工作的时候
{5558}{5609}版本控制是一个非常强大的工具
{5610}{5703}它可以解决不同人写同一份代码时
{5731}{5829}向代码中更新新内容所引发的内容冲突
{5830}{5872}它就很有用
{5965}{5990}所以在你自己工作
{5992}{6020}或者和其他人一起的时候
{6021}{6056}`git` 都是个很强大的工具
{6057}{6140}此外它还有个比较香的功能
{6141}{6190}就是可以让你回答一些在其他情况下
{6191}{6238}比较难回答的问题
{6246}{6322}比如这个软件项目里某个模块是谁写的
{6333}{6419}或者谁改了某个软件项目里的某行代码
{6427}{6483}以及为什么要改这行代码
{6489}{6534}这行代码是什么时候由谁改的 [*]
{6579}{6626}此外版本控制系统还有一些
{6627}{6691}其他的很强大的功能
{6692}{6737}在今天课程的末尾我们会讲
{6746}{6775}或者如果来不及讲了
{6776}{6811}你也可以自己去找课程笔记 [*]
{6843}{6890}好 现在我们假设你有个已经
{6897}{6925}搞了好多年的项目
{6927}{6974}然后你注意到这个项目的
{6975}{7004}一些莫名其妙的东西不工作了
{7005}{7060}比如有些单元测试过不了了
{7074}{7131}并且它不是这个时候才挂掉的
{7132}{7191}它可能在之前某个时间挂了
{7201}{7265}但是你并不确定什么时候有的这个毛病
{7278}{7313}好，版本控制系统有个
{7323}{7377}自动查证这种事情的方法
{7385}{7460}就比如你去给它一份单元测试的代码
{7461}{7490}现在的程序会在这个单元测试上挂掉
{7491}{7559}但是你知道过去的某个版本上，它不会挂
{7567}{7616}然后它就可以去二分查找代码历史 [*]
{7617}{7704}搞清楚具体是哪一次代码更改让它挂了
{7719}{7803}所以只要你知道该如何正确使用这些工具
{7810}{7863}你就能发现很多又强又炫酷的功能
{8004}{8077}事实上“市面”上有很多版本控制系统 [*]
{8078}{8172}而 `git` 则成为了版本控制的某种事实标准
{8182}{8213}所以这就是为什么
{8214}{8247}今天的课我们主要讲 `git`
{8308}{8367}我想给你们看个梗图
{8368}{8469}这个图刚刚还在屏幕上来着……让我重新找找
{8575}{8623}所以这是个 xkcd 漫画
{8631}{8695}这个漫画因为它的绘画风格而出名
{8703}{8743}我来给你们朗读一下
{8788}{8852}“这是 `git`，它能通过一个优美的
{8853}{8899}图论里面的树型模型 [*]
{8900}{8950}来跟踪项目里的分工工作”
{8970}{9002}“好，那么我们怎么用呢”
{9017}{9077}“不知道，就记住这些 Shell 命令
{9078}{9104}使用它们来同步数据
{9113}{9175}如果出错了就先把你的文件存到别的地方
{9178}{9233}然后删掉项目，再下一份新的”
{9347}{9404}我猜接下来你们有些人不想举手
{9408}{9461}不过还是要说，如果你之前这样用过 `git`
{9466}{9493}请举一下手
{9505}{9545}我在学这个工具的时候肯定这样干过
{9554}{9639}所以你们中的好多人之前也这么干过
{9658}{9698}所以这门课的目的就是
{9699}{9712}让你学点东西
{9713}{9748}以后你就不会这样用 `git` 了
{9799}{9911}不幸的是，就像这张图画的那样
{9924}{10028}`git` 的接口设计得很可怕
{10029}{10070}它提供的行为抽象全是坑
{10080}{10130}因为这个原因，我们相信
{10131}{10200}从接口开始，自顶向下学 `git` 的话
{10210}{10258}可能不是个好方法
{10263}{10301}并且这样子可能会让你更加迷惑
{10323}{10385}不过你也可以像这个图里那样
{10386}{10430}记住一大堆命令
{10431}{10487}并且把它们想成魔法咒语
{10494}{10566}至于这些命令为什么能用也不管
{10567}{10592}反正它就是能用
{10593}{10662}但之后你就得像这个图里这样
{10663}{10698}只要有什么东西出问题了
{10700}{10742}你就得删了重下
{10744}{10825}所以尽管 `git` 的接口很丑
{10839}{10931}但它的内在设计和想法事实上都很美
{10965}{11020}这种丑陋的接口只能死记硬背
{11028}{11082}但其内在的优雅设计
{11083}{11118}其实是可以被理解的
{11127}{11200}一旦理解了 `git` 的内部实现
{11201}{11275}也就是它不那么复杂的数据模型
{11294}{11366}然后你就可以学习接口了
{11370}{11417}你可能得记住一些东西
{11423}{11462}但是你可以通过理解
{11469}{11522}命令是怎么操作内在数据结构的
{11530}{11607}去理解这些命令到底在干啥
{11635}{11692}我们今天讲 `git` 的安排
{11698}{11745}第一部分是关于数据模型的
{11754}{11832}几乎都是理论
{11847}{11947}讲一下文件和文件夹，历史快照的模型
{11957}{12025}然后我们会尝试几个 `git` 命令
{12035}{12102}最后在（讲义的）资源和练习里
{12108}{12156}我将会给你一些教程
{12157}{12186}这些教程能教给你所有细节
{12193}{12269}因为实际上你要学很多不同的命令
{12315}{12355}对今天的教学计划
{12356}{12386}有什么不明白的吗？
{12458}{12526}好，所以我们现在开始吧
{12575}{12648}可能有好多比较临时的
{12649}{12691}能拿来做版本控制的手段
{12703}{12772}并且我猜部分同学可能之前这样做过
{12778}{12821}就比如你有些文件
{12827}{12868}或者一个文件夹里有一堆不同的文件
{12875}{12917}它们组成了一个软件项目
{12927}{12955}然后你想跟踪这些文件的更改
{12965}{12991}你显然可以，比如说
{12992}{13055}每天把整个文件夹复制一份
{13060}{13097}然后给它标个时间戳
{13112}{13175}当你需要和其他人合作的时候
{13176}{13253}你可以把把整个文件夹压成一个压缩包
{13254}{13291}然后用电子邮件发给别人
{13304}{13354}然后如果你和你的朋友
{13355}{13414}正在写同一个软件的两个不同的部分
{13420}{13465}你们就可以各写各的
{13466}{13505}然后你们中的一个人要把压缩包
{13506}{13532}拿邮件发给另一个人
{13533}{13572}然后手动把对方给代码做的修改
{13573}{13605}用某种方法复制下来
{13606}{13649}粘贴到自己的代码里
{13653}{13696}然后你的程序里
{13706}{13786}就同时有了你们两个人写的代码
{13878}{13919}如果你们之前这样合作过的话
{13920}{13940}举一下手
{13941}{14035}我之前肯定这样干过的，你们也有好多
{14113}{14144}`git` 可以让我们避免干这种
{14145}{14180}并不怎么优美的工作
{14181}{14228}它有个经过仔细考虑的模型
{14229}{14261}这个模型可以让一些
{14262}{14321}你想做的事变得更加简单
{14329}{14431}比如追踪你自己在项目里的更改
{14432}{14469}或者和其他人合作等等
{14519}{14566}所以 `git` 的这个设计得很棒的模型
{14567}{14635}给你提供了像是分支、合作
{14636}{14686}还有从其他人那合并更改
{14697}{14729}诸如此类令人舒适的功能
{14758}{14786}`git` 的模型
{14787}{14839}是一组经过抽象，放在某个顶层目录下的
{14840}{14883}文件和文件夹
{14899}{14970}你可能对这种抽象挺熟悉的
{14971}{15018}因为你电脑上也是这样放文件和文件夹的
{15028}{15062}所以我给你们来个例子
{15067}{15116}你有个根目录文件夹
{15117}{15195}我就叫它 root 吧
{15223}{15325}这个目录里面有个叫 `foo` 的文件夹
{15334}{15388}然后 `foo` 里面又有个
{15389}{15441}叫 `bar.txt` 的文件
{15497}{15551}这个文件里可以写点东西
{15552}{15580}比如 `hello world`
{15686}{15742}回头看看这个根目录
{15743}{15774}里面有个目录
{15775}{15818}那它自然也可以有个文件
{15825}{15878}这个文件里也可以
{15910}{15975}写点东西
{16160}{16193}好了，挺简单的
{16211}{16277}`git` 用了个术语——树（tree）来表示
{16279}{16456}这些文件和文件夹以及这个最顶上的结构
{16464}{16496}就叫做树
{16581}{16612}所以这是个文件夹
{16692}{16832}然后这些我们平时叫文件的东西被称作 `blob`
{16995}{17074}好，现在我们有个文件和文件夹构成的模型
{17116}{17189}并且这个模型还是递归定义的
{17201}{17242}树里面可以有别的树
{17254}{17333}树里面还可以有文件
{17340}{17385}但显然文件里不能有树
{17438}{17525}好，现在我们有一个由文件和文件夹构成的模型
{17572}{17683}然后最顶上这个我标出来的东西
{17717}{17761}就是我们正在跟踪的
{17762}{17804}被称作为根目录的东西
{17805}{17830}就比如你电脑上的一个文件夹
{17831}{17860}这个文件夹对应着一个软件项目
{17928}{18023}现在我们有了文件和文件夹的模型
{18036}{18085}那么我们用什么模型来维护历史更改呢
{18090}{18121}你可以想想一种比较简单的方式
{18122}{18151}就是你给这整棵树像照相一样“拍”一个快照
{18152}{18179}然后历史更改就是
{18180}{18232}由快照所构成的线性序列
{18245}{18283}你基本上可以把这个东西想成
{18302}{18379}你有一大堆标上了日期和时间的
{18395}{18427}文件夹的拷贝
{18454}{18495}但 `git` 的实现
{18496}{18541}并不是用的这样简单的线性模型
{18546}{18589}它用了一个更有意思的东西
{18605}{18655}你之前可能听说过这个术语
{18662}{18719}`git` 有一个用有向无环图 [*]
{18722}{18747}来维护更改历史的模型
{18761}{18815}这个挺像一个听起来比较有意思的数学名词
{18822}{18879}但它实际上完全没有那么复杂
{18909}{19016}在 `git` 里，每个快照都有一些父节点
{19032}{19065}然后我们想知道
{19066}{19121}众多更改之间的前后关系
{19134}{19202}假设我现在用圆圈
{19211}{19257}来表示一个单独的快照
{19263}{19372}这个圈表示整棵树里的所有内容
{19383}{19435}我整个项目的所有文件和文件夹
{19461}{19522}正处在某个状态
{19544}{19582}然后我改了一些文件
{19583}{19621}这样它就在另一个状态了
{19639}{19704}然后用我又加了一些文件，它就又去了另一个状态
{19716}{19764}每个状态都有个指针
{19765}{19799}指向它之前的状态
{19845}{19900}到现在为止，这还是个线性的历史更改
{19911}{19985}但是我们现在做点有意思的事
{19998}{20139}你可以从某个快照分叉你的历史更改
{20151}{20172}也就是说
{20173}{20254}我想要基于这个版本的更改
{20339}{20381}像这样创建一个新的快照
{20438}{20484}通过这种历史更改模型
{20485}{20513}你可以在做一些类似于
{20519}{20603}这是我的开发主线
{20610}{20638}我到这了
{20643}{20708}现在我有两个不同的任务
{20721}{20754}一个是我想给我的项目
{20755}{20817}加点有意思的新特性
{20826}{20877}这个我要写好几天
{20888}{20959}但是除此之外，有人报给了我一个 bug
{20960}{21008}我需要找出来这个 bug，然后赶快修好它
{21024}{21133}我不想在同一条开发流程线里
{21134}{21174}同时干这两个工作
{21204}{21242}`git` 有它自己的一套
{21243}{21302}能够在更改历史上创建两个分支的方法
{21310}{21362}通过这种方法，可以临时地并行工作
{21380}{21449}还能让它们不相互影响
{21457}{21519}所以我现在创建一个
{21525}{21555}表示我的项目中
{21556}{21588}某个正常工作的状态的基底快照
{21589}{21662}然后从这，我可以创建一个
{21663}{21715}拿来实现新功能的快照
{21726}{21775}所以这里就有了
{21776}{21814}基底项目加上一个新功能
{21815}{21861}所以我在它上面写个 `+feature`
{21948}{21996}然后类似的，从这里
{21997}{22050}我可以回到最初的快照
{22051}{22126}因为我不想在写新功能的同时修 bug
{22142}{22210}然后可以到这，再去修 bug
{22211}{22252}建一个不同的快照
{22253}{22312}这个快照只包括 bug 修复
{22408}{22431}但是不包括新功能
{22450}{22541}最后等我写完这两块东西后
{22542}{22632}我想把它们一起合并回我正常情况下的代码
{22633}{22681}这样我的代码就既有新功能又有 bug 修复
{22695}{22769}所以最后我可以建一个新快照
{22773}{22865}它合并了这两个快照里的更改
{22880}{22914}然后这个新快照
{22915}{22974}以刚刚的两个快照作为父节点
{22998}{23059}然后这个版本
{23237}{23279}既有新特性，又有 bug 修复
{23310}{23392}所以 `git` 这种历史模型
{23398}{23477}相比于线性的一串快照来说
{23479}{23528}就显得很炫酷
{23533}{23627}我想要能支持同时写多个不同的东西
{23632}{23668}然后也能把我在不同的并行分支里
{23671}{23775}对它们的修改合并起来。有问题吗？
{23790}{23930}_[同学的提问]_
{23931}{24010}好，这是个很不错的点
{24011}{24061}似乎当你合并东西的时候
{24062}{24126}你会遇到一些你没想到的错误
{24127}{24166}你可以设想
{24167}{24245}这个新特性改了一些代码
{24246}{24288}一起把 bug 修了 [*]
{24289}{24347}或者你想， bug 修复把新特性搞坏了
{24348}{24378}或者一些类似的东西

[590]
目前为止有什么问题吗
这就是 git 大致的储存模型了
然后我们就要开始
实际地使用 git 命令
来理解 git 的命令
和这个图结构变换的关系
所以对于把历史
建模成 blob 构成的树
外面套一层 commit 树 # REVIEW ...
而 commit 则是 blob 树的一个快照
而 blob 树则会
随着不同 commit 整体改变
然后引用则会指向图上的某一节点
没问题吗 好强啊
我们有了对象和引用以后
这就可以构成一整个 git 仓库了
这就是仓库里实际存的东西
从高层次（用户层）来说
所有的 git 命令
就只是在改变对象或者引用数据而已
现在我们来讲一些 git 命令
我们会和 Vim 那堂课那样交互式地演示
然后可以参考课堂笔记来了解细节
因为这个工具实在非常强大
我们不可能二十分钟讲完
*那就讲一个小时
然后我们进到一个叫做 `playground` 的目录
开个新文件夹叫做 `demo` 然后切进去
我们假设这是项目的根目录
现在是空的 毕竟我刚刚开这文件夹
我现在用 `git init` 命令
来把它初始化成一个 git 仓库
init = initialize = 初始化
然后它告诉我它在这个目录
下面的 `.git` 文件夹里
初始化了空 git 仓库
[629]
如果只是跑 `ls`
还是啥都没有
但是我跑 `ls -a`
就会有个隐藏的文件夹 `.git`
* `.` 开头的文件默认隐藏 文件夹是特殊的文件
而我跑 `ls .git`
会看到一堆的文件
这就是本地磁盘上 git 储存数据的地方
也就是那些对象和引用
然后你在这里也可以看到
对象（`objs`）和引用（`refs`）两个文件夹
仓库的数据就存在里面
而另外一个学习时值得注意的命令
则是 `git help`
然后你要加一个子命令名作为参数
来指定要看啥的帮助
我现在跑 `git help init`
它就会告诉我 `git init` 的帮助信息
然后有些命令可以用来
了解 git 仓库的状态
例如 `git status`
可以了解用户层的仓库状态
先不看第一行
第二行说我们现在还没有 commit
因为我们刚开一个新的 git 仓库
自然也就没有历史
还有人要看吗 我要擦掉了
我想要一路打命令
一路展示引用和对象数据的变化
现在这个美妙的空图像
展现了我们~~整洁~~的空仓库
所以来往历史里加点东西
[665]
让我开一个新的文件
里面只有 `hello world`
通常来说这会是你的源代码啥的
现在 我想要把目录里的内容
变成新的快照
代表我仓库的第一个状态
你可能会猜
是不是有个 `git snapshot` 啥的
来给整个目录来个快照
因为某些原因
以及为了让操作更灵活
让你选择下一个快照里包含什么
git 并没有完全一致的功能
初学者经常在这里满头问号
所以我现在先把这个说了
git 里有一个概念叫做 staging 区
在用户层面上
你通过这个方式告诉 git
你想要把哪些修改包含在下一个快照里
现在再跑一次 `git status`
它会说现在没有 commit
然后 `hello.txt` 没有被纳入版本管理
意思就是说
git 知道这里有个文件
但是就是不会加进下一个快照
现在 git 会暂时忽略它
然后我现在跑 `git add hello.txt`
然后再跑 `git status`
它就会说这些修改将被 commit：
新文件 `hello.txt`
然后我现在跑 git 的快照命令
实际上是 `git commit`
就会在黑板上创造一个新的圈（节点）
* 要在整个 commit 完成之后
* 例如要求 commit message 非空否则默认 abort
这个文本文件会被包含在那个快照里
然后我现在跑这个命令
[708]
它会弹出一个文本编辑器
让我输入这个 commit 的 message
写一手好 commit message 非常重要
以后你（或者别人）往回看版本历史的时候
能够很方便地知道这样改变的原因
我这里就随便写点
但是课堂笔记里有个链接
来指导你写高质量的 commit message
然后 git 给我打出了一些信息
master 先不管
这个  是 commit 的 hash
现在我的历史上有了一个节点
节点里面是一个
只有一个文件节点的 blob 树
这个文件节点的文件名叫做 `hello.txt`
里面写有 `hello world` # REVIEW 树套树套..
它的短 hash 是 `42fb7a2...`
git 把它截断了
然后是我的 commit message
接下来是再次提醒我加了个新文件 `hello.txt`
现在我跑 `git log` 命令
这个命令能够帮助你可视化历史
非常有用
有问题吗
学生：这个 `42fb7a2` 是代表一整个树
还是 `hello` 这个功能
#REVIEW 也没说啥树= =
好问题 也就是说这个 hash 到底代表什么
这是 commit 的 hash
commit 里面有 blob 树的 hash
以及（commit message，commit 时间等）其他信息
实际上 我可以用 `git cat-file -p 42fb7a2`
这是 git 内部实现用的命令
会把 commit 的内容打出来
你会注意到它和黑板上的结构一致
它的 blob tree 的 hash 是这个
作者是这个
commit message 是这个
然后我可以继续深入
`cat-file -p` 这个 hash
你可以看到树里只有一个文件
这个 blob 的 hash 是这个
[758]
再套一层娃
它就会给我显示文件的实际内容了
所以这就是用来展示
git 对象数据的内部命令
那边还有提问？
学生：你为啥要手动指定要加的文件
学生：而不是直接把所有修改 commit 了
问得好
这个同学问 为啥不直接 commit 所有改变
而是要来个 `git add`
实际上 我们可以一次 commit 所有改变
如果你跑 `git commit -a`
就会对所有纳入版本管理的文件的改变
进行 commit
也就是在前一个快照里有
而且之后被修改过的文件
但是不包括新文件
也有 `git add` 的变体
`git add :/` 会从项目根目录递归 stage 所有文件
#REVIEW 没有任何问题  只是给你看看可爱的 :/
在高层次来说
把 `git add` 和 `git commit` 分开
`git commit` 不对整个目录进行快照
这样设计的原因是
你通常来说并不想把所有东西加入快照 #REVIEW svn 哈哈
举几个例子
[785]
一个是我在勤奋工作 #REVIEW packing
我写了两个新功能
我并不是很想把新功能 A 和 B
打到一个快照里
说我实现了 A 和 B
我更想分成两个快照
先是实现 A
然后是实现 B
然后第一个快照有 A 功能
第二个有 A 和 B 功能
有了 `git add` 和 staging 区
才能够使我这样做
另外一个是
假设我在修 bug
然后我输出调试代码里满地都是
然后我终于找到了是多加了 1
然后我把它修了以后想来个新快照
但是那些快照最好不要有输出调试
而只是去掉那个 +1
我可以手动删掉所有调试输出
而 git 就很香
它可以让我选择 add 哪一块修改
例如只 add 删掉这个 -1 这行
然后就可以 commit 来个新快照
之后就可以把输出调试全部丢掉了
这是 staging 区的两种用法
也因此没有直接快照所有修改的命令
学生：还有一个例子 你目录下面有个日志文件
Jon 说到了
你目录下面有个你程序打出来的日志文件
你快照的时候把这个加入快照没意思啊
以及其他的一些 例如编译时的 `.o` 啥的二进制文件
这些东西你也不应该加进版本历史里
[836]

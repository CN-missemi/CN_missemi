好，我们开始上今天的课了

所以在我们实际开始之前，一条小贴士

根据大家的反馈来看

你们好多人都觉得

每天上完课后的答疑时间

都只能问关于当天的课程内容的东西

但事实上不是这回事儿

你可以在答疑时间问

关于所有我们所教的所有课程的问题

不管它是前一天的还是上一周的

甚至我们课上没讲过的东西

只要你对这个东西好奇

所以可以在答疑时间问任何问题

答疑在 32 号楼 G9 休息室

32 号楼也被称作史塔特科技中心[*] 
* （MIT内一栋著名的复合式建筑）

这栋楼由两个结构构成

分别是 G 塔和 D 塔 [*]
* （G 塔又称 Gates Tower，D 塔又称 Dreyfoos Tower [维基百科]）

我们是在 G 塔的九楼答疑

所以如果你坐电梯上去

那你一出电梯，休息室就在你右手边

所以今天呢

我们要讨论下版本控制系统

一开始我先想了解下

你们这些人

之前用没用过版本控制系统

如果你之前用过 Git、Subversion、Mercurial [*]
* 这三个词分别是无用的饭桶、破环颠覆、汞制剂，这代表着人们对版本管理的态度

或者其他的版本控制系统

那你就举个手

啊好，看来用过的人还不少

所以我就不讲版本控制系统相关的

一些比较烂大街的东西了

我们将讲一些

关于 `git` 的比较细节的东西

比如它的数据模型和内在实现

但我们先大概讲一下

版本控制系统是用来

跟踪源代码、文件、文件夹修改的工具

正如“版本控制系统”这个名字所说

这些工具帮我们追踪

我们对一组文件做出的更改

并且还可以让团队合作更加便捷

所以它们在一群人一起开发软件项目时

非常有用

版本控制系统通过（记录）一串快照的方式

来追踪对一个文件夹或它的内容的更改

所以你就能把整个文件夹的状态

还有里面的软件项目之类的玩意

像拍照一样定格下来

所以你就有一串快照

每个快照都描述了

你跟踪的这个顶层目录下的

所有文件和文件夹的信息

然后版本控制系统维护的东西

除了你对这些文件内容的实际更改之外

还有一堆元数据（Metadata）

这是为了让我们弄清楚

“某个文件的某个修改是谁写的”

“某个修改是什么时候发生的”

所以版本控制系统维护了

像是作者、提交时间戳

之类的元数据

然后你也可以给这些快照附加其他你想要的额外信息

或者干一些类似的事

这就是为什么版本控制系统用处很大

就算你自己一个人做项目的时候

它也很有用

你可以用它来看

你之前写的旧版本的代码

可以通过看提交信息来弄明白

为什么当时要做这个更改

还可以通过分支来

不冲突地同时做多个工作

或者一边修 bug

一边独立地写其他新特性

所以版本控制系统是无价之宝

对于自己一个人写东西或者写小型项目也是如此

就比如我认为这门课的讲师

除了做研究和写大型软件项目时

他甚至还在安排作业和课程设计

这些小型的东西上也用 `git` 

当然和其他人一起工作的时候

版本控制是一个非常强大的工具

比如更新代码的补丁

或者解决不同人写同一份代码时

引发的内容冲突

它就很有用

所以在你自己工作

或者和其他人一起的时候

`git` 都是个很强大的工具

此外它还有个比较香的功能

就是可以让你回答一些在其他情况下

比较难回答的问题

比如这个软件项目里某个模块是谁写的

或者谁改了某个软件项目里的某行代码

以及为什么要改这行代码

以及这行代码是什么时候由谁改的 [*]
* 哈哈 原来是自己改的

此外版本控制系统还有一些

其他的很强大的功能

在今天课程的末尾我们会讲

或者如果来不及讲了

你也可以自己去找课程笔记 [*]
* 在课程官网

好 现在我们假设你有个已经

搞了好多年的项目

然后你注意到这个项目的

一些莫名其妙的东西不工作了

比如有些单元测试过不了了

并且它不是这个时候才挂掉的

它可能在之前某个时间挂了

但是你并不确定什么时候有的这个毛病

好，版本控制系统有个

自动查证这种事情的方法

就比如你去给它一份单元测试的代码

现在的程序会在这个单元测试上挂掉

但是你知道过去的某个版本上，它不会挂

然后它就可以去二分查找代码历史 [*]

* 一种算法，可以在值单调的列表（数组）里快速定位元素

搞清楚具体是哪一次代码更改让它挂了

所以只要你知道该如何正确使用这些工具

你就能发现很多又强又炫酷的功能

事实上“市面”上有很多版本控制系统 [*]
* 有开源的，也有商用收费的

而 `git` 则成为了版本控制的某种事实标准

所以这就是为什么

今天的课我们主要讲 `git`

我想给你们看个梗图

这个图刚刚还在屏幕上来着……让我重新找找

所以这是个 xkcd 漫画

这个漫画因为它的绘画风格而出名

我来给你们朗读一下

“这是 `git`，它能通过一个优美的

图论里面的树型模型 [*]
* (此处应是指 Merkle Tree, Git 基于这种数据结构设计，尽管 Git 使用的版本应当被称为 Merkle DAG)

来跟踪项目里的分工工作”

“好，那么我们怎么用呢”

“不知道，就记住这些 Shell 命令

使用它们来同步数据

如果出错了就先把你的文件存到别的地方

然后删掉项目，再下一份新的”

我猜接下来你们有些人不想举手

不过还是要说，如果你之前这样用过 `git`

请举一下手

我在学这个工具的时候肯定这样干过

所以你们中的好多人之前也这么干过

所以这门课的目的就是

让你学点东西

以后你就不会这样用 `git` 了

不幸的是，就像这张图画的那样

`git` 的接口设计得很可怕

它提供的行为抽象全是坑

因为这个原因，我们相信

从接口开始，自顶向下学 `git` 的话

可能不是个好方法

并且这样子可能会让你更加迷惑

不过你也可以像这个图里那样

记住一大堆命令

并且把它们想成魔法咒语

至于这些命令为什么能用也不管

反正它就是能用

但之后你就得像这个图里这样

只要有什么东西出问题了

你就得删了重下

所以尽管 `git` 的接口很丑

但它的内在设计和想法事实上都很美

这种丑陋的接口只能死记硬背

但其内在的优雅设计

其实是可以被理解的

一旦理解了 `git` 的内部实现

也就是它不那么复杂的数据模型

然后你就可以学习接口了

你可能得记住一些东西

但是你可以通过理解

命令是怎么操作内在数据结构的

去理解这些命令到底在干啥

我们今天讲 `git` 的安排

第一部分是关于数据模型的

几乎都是理论

讲一下文件和文件夹，历史快照的模型

然后我们会尝试几个 `git` 命令

最后在（讲义的）资源和练习里

我将会给你一些教程

这些教程能教给你所有细节

因为实际上你要学很多不同的命令

对今天的教学计划

有什么不明白的吗？

好，所以我们现在开始吧

可能有好多比较临时的

能拿来做版本控制的手段

并且我猜部分同学可能之前这样做过

就比如你有些文件

或者一个文件夹里有一堆不同的文件

它们组成了一个软件项目

然后你想跟踪这些文件的更改

你显然可以，比如说

每天把整个文件夹复制一份

然后给它标个时间戳

当你需要和其他人合作的时候

你可以把把整个文件夹压成一个压缩包

然后用电子邮件发给别人

然后如果你和你的朋友

正在写同一个软件的两个不同的部分

你们就可以各写各的

然后你们中的一个人要把压缩包

拿邮件发给另一个人

然后手动把对方给代码做的修改

用合适的方法复制下来

粘贴到自己的代码里

然后你的程序里

就同时有了你们两个人写的代码

如果你们之前这样合作过的话

举一下手

我之前肯定这样干过的，你们也有好多

`git` 可以让我们避免干这种

并不怎么优美的工作

它有个经过仔细考虑的模型

这个模型可以让一些

你想做的事变得更加简单

比如追踪你自己在项目里的更改

或者和其他人合作等等

所以 `git` 的这个设计得很棒的模型

给你提供了像是分支、合作

还有从其他人那合并更改

诸如此类令人舒适的功能

`git` 的模型

是一组经过抽象，放在某个顶层目录下的

文件和文件夹

你可能对这种抽象挺熟悉的

因为你电脑上也是这样放文件和文件夹的

所以我给你们来个例子

你有个根目录文件夹

我就叫它 root 吧

这个目录里面有个叫 `foo` 的文件夹

然后 `foo` 里面又有个

叫 `bar.txt` 的文件

这个文件里可以写点东西

比如 `hello world`

回头看看这个根目录

里面有个目录

那它自然也可以有个文件

这个文件里也可以

写点东西

好了，挺简单的

`git` 用了个术语——树（tree）来表示

这些文件和文件夹以及这个最顶上的结构

就叫做树

所以这是个文件夹

然后这些我们平时叫文件的东西被称作 `blob`

好，现在我们有个文件和文件夹构成的模型

并且这个模型还是递归定义的

树里面可以有别的树

树里面还可以有文件

但显然文件里不能有树

好，现在我们有一个由文件和文件夹构成的模型

然后最顶上这个我标出来的东西

就是我们正在跟踪的

被称作为根目录的东西

就比如你电脑上的一个文件夹

这个文件夹对应着一个软件项目

现在我们有了文件和文件夹的模型

那么我们用什么模型来维护历史更改呢

你可以想想一种比较简单的方式

就是你给这整棵树像照相一样“拍”一个快照

然后历史更改就是

由快照所构成的线性序列

你基本上可以把这个东西想成

你有一大堆标上了日期和时间的

文件夹的拷贝

但 `git` 的实现

并不是用的这样简单的线性模型

它用了一个更有意思的东西

你之前可能听说过这个术语

`git` 有一个用有向无环图 [*]
*（Directed Acylic Graph，一种图论结构）

来维护更改历史的模型

这个挺像一个听起来比较有意思的数学名词

但它实际上完全没有那么复杂

在 `git` 里，每个快照都有一些父节点

然后我们想知道

众多更改之间的前后关系

假设我现在用圆圈

来表示一个单独的快照

这个圈表示整棵树里的所有内容

我整个项目的所有文件和文件夹

正处在某个状态

然后我改了一些文件

这样它就在另一个状态了

然后用我又加了一些文件，它就又去了另一个状态

每个状态都有个指针

指向它之前的状态

到现在为止，这还是个线性的历史更改

但是我们现在做点有意思的事

你可以从某个快照分叉你的历史更改

也就是说

我想要基于这个版本的更改

像这样创建一个新的快照

通过这种历史更改模型

你可以在做一些类似于

这是我的开发主线

我到这了

现在我有两个不同的任务

一个是我想给我的项目

加点有意思的新特性

这个我要写好几天

但是除此之外，有人报给了我一个 bug

我需要找出来这个 bug，然后赶快修好它

我不想在同一条开发流程线里

同时干这两个工作

`git` 有它自己的一套

能够在更改历史上创建两个分支的方法

通过这种方法，可以临时地并行工作

还能让它们不相互影响

所以我现在创建一个

表示我的项目中

某个正常工作的状态的基底快照

然后从这，我可以创建一个

拿来实现新功能的快照

所以这里就有了

基底项目加上一个新功能

所以我在它上面写个 `+feature`

然后类似的，从这里

我可以回到最初的快照

因为我不想在写新功能的同时修 bug

然后可以到这，再去修 bug

建一个不同的快照

这个快照只包括 bug 修复

但是不包括新功能

最后等我写完这两块东西后

我想把它们一起合并回我正常情况下的代码

这样我的代码就既有新功能又有 bug 修复

所以最后我可以建一个新快照

它合并了这两个快照里的更改

然后这个新快照

以刚刚的两个快照作为父节点

然后这个版本

既有新特性，又有 bug 修复

所以 `git` 这种历史模型

相比于线性的一串快照来说

就显得很炫酷

我想要能支持同时写多个不同的东西

然后也能把我在不同的并行分支里

对它们的修改合并起来。有问题吗？

_[同学的提问]_

好，这是个很不错的点

似乎当你合并东西的时候

你会遇到一些你没想到的错误

你可以设想

这个新特性改了一些代码

一起把 bug 修了 [*]
* ？？？这真的可能吗？？？

或者你想， bug 修复把新特性搞坏了

或者一些类似的东西


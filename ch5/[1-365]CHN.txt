好，我们开始上今天的课了
所以实际上
根据投票情况来看
如果我不告诉你们的话
你们好多人都觉得
#REVIEW[关于Office hour的翻译] 每天上完课后的答疑时间
都只能问关于当天的课程内容的东西
但事实上这不对
你可以在答疑时间问
关于所有我们所教的所有课程的问题
不管它是前一天的还是上一周的
甚至我们课上没讲过的东西
只要你对这个东西好奇
所以可以在答疑时间问任何问题
#REVIEW 答疑在32号楼G9休息室
32号楼也被称作史塔特科技中心[*] （MIT内一栋著名的复合式建筑）
这栋楼由两个结构构成
分别是 `G塔` 和 `D塔` [*] （`G塔` 又称 `Gates Tower`，`D塔` 又称 `Dreyfoos Tower` [维基百科]）
我们是在 `G塔` 的九楼答疑
所以如果你坐电梯上去
那你一出电梯，休息室就在你右手边
所以今天呢
我们要讨论下版本控制系统
一开始我先想了解下
你们这些人
之前用没用过版本控制系统
如果你之前用过 `git`、`subversion`、`mercurial`
或者其他的版本控制系统
那你就举个手
啊好，看来用过的人还不少
所以我就不讲版本控制系统
相关的一些比较烂大街的东西了
我们将讲一些
关于 `git` 的比较细节的东西
比如它的数据模型和内在实现
但我们先大概讲一下
版本控制系统是用来
跟踪对源代码、文件、文件夹
的修改的工具
就像是“版本控制系统”这个名字那样
这些工具帮我们追踪
我们对一组文件做出的更改
并且还可以让团队合作更加便捷
所以它们对于
和一群人一起开发软件这种事是很有用的
版本控制系统通过一串快照这种方式
来追踪对一个文件夹或它的内容的更改
所以你就能把整个文件夹的状态
还有里面的软件项目之类的玩意
像拍照一样定格下来
所以你就有一串快照
每个快照都描述了
你跟踪的这个顶层目录下的
所有文件和文件夹的信息
然后版本控制系统维护的东西
除了你对这些文件内容的实际更改之外
还有一堆元数据
然后这个呢是为了给我们
提供弄清楚
“某个文件的某个修改是谁写的”
“某个更改是什么时候做的”
这些问题的可能性
所以版本控制系统维护了
像是作者、提交时间戳
之类的元信息
然后你也可以给这些快照附加其他你想要的额外信息
或者干一些类似的事
这就是为什么版本控制系统很有用
然后它甚至在你自己一个人做项目的时候
也很有用
你可以用它来看
你之前写的旧版本的代码
可以通过看提交信息来弄明白
为什么当时要做这个更改
还可以通过分支来
不冲突地同时做多个工作
或者一边修 bug 一边
独立地写其他新特性
所以版本控制系统
是一个非常有价值的工具
对于自己一个人写东西或者写小型项目也是如此
#REVIEW[此行以及后续几行] 就比如我认为这门课的讲师
在除了做研究时和
写大型软件项目之外
他甚至还在作业和课程设计
这些小型的东西上也用 `git` 
当然和其他人一起工作的时候
版本控制是一个非常强大的工具
就比如在你想要修改一下代码
来解决不同人在写同一块代码时
所引发的冲突的时候
它就很有用
所以在你自己工作
或者和其他人一起的时候
`git` 都是个很强大的工具
#REVIEW[整洁？] 此外它还有个比较整洁的功能
就是可以让你回答一些在其他情况下
比较难回答的问题
比如这个软件项目里某个模块是谁写的
或者谁改了某个软件项目
里的某行代码
以及为什么要改这行代码
以及这行代码是什么时候由谁改的
此外版本控制系统还有一些
其他的很强大的功能
我们在今天的课程结束时
会讲到这些功能
或者如果你没有时间的话
你可以自己去找我们的课程笔记
#REVIRE[衔接没太搞懂] 考虑假设你有个已经
搞了好多年的项目
然后你注意到这个项目的
一些有趣的东西不工作了
比如有些单元测试过不了了
并且它不是这个时候才挂掉的
它可能在很久以前就挂掉了
但是你并不知道什么时候改的代码让它挂了
好，版本控制系统有个自动识别
这种事情的方法
就比如你去给它个单元测试的代码
你现在的程序会在这个单元测试上挂掉
但是你知道过去的某个版本上，它不会挂
然后它就可以去二分查找[*](一种算法，用以在有序列表里快速定位元素)代码历史
最终就可以找出来具体
是哪一次代码的更改让它挂了
所以只要你知道该如何正确使用这些工具
你就能找到很多又强又炫酷的
功能
一共有很多版本控制系统
而 `git` 则成为了版本控制的
某种事实标准
所以这就是为什么
今天的课我们主要讲`git`
#REVIEW[one comic我翻译为梗图（比较切合实际？）] 我想给你们看个梗图
这个图刚刚还在屏幕上来着······让我重新找找
所以这是个 xkcd 漫画
这个漫画因为它的绘画风格而出名
我来给你们朗读一下
“这是 `git` ，它能通过一个优美的
图论[*](研究图的理论)里面的树型模型
来跟踪项目里的分工工作”
“好，那么我们怎么用呢”
“不知道，就记住这些 `shell` 命令
把它们打到终端里来跑
如果出错了就先把你写的东西存到别的地方
然后删掉项目，再下一份新的”
我猜接下来你们有些人不想举手
那么，如果你之前这样用过 `git`
请举一下手
我在学这个工具的时候肯定这样干过
所以你们中的好多人之前也这么干过
所以这门课的目的就是
让你学点东西
以后你就不会这样用 `git` 了
不幸的是，就像这张图画的那样
`git` 的接口设计地很可怕
它是个全是坑的抽象
因为这个原因，我们相信
从接口开始，自顶向下学 `git` 的话
可能不是最好的方法
并且这样子可能会让你更加迷惑
不过你也可以像这个图里那样
记住一大堆命令
并且把它们想成魔法咒语
#REVIEW[这句我看不懂] 
但之后你就得像这个图里这样
只要有什么东西出问题了
你就得删了重下
所以尽管 `git` 的接口很丑
但它的内在设计和想法事实上都很美
虽然你要记住这个丑陋的接口
但是事实上你也可以理解
内在的优雅设计
并且一旦你理解了 `git` 的内部实现
也就是 `git` 那
并不那么复杂的数据模型
然后你就可以学习接口了
你可能得记住一些东西
但是你可以通过理解
命令是怎么操作内在数据结构的
去理解每个它们到底在干啥
顺带说一句
我们今天讲 `git` 的第一部分就是关于数据模型的
概括地来说就是
我们怎么把文件和文件夹的历史快照抽象成模型
以及它们之间是怎么
关联的
然后在这之后我将会带你
看几个 `git` 命令
最后在资源和练习里
我将会给你一些教程
这些教程能教给你所有细节
#REVIEW[奇怪的语义] 因为你最终要学很多不同的命令
有人对今天我打算的讲课顺序
有疑问的吗
好，所以我们现在开始吧
可能有好多比较临时的
能拿来做版本控制的手段
并且我猜你们中的一些人之前可能这样子做过
就比如你有些文件或者文件夹
或者一堆不同的文件
这些文件组成了一个软件项目
然后你想跟踪这些文件的更改
你显然可以简单地
每天把整个文件夹复制一份
然后给你的备份标个时间戳
当你想要干像是和其他人合作这种事的时候
你可以把把整个文件夹压成一个压缩包
然后用电子邮件发给别人
然后如果你和你的朋友
正在写同一个软件的两个不同的部分
你们就可以各写各的
然后你们中的一个人要把压缩包
拿邮件发给另一个人
然后手动把对方给代码做的修改
用合适的方法复制下来
粘贴到自己的代码里
所以最终你就有了一块
有你们两个人写的东西的代码
如果你们之前这样干过的话
举一下手
我之前肯定这样干过的，你们也有好多
`git` 可以让我们避免干这种
并不怎么优美的活
它有个经过仔细考虑的模型
这个模型可以让一些
你想做的事变得更加简单
比如追踪你自己在项目里的更改
或者和其他人合作等等
所以 `git` 的这个设计地很棒的模型
给你提供了像是分支、合作
还有从其他人那合并更改之类的
类似的令人舒适的功能
`git` 的模型
是一组经过抽象到，放在某个顶层目录下的
文件和文件夹
你可能对这种抽象挺熟悉的
因为你电脑上
也是这样放文件和文件夹的
所以我给你们来个例子
你有个根目录文件夹
我就叫它 `(root)` 吧
这个目录里面有个叫 `foo` 的文件夹
然后 `foo` 里面又有个
叫 `bar.txt` 的文件
这个文件里可以写点东西
比如 `hello world`
回头看看这个根目录
里面有个目录
那它自然也可以有个文件
这个文件里也可以
写点东西
好了，挺简单的
`git` 用了个术语 `树(tree)` 来表示
这些文件和文件夹
以及这个最顶上的东西
所以这是个文件夹
然后这些我们平时叫文件的东西被称作 `blob`
好，现在我们有个文件和文件夹构成的模型
并且这个模型还是递归定义的
树里面可以有别的树
树里面还可以有文件
但显然文件里不能有树
好，现在我们有一个由文件和文件夹构成的模型
然后最顶上这个我标出来的东西
就是我们正在跟踪的
被称作为根目录的东西
就比如你电脑上的一个文件夹
这个文件夹对应着一个软件项目
现在我们有了文件和文件夹的模型
那么我们用什么模型来维护历史更改呢
你可以想想一种比较简单的方式
就是你给这整棵树像照相一样“拍”一个快照
然后历史更改就是
由快照所构成的线性序列
你基本上可以把这个东西想成
你有一大堆标上了日期和时间的
文件夹的拷贝
但 `git` 的实现
并不是用的这样简单的线性模型
它用了一个更有意思的东西
你之前可能听说过这个术语
`git` 有一个用`有向无环图`[*]（`Directed Acylic Graph` ，一种图论数据结构）
来维护更改历史的模型
这个挺像一个听起来比较有意思的数学名词
但它实际上完全没有那么复杂
在 `git` 里，每个快照都有一些父节点
#REVIEW[迷惑] 然后我们想知道
哪个更改在其他哪些更改之前
假设我现在用圆圈
来表示一个单独的快照
这个圈表示整棵树里的所有内容
我整个项目的所有文件和文件夹
正处在某个状态
然后我改了一些文件
这样它就在另一个状态了
然后用我又加了一些文件，它就又去了另一个状态
每个状态都有个指针
指向它之前的状态
到现在为止，这还是个线性的历史更改
但是我们现在做点有意思的事
你可以从某个快照分叉你的历史更改
也就是说
我想要基于这个版本的更改
像这样创建一个新的快照
通过这种历史更改模型
你可以在做一些类似于
这是我的开发主线
我到这了
现在我有两个不同的任务
一个是我想给我的项目
加点有意思的新特性
这个我要写好几天
但是除此之外
有人报给了我一个 bug
我需要找出来这个 bug ，然后赶快修好它
我不想在同一条
开发流程线里
同时干这两个工作
#REVIEW[凑不够了]
`git` 有它自己的一套，能够在更改历史上创建分支
进而把它分成两个分叉的方法
通过这种方法，可以临时一起搞这两个不同的东西
还能让它们不相互影响
所以我现在创建一个
表示我的项目的某个能跑的状态的基底快照
然后从这，我可以创建一个
拿来实现新功能的快照
所以这里就有了
基底项目加上一个新功能
所以我在它上面写个 `+feature`
然后类似的，从这里
我可以回到最初的快照
因为在写新功能的时候不想修 bug
然后可以到这，再去修 bug
建一个不同的快照
这个快照只包括 bug 修复
但是不包括新功能
最后等我写完这两块东西后
我想把它们一起合并回
我正常情况下的代码
这样我的代码就既有新功能又有 bug 修复
所以最后我可以建一个
合并了这两个快照里的更改的新快照
然后这个新快照
以刚刚的两个快照作为父节点
然后这个版本
既有新特性，又有 bug 修复
所以 `git` 这种历史模型
相比于一个
序列形式的一串快照来说
就显得很炫酷
我想要能支持
同时写多个不同的东西
然后也能把我在不同的分支里
对它们的修改
合并起来。有问题吗？
好，这是个很不错的点
似乎当你合并东西的时候
你会遇到一些你没想到的错误
你可以设想
这个新特性改了一些代码
一起把 bug 修了
或者你想， bug 修复把新特性搞坏了
或者一些类似的东西